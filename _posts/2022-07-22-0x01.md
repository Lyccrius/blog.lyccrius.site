---
layout: post
title:  "《算法竞赛进阶指南》0x01 位运算"
date:   2022-07-22 10:16:56 +0800
categories: course sfjs jjzn
---

0x代表16进制  
0x00~0xFF是以最高位二进制位为正负符号位的“补码”形式表示的8位二进制数。  
8位二进制数对应char类型，范围为-128~127，其中0xFF代表-1，0x7F代表最大值127。

## 补码 
### 32位无符号整数 unsigned int：
直接把这32位编码C看作32位二进制数n。  
### 32位有符号整数 int：
以最高位为符号位，0表示非负数，1表示负数。  
对于最高位为0的每种编码C，直接看作32位二进制数S。  
同时，定义该编码按位取反后得到的编码~C表示的数值为-1-S。  
在补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在32为补码下做**最高位不进位**的二进制加减法运算。  
> 正数：原码=反码=补码  
> 负数：反码=原码除符号位取反；补码=反码+1  
> 个人理解：负数补码的符号位相当于`-2147483648`，其余位与正数表示数值相同。  

#### 0x3F 3F 3F 3F
满足以下两个条件的最大整数。  
1. 整数的两倍不超过 0x7F FF FF FF，即int能表示的最大正整数。
2. 整数的每8位（每个字节）都是相同的。

#### memset
`memset(a, val, sizeof(a));`  
把数值 val(0x00~0xFF) 填充到数组a的每个字节上。  
1个int占用4个字节，所以只能赋值出“每8位都相同”的int。  
综上所述，0x7F 7F 7F 7F 是能初始化出的最大数值。  
把数值初始化成正无穷时，为避免加法算数上溢或繁琐的判断，用`memset(a, 0x3f, sizeof(a))`来代替。  

## 移位运算

### 左移
在二进制表示下把数字同时向左移动，低位以0填充，高位越界后舍弃。
> 1 << n = $2^n$, n << 1 = 2n  

### 算数右移
在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。  
> n >> 1 = $\lfloor {n \over 2.0} \rfloor$  

算数右移等于除以2向下取整，(-3) >> 2 = -2，3 >> 1 = 1。  
“整数/2”在C++中实现为“除以2向零取整”，(-3) / 2 = -1，3 / 2 = 1。

### 逻辑右移
在二进制位补码表示下把数字同时向右移动，高位以0填充，低位越界后舍弃。  
一般编译器均使用算数右移。  
默认右移操作采用算数右移。