---
layout: post
title:  "《算法竞赛进阶指南》0x01 位运算"
date:   2022-07-22 10:16:56 +0800
categories: course sfjs jjzn
---

0x 代表 16 进制  
0x00~0xFF 是以最高位二进制位为正负符号位的“补码”形式表示的 8 位二进制数。  
8 位二进制数对应 char 类型，范围为 -128~127，其中 0xFF 代表 -1，0x7F 代表最大值 127。

## 补码 
### 32 位无符号整数 unsigned int：
直接把这 32 位编码 $$C$$ 看作 32 位二进制数 $$N$$。  
### 32 位有符号整数 int：
以最高位为符号位，0 表示非负数，1 表示负数。  
对于最高位为0的每种编码 $$C$$，直接看作 32 位二进制数 $$S$$。  
同时，定义该编码按位取反后得到的编码 $$~C$$ 表示的数值为 $$-1-S$$。  
在补码下每个数值都有唯一的表示方式，并且任意两个数值做加减法运算，都等价于在 32 为补码下做**最高位不进位**的二进制加减法运算。  
> 正数：原码=反码=补码  
> 负数：反码=原码除符号位取反；补码=反码+1  
> 个人理解：负数补码的符号位相当于 `-2147483648`，其余位与正数表示数值相同。  

#### 0x3F 3F 3F 3F
满足以下两个条件的最大整数。  
1. 整数的两倍不超过 0x7F FF FF FF，即int能表示的最大正整数。
2. 整数的每8位（每个字节）都是相同的。

#### memset
`memset(a, val, sizeof(a));`  
把数值 $$val$$(0x00~0xFF) 填充到数组a的每个字节上。  
1 个 int 占用 4 个字节，所以只能赋值出“每 8 位都相同”的int。  
综上所述，0x7F 7F 7F 7F 是能初始化出的最大数值。  
把数值初始化成正无穷时，为避免加法算数上溢或繁琐的判断，用`memset(a, 0x3f, sizeof(a))`来代替。  

## 移位运算

### 左移
在二进制表示下把数字同时向左移动，低位以 0 填充，高位越界后舍弃。
> $$1 << n = 2^n, n << 1 = 2n  $$

### 算数右移
在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。  
> $$n >> 1 = \lfloor {n \over 2.0} \rfloor$$  

算数右移等于除以 2 向下取整，$$(-3) >> 2 = -2，3 >> 1 = 1$$。  
“整数/2”在C++中实现为“除以2向零取整”，$$(-3) / 2 = -1，3 / 2 = 1$$。

### 逻辑右移
在二进制位补码表示下把数字同时向右移动，高位以0填充，低位越界后舍弃。  
一般编译器均使用算数右移。  
默认右移操作采用算数右移。