---
layout: post
title:  day1 高级数据结构
date:   2022-08-01
author: 吕秋实
categories: course qbxt 66
---

## 线段树

### 建树

```cpp
    void Build(int u, int l, int r) {
        if (l == r) {
            node[u].val = a[l];
            return;
        }
        int mid = l + r >> 1;
        node[u].lson = u * 2;
        node[u].rson = u * 2 + 1;
        Build(node[u].lson, l, mid);
        Build(node[u].rson, mid + 1, r);
        PushUp(u);
    }
```

#### 节点上传 PushUp

```cpp
    void PushUp(int u) {
        node[u].val = node[node[u].lson].val + node[node[u].rson].val;
        return;
    }
```

### 区间求和

```cpp
    int Query(int u, int l, int r) {
        if (l > node[u].r || node[u].l > r) return 0;
        if (l >= node[u].l && node[u].r <= r) return node[u].val;
        return Query(node[u].lson, l, r) + Query(node[u].rson, l, r);
    }
```

### 定理

* 任意一个区间都能在线段树上划分成 $\mathcal O(\log n)$ 个区间。
* 证明：反证法（略）。

### 单点修改

* 显然只会修改 $\mathcal O(\log n)$ 个节点，从下往上 PushUp 即可。

### 区间修改

* 区间修改的修改点数可能会达到 $\mathcal O(n)$ 级别，这时就需要使用懒标记。

#### 懒标记

* 考虑在某些节点打上形如：该节点所表示的区间内的所有元素的值都需要做一个特定的变化的标记。
* 这样考虑区间修改时可以只更新到更新区间完全覆盖线段树节点区间位置，然后在被覆盖的区间上打上懒标记。

#### 标记下传 PushDown

* 考虑线段树一定都是从上到下访问的，那么我们在访问的过程中，如果遇到有标记的点，那么它子树内的点的信息一定是不对的，所以我们需要将这个标记下传到它的儿子们，并更新它的儿子的信息。显然只有在区间加的操作里，相同节点上的懒标记是可以合并的，所以懒标记个数不会爆炸。
* 懒标记的好处就是每次修改我们不需要去更新它修改的全部信息，而是打一个标记，在需要用到某些需要修改信息的节点时再修改。

#### 时间复杂度

* 显然 PushDown 并不影响时间复杂度，单次区间修改的复杂度跟区间求和类似，都是 $\mathcal O(\log n)$ 的。

### 代码示例

```cpp
struct SegmentTree {
    struct Node {
        int val;
        int tag;
    } node[maxN * 4 + 10];

    void Mark(int u, int val) {
        node[u].val += val * (node[u].r - node[u].r + 1);
        node[u].tag += val;
        return;
    }

    void PushUp(int u) {
        int lson = node[u].lson;
        int rson = node[u].rson;
        node[u].val = node[lson].val + node[rson].val;
        return;
    }

    void PushDown(int u) {
        if (node[u].tag == 0) return;
        Mark(node[u].lson, node[u].tag);
        Mark(node[u].rson, node[u].tag);
        node[u].tag = 0;
        return;
    }

    void Build(int u, int l, int r) {
        if (l == r) {
            node[u].val = a[l];
            return;
        }
        int mid = l + r >> 1;
        node[u].lson = u * 2;
        node[u].rson = u * 2 + 1;
        Build(node[u].lson, l, mid);
        Build(node[u].rson, mid + 1, r);
        PushUp(u);
        return;
    }

    void Modify(int u, int l, int r, int s, int t, int val) {
        if (s > r || l > t) return;
        if (s <= l && r <= t) {
            Mark(u, val);
            return;
        }
        int mid = l + r >> 1;
        PushDown(u);
        Modify(node[u].lson, l, mid, s, t, val);
        Modify(node[u].rson, mid + 1, r, s, t, val);
        PushUp(u);
        return;
    }

    int Query(int u, int l, int r, int s, int t) {
        if (s > r || l > t) return 0;
        if (s <= l && r <= t) return node[u].val;
        int mid = l + r >> 1;
        PushDown(u);
        return Query(node[u].lson, l, mid, s, t) + Query(node[u].rson, mid + 1, r, s, t);
    }
} SGT;
```

### 种线段树前先思考的两件事

1. 维护的信息可合并吗？
2. 懒标记可合并吗？

### RMQ

||线段树|$\text{ST}$ 表|
|:--|:--|:--|
|预处理时间复杂度|$\mathcal O(n)$|$\mathcal O(n \log n)$|
|单次询问时间复杂度|$\mathcal O(\log n)$|$\mathcal O(1)$|
|空间复杂度|$\mathcal O(n)$|$\mathcal O(n \log n)$|

## 树状数组

* 树状数组支持：
  * 单点修改。
  * 前缀求和。

```cpp
struct BinaryIndexedTree {
    int node[maxN + 10];

    int lowbit(int val) {
        return val & -val;
    }

    void Add(int p, int val) {
        while (p <= n) {
            node[p] += val;
            p += lowbit(p);
        }
        return;
    }

    int Ask(int p) {
        int ret = 0;
        while (p >= 1) {
            ret += node[p];
            p -= lowbit(p);
        }
        return ret;
    }
} BIT;
```

### 线段树 $\text{VS}$ 树状数组

* 两者时间复杂度一致。
* 线段树：能实现的功能更多。
* 树状数组：更好写，常数更小。

## 例题 1

> 给定一个长度为 
$n$ 的排列 $p$，求将其冒泡排序所需要交换的次数。
> 
> $n \le 100000$

### Solution

* 考虑答案一定是满足 $1 \le i, j \le n, i \lt j, p[i] \gt p[j]$ 的 $i, j$ 对数。
* 于是考虑对于每一个位置，求出前面有多少比它大的数，最后全加起来即可。
* 考虑从左往右扫，维护一个数集 $S$，每当遇到一个数时，询问 $S$ 中比当前数小的数（比当前数大的数的个数可以由总数 $-$ 比当前数小的数得到），并把它加进去。
* 维护 $a[i]$ 表示 $S$ 中是否有值为 $i$ 的数，于是询问就是一个前缀和。用 $\text{BIT}$ 维护 $a$ 数组即可。

## 例题 2

> [P4868 Preprefix sum](https://www.luogu.com.cn/problem/P4868)

### Solution

* 考虑维护前缀和数组。修改一个值相当于对前缀和数组进行后缀加。求 preprefix sum 相当于求这个数组的前缀和。用线段树维护即可。

```cpp
    for (int i = 1; i <= N; i++) SGT.Modify(1, 1, N, i, N, a[i]);
    for (int i = 1; i <= M; i++) {
        std::cin >> opt;
        if (opt[0] == 'M') std::cin >> p >> x, SGT.Modify(1, 1, N, p, N, x - a[p]), a[p] = x;
        else std::cin >> p, std::cout << SGT.Query(1, 1, N, 1, p) << '\n';
    }
```

### Solution 2

* 考虑 $SS_i = \sum_{j = 1}^i a_j \times (i + 1 - j) = (i + 1) * \sum_{j = 1}^i a_j - \sum_{j = 1}^i a_j * j$
* 所以只用维护 $a_j$ 和 $a_j \times j$ 的前缀和即可。相当于维护单点修改和求前缀和，直接用树状数组维护即可。

```cpp
    for (int i = 1; i <= N; i++) S.Add(i, a[i]);
    for (int i = 1; i <= N; i++) SS.Add(i, a[i] * i);
    for (int i = 1; i <= M; i++) {
        std::cin >> opt;
        if (opt[0] == 'M') std::cin >> p >> x, S.Add(p, x - a[p]), SS.Add(p, (x - a[p]) * p), a[p] = x;
        else std::cin >> p, std::cout << S.Ask(p) * (p + 1) - SS.Ask(p) << '\n';
    }
```

## 例题 3

> [CF1527E Partition Game](https://www.luogu.com.cn/problem/CF1527E)

### Solution

* 设 $dp[i][j]$ 表示当前考虑到第 $i$ 段，第 $i$ 段末尾是 $j$ 的最小总代价，考虑怎么从 $dp[i - 1][]$ 转移到 $dp[i][]$。
* 考虑将一段的代价拆成，对于所有中间没有该数的相同的数对，它们的距离的和。
* 设一个数组 $b$，一开始 $b[] = dp[i - 1][]$。考虑预处理出 $last[i]$ 表示 $i$ 前面的第一个等于 $a[i]$ 的位置，从小往大枚举 $j$，考虑当 $j - 1$ 到 $j$ 的时候把 $a[j]$ 的贡献算进去，考虑 $a[j]$ 显然对 $b[1 \cdots last[j] - 1]$ 都有 $j - last[j]$ 的贡献，于是我们需要维护一个支持区间加和前缀求最小值的数据结构，用线段树即可。
* 时间复杂度 $\mathcal O(k n \log n)$。

```cpp
for (int i = 1; i <= n; i++) appear[a[i]].push_back(i);
    for (int i = 1; i <= n; i++) for (int j = 0; j < appear[i].size(); j++) if (j == 0) last[appear[i][j]] = 0; else last[appear[i][j]] = appear[i][j - 1];
    for (int i = 1; i <= n; i++) dp[i] = inf; dp[0] = 0;
    for (int i = 1; i <= k; i++) {
        SGT.Build(1, 0, n);
        for (int j = 1; j <= n; j++) {
            if (last[j] != 0) SGT.Modify(1, 0, last[j] - 1, j - last[j]);
            dp[j] = SGT.Query(1, 0, n, 0, j - 1);
        }
    }
```

## 例题 4

> 维护一个长度为 $n$ 的数组 $a[]$，支持：
> 1. 单点修改。
> 2. 给定 $l, r$，查询 $\max_{l \le x \lt y \le r} a[y] - a[x]$。
> 
> $n \le 1e5$ 

### Solution

* 考虑每个节点维护三个值，最小值，最大值和 $\max_{l \le x \lt y \le r} a[y] - a[x]$。
* 这些信息是可合并的。
* 询问直接合并分成的 $\log$ 个区间的信息即可。

## 动态开点线段树

* 对于每一个访问过的点重新编号。
* 用数组维护每一个点的左右儿子，和该点内维护的信息。
* 空间复杂度与访问的点数有关。

## 例题 5

* 维护一个长度为 $n$ 的数组 $a$，支持：
* 1. 单点修改。
* 2. 求区间 $a[l \cdots r]$ 中有多少个数的值为 $x$。
* $n \le 1e6, a_i \le n$

### Solution

* 对于每一个值，维护一颗线段树。支持单点修改和区间求和。动态开点即可。

## 可持久化线段树（主席树

* 维护所有历史版本的线段树。
* 维护每一个节点的左右儿子和权值。每一次修改时对于每一个访问的点建立一个新的节点，将这个节点修改后的权值和左右儿子填入新点内（本身权值不变）。

## 例题 6

> [CF 323C Two permutations](https://www.luogu.com.cn/problem/CF323C)

* 经典的二维数点问题。
* 考虑对于第 $i$ 时刻维护前 $i$ 行有哪些列有点。
* 每次单点修改，用主席树维护。
* 答案就是 $r_1$ 时刻的线段树 $[l_2, r_2]$ 的和 $–$ $(l_1 - 1)$ 时刻的线段树 $[l_2, r_2]$ 的和。 

```cpp
    int ncnt;
    int root[maxN + 10];

    void Modify(int &u, int l, int r, int k) {
        if (!u) u = ++cnt;
        node[u].val++;
        if (l == r) return;
        int mid = (l + r) / 2;
        if (mid >= k) Modify(node[u].l, l, mid, k);
        else Modify(node[u].r, mid + 1, r, k);
        return;
    }
```

```cpp
    for (int i = 1; i <= n; i++) appear[q[i]] = i;
    for (int i = 1; i <= n; i++) SGT.root[i] = SGT.root[i - 1], SGT.Modify(SGT.root[i], appear[p[i]]);
    std::cin >> m;
    for (int i = 1; i <= m; i++) {
        std::cin >> a >> b >> c >> d;
        l1 = std::min(f(a), f(b));
        r1 = std::max(f(a), f(b));
        l2 = std::min(f(c), f(d));
        r2 = std::max(f(c), f(d));
        x = SGT.Query(SGT.root[r1], l2, r2) - SGT.Query(SGT.root[l1 - 1], l2, r2);
        std::cout << x << '\n';
        x++;
    }
```

## 线段树合并

```cpp
    int Merge(int u, int v) {
        if (!u || !v) return u ^ v;
        int p = ++cnt;
        node[p].val = node[u].val + node[v].val;
        node[p].lson = Merge(node[u].lson, node[v].lson);
        node[p].rson = Merge(node[u].rson, node[v].rson);
        return p;
    }
```

* 单次合并的时间复杂度为两棵线段树的公共点数。
* 一般用于解决树上的问题，总复杂度可以根据总节点个数均摊分析。

## 例题 7

> [CF600E Lomsat gelral](https://www.luogu.com.cn/problem/CF600E)

* 对于每一个点用线段树维护每种颜色出现次数的最大值，线段树合并即可。
* 考虑还有机会跟其它树合并的节点的总数量。考虑每个节点的修改操作总共只会给总数量贡献 $\mathcal O(n \log n)$，然而每合并一次，总数量会减去公共点个数，复杂度加上公共点个数，所以总复杂度是 $\mathcal O(n \log n)$ 的。

```cpp
    void PushUp(int u) {
        int l = node[u].lson;
        int r = node[u].rson;
        if (node[l].val > node[r].val) {
            node[u].val = node[l].val;
            node[u].res = node[l].res;
        }
        if (node[l].val < node[r].val) {
            node[u].val = node[r].val;
            node[u].res = node[r].res;
        }
        if (node[l].val == node[r].val) {
            node[u].val = node[l].val;
            node[u].res = node[l].res + node[r].res;
        }
        return;
    }

    int Merge(int u, int v, int l, int r) {
        if (u == 0 || v == 0) {
            return u ^ v
        }
        if (l == r) {
            node[u].val += node[v].val;
            return u;
        }
        int mid = (l + r) / 2;
        node[u].lson = Merge(node[u].lson, node[v].lson, l, mid);
        node[u].rson = Merge(node[u].rson, node[v].rson, mid + 1, r);
        PushUp(u);
        return u;
    }

    lxl Query(int u) {
        return node[u].res;
    }
```

```cpp
    void DFS(int u, int from) {
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            if (v == from) continue;
            DFS(v, u);
            SGT.root[u] = SGT.Merge(SGT.root[u], SGT.root[v], 1, n);
        }
        SGT.Modify(SGT.root[u], 1, n, c[u]);
        vertex[u].res = SGT.Query(SGT.root[u]);
        return;
    }
```

## 二维线段树 / 树套树

* 对于第一维建一棵普通线段树，每个节点是一个动态开点线段树，来维护第二维。
* 对于第一维上表示区间 $[l_1, r_1]$，第二维上表示区间 $[l_2, r_2]$ 的点内维护左上角为 $(l_1, l_2)$，右下角为 $(r_1, r_2)$ 的矩形的信息。
* 树套树是一个更广的概念，它指的是任意一种树套任意一种树的结构，不只是线段树，还可以是平衡树等。

## 可并堆

* 顾名思义，可以合并的堆。
* 对于每个点，维护该节点子树距离这个节点最近的外节点的距离 $d[x]$。这里的 “外节点” 指的是不同时有左右儿子的节点。
* 对于每一个点，强制让 $d[l[x]] \ge d[r[x]]$，致使这个堆 “向左偏”，可以证明，这个堆的右链的长度是 $\mathcal O(\log n)$ 的。
* 合并时考虑两个堆的根节点哪个大，将大的那个作为新的根，将它的右子树与剩下的堆合并，一次合并的复杂度是 $\mathcal O(\log n)$ 的。

## 例题 8

> [P1552 [APIO2012] 派遣](https://www.luogu.com.cn/problem/P1552)

* 考虑对于一个领导者来说，一定选子树内薪水最小的若干个忍者，直到付不起工资为止。
* 考虑对于领导者 $x$，他选的人一定是 $x$ 的所有儿子选的人以及自己的并集的子集，所以直接把上述并集处理出来，每次不断地弹掉薪水最高的人，直到付得起工资即可，每个人的选人集合可以直接用可并堆维护。

```cpp
struct Heap {
    struct Node {
        int lson;
        int rson;
        int dist;
        lxl size;
        lxl cost;
        int weight;
    } node[maxN + 10];

    int ncnt;
    int root[maxN + 10];

    void PushUp(int u) {
        node[u].size = node[node[u].lson].size + node[node[u].rson].size + 1;
        node[u].cost = node[node[u].lson].cost + node[node[u].rson].cost + node[u].weight;
        return;
    }

    void Insert(int &u, int w) {
        if (!u) u = ++ncnt;
        node[u].weight = w;
        node[u].cost = w;
        node[u].size = 1;
        return;
    }

    int Merge(int u, int v) {
        if (!u || !v) return u + v;
        if (node[u].weight < node[v].weight) std::swap(u, v);
        node[u].rson = Merge(node[u].rson, v);
        PushUp(u);
        if (node[node[u].lson].dist < node[node[u].rson].dist) std::swap(node[u].lson, node[u].rson);
        node[u].dist = node[node[u].rson].dist + 1;
        return u;
    }

    void Pop(int &u) {
        u = Merge(node[u].lson, node[u].rson);
        return;
    }
} H;
```

```cpp
    void DFS(int u) {
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            DFS(v);
            H.root[u] = H.Merge(H.root[u], H.root[v]);
        }
        while (H.root[u] && H.node[H.root[u]].size && H.node[H.root[u]].cost > M) H.Pop(H.root[u]);
        ans = std::max(ans, H.node[H.root[u]].size * L[u]);
        return;
    }
```

## 平衡树

* 插入、删除、反转……

## Splay

* 需要维护的东西：$lson, rson, size, fa$。

### Rotate

```cpp
    void Rotate(int x) {
        int fa = f[x];
        int ga = f[fa];
        int wh = get(x);
        PushDown(fa);
        PushDown(x);
        ch[fa][wh] = ch[x][wh ^ 1];
        f[ch[x][wh ^ 1]] = fa;
        ch[x][wh ^ 1] = fa;
        f[fa] = x;
        if (ga) ch[ga][ch[ga][1] == fa] = x;
        f[x] = ga;
        PushUp(x);
        PushUp(fa);
    }
```

### Splay 的双旋

```cpp
    void Splay(int x, int goal) {
        for (int fa; (fa = f[x]) != goal; Rotate(x)) {
            if (f[fa] != goal) {
                if (get(fa) == get(x)) Rotate(fa);
                else Rotate(x);
            }
        }
        if (!goal) root = x;
    }
```

### Insert, Erase, FindKth, FindRnk

### 对区间进行操作

* 对于区间 $[l, r]$
* $Splay(l - 1, 0), Splay(r + 1, root)$

### Reverse

## FHQ Treap

* $\text{Treap = Tree + Heap}$
* 每个节点设置一个修正值，修正值需要满足堆的性质。

### Merge(x, y)

### Split(x, root1, root2, k)

### Erase, Insert, FindKth, FindRnk

### 对区间进行操作

## 例题 9

> [P2042 [NOI2005] 维护数列](https://www.luogu.com.cn/problem/P2042)

### Solution

* 平衡树板子题，里面的所有操作都可以用 $\text{Splay / Treap}$ 实现。

## 可持久化平衡树

* 基于旋转的平衡树（如 $\text{Splay}$）比较难可持久化。而非旋 $\text{Treap}$（$\text{FHQ Treap}$）可以可持久化。
* 方式：类似主席树，对于每一个访问到的需要修改的点，新建一个点即可。 

## 树链剖分

* $\text{HLD}$（轻重链剖分）

### 性质

1. 树上每个节点只属于一条重链。
2. 一条重链的 $dfn$ 是连续的。
3. 树上每个节点到根节点的路径上最多只会经过 $\log n$ 条轻边，即最多只会经过 $\log n$ 条重链。树上的任意一条路径也只会经过 $\mathcal O(\log n)$ 条重链。

## 例题 10

> [P2146 [NOI2015] 软件包管理器](https://www.luogu.com.cn/problem/P2146)

### Solution

* 软件包的依赖关系构成了一个树形结构，安装一个软件包的时候要安装其所有祖先的软件包，卸载一个软件包时需要卸载其所有子树的软件包。树链剖分后线段树维护即可。

## LCT（Link Cut Tree）

### Access(x)

1. 将当前点在 $\text{Splay}$ 中旋转到根上。
2. 改变当前点的右儿子。并更新当前点的信息。
3. 将当前点改为当前链最浅的节点的父亲。

```cpp
    void Access(int x) {
        for (int y = 0; x; y = x, x = f[x]) {
            Splay(x);
            ch[x][1] = y;
            PushUp(x);
        }
    }
```

### MakeRoot(x)

* $Access(x) + Reverse$ 即可。

### FindRoot(x)

* $Access(x)$ 后跳一跳左子树即可。

### Split(x, y)

* $MakeRoot(x) + Access(y)$

### Link(x, y)

* 将 $x, y$ 之间连一条轻边。
* 先 $MakeRoot(x)$ 后令 $f[x] = y$ 即可。
* 如果连边不一定合法的话只需要判断 $FindRoot(x)$ 是否等于 $FindRoot(y)$ 即可。

### Cut(x, y)

* $Split(x, y)$
* $Splay(x)$
* $rs[x] = fa[y] = 0$
* $PushUp(x)$
* 如果割边不一定合法的话，需要：
  1. 判一下 $x, y$ 是否联通。
  2. $Split$ 后判一下该链的大小是否为 $2$ 即可。

### LCT 维护子树信息

* 对于每一个节点维护其轻儿子的子树的信息。
* $Access / Link / Cut$ 时，由于我们需要用 $\text{Splay}$ 中的某个子树的信息和来修改某个点的轻子树的信息和，所以我们还需要对每个点维护其再 $\text{Splay}$ 中的子树的信息和。