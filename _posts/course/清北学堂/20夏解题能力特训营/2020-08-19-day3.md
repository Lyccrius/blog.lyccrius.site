---
layout: post
title:  数据结构题目选讲
date:   2020-08-19
author: 李佳实
categories: course qbxt 6
---

*   数据结构是优化时间或空间的工具
*   正式比赛中考察对数据结构本身的理解的题相对不多
*   更多的题考察的是模型转化
*   所以我们要熟练掌握代码，明白每个数据结构能做什么。

# NOIP 数据结构

*   栈（单调栈）、队列（单调队列）
*   堆（优先队列、手动实现）
*   链表（双向链表、循环链表）
*   ST表
*   并查集（路径压缩、按秩合并）
*   树状数组、二维树状数组
*   字典树
*   线段树、平衡树

# 题目选讲

## P1955 [NOI2015] 程序自动分析

*   用并查集维护相等关系。
*   判断不等关系是否冲突。

```cpp
    for (int k = 1; k <= n; k++) if (e[k] == 1) DSU.Union(i[k], j[k]);
    for (int k = 1; k <= n; k++) if (e[k] == 0) if (DSU.Find(i[k]) == DSU.Find(j[k])) ok = false;
```

*   记得离散化。
*   空间开二倍。

##  P3512 [POI2010]PIL-Pilots

*   单调队列维护最大/小值。
*   队列头部超出限制就弹出。

```cpp
    std::deque<lxl> mx;
    std::deque<lxl> mn;
    lxl ans = 0;
    lxl cur = 1;
    for (lxl i = 1; i <= n; i++) {
        while (!mx.empty() && a[mx.back()] < a[i]) mx.pop_back();
        while (!mn.empty() && a[mn.back()] > a[i]) mn.pop_back();
        mx.push_back(i);
        mn.push_back(i);
        while (!mx.empty() && !mn.empty() && a[mx.front()] - a[mn.front()] > k) {
            cur++;
            while (!mx.empty() && mx.front() < cur) mx.pop_front();
            while (!mn.empty() && mn.front() < cur) mn.pop_front();
        }
        ans = std::max(ans, i - cur + 1);
    }
```

## P3487 [POI2009]ARC-Architects

*   字典序满足贪心。
*   $a_{b_{i + 1}}$ 就是 $a_{b_i + 1}$ 到 $a_{n - k + i}$ 的最大值。
*   用单调队列维护。

```cpp
    k = inicjuj();
    while (a[n + 1] = wczytaj()) n++;
    std::deque<int> q;
    for (int i = 1; i <= n; i++) {
        while (!q.empty() && q.back() < a[i]) q.pop_back();
        if (q.size() < k) q.push_back(a[i]);
        if (i >= n - k + 1) wypisz(q.front()), q.pop_front();
    }
```

## P3545 [POI2012]HUR-Warehouse Store

*   贪心$+$堆。
*   最后一天的货肯定只能用于满足最后一天的订单。
*   倒数第二天的货有两个选择，为了保证能完成的订单数最多，就在两天之中挑一个快要达成的来满足（相当于在倒数第二天的订单和倒数第一天的订单减去倒数第一天的货之间取最小值）。
*   以此类推。

```cpp
    for (lxl i = n; i >= 1; i--) {
        q.push((Node) {i, b[i]});
        while (!q.empty() && a[i]) {
            Node t = q.top();
            q.pop();
            if (a[i] >= t.a) {
                a[i] -= t.a;
                ans.push(t);
            } else {
                t.a -= a[i];
                q.push(t);
                a[i] = 0;
            }
        }
    }
```

## P2391 白雪皑皑

*   考虑倒序处理。
*   因为每次染的颜色不一样，所以总共只会染 $n$ 次颜色。
*   只需快速知道每次需要染哪些馒头。
*   用并查集维护，开始每个馒头单独一个集合，每当一个馒头 $i$ 被染上色，就把 $x$ 连向 $x - 1$，这样就可以快速找到哪些馒头没被染过色。
*   总共只有 $n$ 个馒头，总复杂度为 $\mathcal O(n)$。

```cpp
    for (lxl i = m; i >= 1; i--) {
        lxl l = ((i * p + q) % n) + 1;
        lxl r = ((i * q + p) % n) + 1;
        if (l > r) std::swap(l, r);
        while (l <= r) {
            if (DSU.Find(r) == r) c[r] = i;
            DSU.Union(r, r - 1);
            r = DSU.Find(r);
        }
    }
```

## P2922 [USACO08DEC]Secret Message G

*   对信息建字典树，终止节点权值 $+1$。
*   密码的答案 $=$ 路径上点权和 $+$ 终止节点子树（不包括终止节点）权值总和。
*   可以建出 $\text{Trie}$ 树之后 $\text{PushUp}$ 一下，得到每个点子树的权值总和，就可以 $\mathcal O(密码长度)$ 回答每个询问。

```cpp
struct TrieTree {
    struct Node {
        int son[2];
        int val;
        int sum;
    } node[maxA * 2 + 10];

    int ncnt;
    int root;

    void Init() {
        root = ++ncnt;
        return;
    }

    void Insert(int n) {
        int u = root;
        for (int i = 1; i <= n; i++) {
            if (node[u].son[a[i]] == 0) node[u].son[a[i]] = ++ncnt;
            u = node[u].son[a[i]];
        }
        node[u].val++;
        return;
    }

    void PushUp(int u) {
        if (node[u].son[0]) PushUp(node[u].son[0]);
        if (node[u].son[1]) PushUp(node[u].son[1]);
        node[u].sum += node[node[u].son[0]].val;
        node[u].sum += node[node[u].son[0]].sum;
        node[u].sum += node[node[u].son[1]].val;
        node[u].sum += node[node[u].son[1]].sum;
        return;
    }

    int Query(int n) {
        int u = root;
        int ret = 0;
        for (int i = 1; i <= n; i++) {
            if (node[u].son[a[i]] == 0) return ret;
            u = node[u].son[a[i]];
            ret += node[u].val;
        }
        ret += node[u].sum;
        return ret;
    }
} TT;
```

## P4054 [JSOI2009] 计数问题

*   二维树状数组。
*   各数分别维护。

```cpp
struct BinaryIndexedTree {
    struct BinaryIndexedTree2 {
        int node[maxM + 10][maxC + 10];

        void Add(int y, int c, int val) {
            while (y <= m) {
                node[y][c] += val;
                y += lowbit(y);
            }
            return;
        }

        int Ask(int y, int c) {
            int ret = 0;
            while (y >= 1) {
                ret += node[y][c];
                y -= lowbit(y);
            }
            return ret;
        }
    } BIT[maxN + 10];

    void Add(int x, int y, int c, int val) {
        while (x <= n) {
            BIT[x].Add(y, c, val);
            x += lowbit(x);
        }
        return;
    }

    int Ask(int x, int y, int c) {
        int ret = 0;
        while (x >= 1) {
            ret += BIT[x].Ask(y, c);
            x -= lowbit(x);
        }
        return ret;
    }
} BIT;
```