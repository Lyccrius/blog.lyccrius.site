---
layout: post
title:  数据结构题目选讲
date:   2020-08-19
author: 李佳实
categories: course qbxt 6
---

*   数据结构是优化时间或空间的工具
*   正式比赛中考察对数据结构本身的理解的题相对不多
*   更多的题考察的是模型转化
*   所以我们要熟练掌握代码，明白每个数据结构能做什么。

# NOIP 数据结构

*   栈（单调栈）、队列（单调队列）
*   堆（优先队列、手动实现）
*   链表（双向链表、循环链表）
*   ST表
*   并查集（路径压缩、按秩合并）
*   树状数组、二维树状数组
*   字典树
*   线段树、平衡树

# 题目选讲

## P1955 [NOI2015] 程序自动分析

*   用并查集维护相等关系。
*   判断不等关系是否冲突。

```cpp
    for (int k = 1; k <= n; k++) if (e[k] == 1) DSU.Union(i[k], j[k]);
    for (int k = 1; k <= n; k++) if (e[k] == 0) if (DSU.Find(i[k]) == DSU.Find(j[k])) ok = false;
```

*   记得离散化。
*   空间开二倍。

##  P3512 [POI2010]PIL-Pilots

*   单调队列维护最大/小值。
*   队列头部超出限制就弹出。

```cpp
    std::deque<lxl> mx;
    std::deque<lxl> mn;
    lxl ans = 0;
    lxl cur = 1;
    for (lxl i = 1; i <= n; i++) {
        while (!mx.empty() && a[mx.back()] < a[i]) mx.pop_back();
        while (!mn.empty() && a[mn.back()] > a[i]) mn.pop_back();
        mx.push_back(i);
        mn.push_back(i);
        while (!mx.empty() && !mn.empty() && a[mx.front()] - a[mn.front()] > k) {
            cur++;
            while (!mx.empty() && mx.front() < cur) mx.pop_front();
            while (!mn.empty() && mn.front() < cur) mn.pop_front();
        }
        ans = std::max(ans, i - cur + 1);
    }
```

## P3487 [POI2009]ARC-Architects

*   字典序满足贪心。
*   $a_{b_{i + 1}}$ 就是 $a_{b_i + 1}$ 到 $a_{n - k + i}$ 的最大值。
*   用单调队列维护。

```cpp
    k = inicjuj();
    while (a[n + 1] = wczytaj()) n++;
    std::deque<int> q;
    for (int i = 1; i <= n; i++) {
        while (!q.empty() && q.back() < a[i]) q.pop_back();
        if (q.size() < k) q.push_back(a[i]);
        if (i >= n - k + 1) wypisz(q.front()), q.pop_front();
    }
```

## P3545 [POI2012]HUR-Warehouse Store

*   贪心 $+$ 堆。
*   最后一天的货肯定只能用于满足最后一天的订单。
*   倒数第二天的货有两个选择，为了保证能完成的订单数最多，就在两天之中挑一个快要达成的来满足（相当于在倒数第二天的订单和倒数第一天的订单减去倒数第一天的货之间取最小值）。
*   以此类推。

```cpp
    for (lxl i = n; i >= 1; i--) {
        q.push((Node) {i, b[i]});
        while (!q.empty() && a[i]) {
            Node t = q.top();
            q.pop();
            if (a[i] >= t.a) {
                a[i] -= t.a;
                ans.push(t);
            } else {
                t.a -= a[i];
                q.push(t);
                a[i] = 0;
            }
        }
    }
```

## P2391 白雪皑皑

*   考虑倒序处理。
*   因为每次染的颜色不一样，所以总共只会染 $n$ 次颜色。
*   只需快速知道每次需要染哪些馒头。
*   用并查集维护，开始每个馒头单独一个集合，每当一个馒头 $i$ 被染上色，就把 $x$ 连向 $x - 1$，这样就可以快速找到哪些馒头没被染过色。
*   总共只有 $n$ 个馒头，总复杂度为 $\mathcal O(n)$。

```cpp
    for (lxl i = m; i >= 1; i--) {
        lxl l = ((i * p + q) % n) + 1;
        lxl r = ((i * q + p) % n) + 1;
        if (l > r) std::swap(l, r);
        while (l <= r) {
            if (DSU.Find(r) == r) c[r] = i;
            DSU.Union(r, r - 1);
            r = DSU.Find(r);
        }
    }
```

## P2922 [USACO08DEC]Secret Message G

*   对信息建字典树，终止节点权值 $+1$。
*   密码的答案 $=$ 路径上点权和 $+$ 终止节点子树（不包括终止节点）权值总和。
*   可以建出 Trie 树之后 PushUp 一下，得到每个点子树的权值总和，就可以 $\mathcal O(密码长度)$ 回答每个询问。

```cpp
struct TrieTree {
    struct Node {
        int son[2];
        int val;
        int sum;
    } node[maxA * 2 + 10];

    int ncnt;
    int root;

    void Init() {
        root = ++ncnt;
        return;
    }

    void Insert(int n) {
        int u = root;
        for (int i = 1; i <= n; i++) {
            if (node[u].son[a[i]] == 0) node[u].son[a[i]] = ++ncnt;
            u = node[u].son[a[i]];
        }
        node[u].val++;
        return;
    }

    void PushUp(int u) {
        if (node[u].son[0]) PushUp(node[u].son[0]);
        if (node[u].son[1]) PushUp(node[u].son[1]);
        node[u].sum += node[node[u].son[0]].val;
        node[u].sum += node[node[u].son[0]].sum;
        node[u].sum += node[node[u].son[1]].val;
        node[u].sum += node[node[u].son[1]].sum;
        return;
    }

    int Query(int n) {
        int u = root;
        int ret = 0;
        for (int i = 1; i <= n; i++) {
            if (node[u].son[a[i]] == 0) return ret;
            u = node[u].son[a[i]];
            ret += node[u].val;
        }
        ret += node[u].sum;
        return ret;
    }
} TT;
```

## P4054 [JSOI2009] 计数问题

*   二维树状数组。
*   各数分别维护。

```cpp
struct BinaryIndexedTree {
    struct BinaryIndexedTree2 {
        int node[maxM + 10][maxC + 10];

        void Add(int y, int c, int val) {
            while (y <= m) {
                node[y][c] += val;
                y += lowbit(y);
            }
            return;
        }

        int Ask(int y, int c) {
            int ret = 0;
            while (y >= 1) {
                ret += node[y][c];
                y -= lowbit(y);
            }
            return ret;
        }
    } BIT[maxN + 10];

    void Add(int x, int y, int c, int val) {
        while (x <= n) {
            BIT[x].Add(y, c, val);
            x += lowbit(x);
        }
        return;
    }

    int Ask(int x, int y, int c) {
        int ret = 0;
        while (x >= 1) {
            ret += BIT[x].Ask(y, c);
            x -= lowbit(x);
        }
        return ret;
    }
} BIT;
```

## P1792 [国家集训队]种树

*   考虑最大值在什么情况下不会选。
*   如果最大值不选，那么最大值两侧的数都选。
*   假设最大值选，然后把最大值和两侧三个数合并成一个，值为 $A[p - 1] + A[p + 1] - A[p]$，表示删去最大值，并选择两侧的数。相当于给了一次反悔的机会。
*   用链表维护当前的圈。
*   用堆维护当前最大值。

```cpp
struct LinkedList {
    struct Node {
        lxl a;
        int p;
        int last;
        int next;
    } node[maxN + 10];

    void Delete(int p) {
        v[node[p].last] = true;
        v[node[p].next] = true;
        node[p].last = node[node[p].last].last;
        node[p].next = node[node[p].next].next;
        node[node[p].last].next = p;
        node[node[p].next].last = p;
        return;
    }
} LL;

struct Node {
    lxl a;
    int p;
};

struct cmp {
    inline bool operator() (const Node &x, const Node &y) {
        return x.a < y.a;
    }
};

std::priority_queue<Node, std::vector<Node>, cmp> q;
```

```cpp
    for (int i = 1; i <= n; i++) q.push((Node) {A[i], i});
    for (int i = 1; i <= n; i++) LL.node[i].last = i - 1;
    for (int i = 1; i <= n; i++) LL.node[i].next = i + 1;
    LL.node[1].last = n;
    LL.node[n].next = 1;
    if (m > n / 2) {
        std::cout << "Error!";
        return 0;
    }
    while (m) {
        int p = q.top().p;
        q.pop();
        if (v[p]) continue;
        ans += A[p];
        A[p] = A[LL.node[p].last] + A[LL.node[p].next] - A[p];
        q.push((Node) {A[p], p});
        LL.Delete(p);
        m--;
    }
```

## BZOJ3910 火车

*   以起点为根建树。
*   一个点未走过的充要条件是它的子树内没有点被访问过。
*   用并查集维护点是否被访问过，访问过则与父结点合并。
*   利用 LCA 快速求两点间距离。

```cpp
void PushUp(int u, int v) {
    if (vertex[u].dep < vertex[v].dep) return;
    vertex[u].tag = true;
    DSU.Union(u, ST.f[u][0]);
    PushUp(DSU.Find(u), v);
    return;
}
```

```cpp
    for (int i = 1; i <= n; i++) graph::vertex[i].tag = true;
    for (int i = 1; i <= m; i++) std::cin >> t[i], graph::vertex[t[i]].tag = false;
        graph::DFS(1, 0);
    graph::ST.Init();
    graph::DSU.init();
    for (int i = 1; i <= m; i++) {
        if (graph::vertex[t[i]].tag) continue;
        int lca = graph::LCA(a, t[i]);
        ans += graph::vertex[a].dep + graph::vertex[t[i]].dep - 2 * graph::vertex[lca].dep;
        graph::PushUp(a, lca);
        graph::PushUp(t[i], lca);
        a = t[i];
    }
```

## P3822 [NOI2017] 整数

*   $a$ 有正负，相当于有加减。
*   可以把加数加在一起为 $x$，减数加到一起为 $y$。
*   每次询问相当于 $x$ 和 $y$ 的后 $k$ 位哪个大。
*   处理只有加的情况。
*   把 $a$ 拆成 $30$ 位，每次操作一位相当于单点修改。
*   对于询问，相当于问 $x$ 和 $y$ 的后 $k$ 位的不相同的第一位。
*   维护 $z = x \oplus y$，相当于问 $z$ 的后 $k$ 位的第一个 $1$ 在哪一位。
*   可用树状数组每次操作 $\mathcal O(\log n)$ 处理。

## P3586 [POI2015] LOG

*   每个数对答案的贡献 $= \min (a[i], s)$。
*   树状数组维护小于等于每个数的权值及其个数。
*   对于一个 $s$，将小于等于 $s$ 的所有数加起来，再把大于 $s$ 的当成 $s$，统计贡献。

```cpp
    for (int i = 1; i <= m; i++) {
        if (ch[i] == 'U') {
            a[i] = std::lower_bound(range.begin(), range.end(), a[i]) - range.begin();
            if (array[k[i]]) {
                cnt.Add(array[k[i]], -1);
                sum.Add(array[k[i]], -range[array[k[i]]]);
            }
            array[k[i]] = a[i];
            cnt.Add(array[k[i]], 1);
            sum.Add(array[k[i]], range[array[k[i]]]);
        } else {
            s[i] = std::lower_bound(range.begin(), range.end(), s[i]) - range.begin();
            if (sum.Ask(s[i] - 1) >= 1ll * (c[i] - (cnt.Ask(m) - cnt.Ask(s[i] - 1))) * range[s[i]]) {
                std::cout << "TAK\n";
            } else {
                std::cout << "NIE\n";
            }
        }
    }
```

## P3419 [POI2005]SAM-Toy Cars

*   贪心 $+$ 堆。
*   地板上玩具不足 $k$ 时直接放。
*   考虑地板上玩具等于 $k$ 时换哪个。
*   记录每种玩具下一次被玩的时间 $next[i]$，替换当前地板上 $next$ 值最大的玩具。
*   用堆维护地板上的玩具。

```cpp
    for (int i = 1; i <= p; i++) {
        next[last[a[i]]] = i;
        last[a[i]] = i;
        next[i] = p + 1;
    }
    for (int i = 1; i <= p; i++) {
        if (inq[a[i]]) {
            q.push(i);
            k++;
        } else {
            if (q.size() == k) {
                inq[a[q.top()]] = false;
                q.pop();
            }
            inq[a[i]] = true;
            q.push(i);
            ans++;
        }
    }
```

## P3474 [POI2008]KUP-Plot purchase

*   假设有一个格子就在这个范围内，直接输出。
*   否则格子分两种，一种小于 $K$，一种大于 $2K$，其中第二种格子不能选。
*   一个显然的结论是，若能找出一种不包含第二个格子的子矩形使得其权值和大于等于 $K$，这个子矩阵一定有一部分的权值和小于等于 $2K$，因为里面每个元素都不超过 $K$。
*   所以我们可以用一个单调栈处理出所有的极大子矩形，若其权值大于 $2K$，就开始砍行和列，直到小于等于 $2K$ 为止。