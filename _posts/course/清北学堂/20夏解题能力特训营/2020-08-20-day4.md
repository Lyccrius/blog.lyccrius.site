---
layout: post
title:  图论
date:   2020-08-20
author: 顾庭枫
categories: course qbxt 6
---

*   一看有没有图
    *   套隐式图模板（尤其是二分图）
    *   分析题目中名词关系，尝试构图（尤其是二分图）
    *   不是图论题
*   二看是什么图
    *   树
        *   LCA
        *   树剖
        *   DP
        *   遍历
    *   DAG
        *   拓扑序DP
        *   贪心
    *   一般图
        *   转化为树 $/$ DAG
        *   最短路
        *   遍历
    *   二分图
        *   匈牙利
*   三看多大的图
    *   $\mathcal O(n)$
        *   Tarjan
        *   遍历
        *   DP
        *   贪心
    *   $\mathcal O(n \log n)$
        *   Dijkstra
        *   Kruskal
        *   倍增
    *   $\mathcal O(n^3)$
        *   Floyd
*   牢记 2 个工具
    *   二分答案
    *   倍增

>   不求最优。  
>   只求能做。

# NOIP

## P1073 [NOIP2009 提高组] 最优贸易

*   简化题意：
    *   求一条 $1 \rightarrow n$ 的（不要求简单）路径，在路径上某个点买 $1$ 次商品，在之后到达的点卖掉，求最大利润。
*   点可重复，一个强连通分量内必可互达。
    *   Tarjan 缩点，变成 DAG
    *   DP
*   另一种做法是分层图，优美（大概），但考试时难以快速反应。

>   考场上先想到的就是最好的。

## P1525 [NOIP2010 提高组] 关押罪犯

*   贪心。
*   将怨气值从大到小排序。
*   尽可能的将怨气值大的两个罪犯分开放。
*   什么样的罪犯必须放在一起？
    *   ——有共同的敌人。
    *   即，对于某一个罪犯，所有不能跟他放在一起的罪犯一定在同一个并查集中。
*   建立 $n$ 个虚点，第 $i$ 个虚点表示与其连通的点与 $i$ 不在一个监狱里。
*   从大到小对于每一个怨气值关系，判断该怨气关系双方 $(u, v)$ 是否在一个并查集中，如果不在，将 $u$ 与 $v$ 对应的虚点相连，$v$ 与 $u$ 对应的虚点相连。

## P1084 [NOIP2012 提高组] 疫情控制

*   简化题意：
    *   一棵带权有根树，有 $m$ 个军队。对于每个军队，移动到其距离不超过 $K$ 且不为根节点的一个点，使得最终根节点与原来的所有叶子的路径上都至少有一个军队。求最小的 $K$。
*   最大值最小。
*   二分答案。
*   每个军队先尽可能向根节点前进，以堵塞更多路径。
*   走不到根节点就地驻扎，走得到根节点分类讨论，支援尚未被堵死的子树。
*   难点在于分类讨论。

## P1967 [NOIP2013 提高组] 货车运输

*   无需简化题意。
*   路径上的最小值最大。
*   先猜二分答案。
*   多组询问，每次二分答案都要 $\mathcal O(m \log z)$，超时。
*   但是很好写，想不下去，不妨先写一个，至少 30 分。
*   事实上，不二分答案直接仿单源最短路求更快（没写过，不保证正确性，也很好写，如果正确应该有 60 分）。
*   再猜，想到一个东西叫做最大瓶颈生成树，树上最小边是所有生成树最小边的最大值，直接求最大生成树就是一个最大瓶颈生成树。
*   盲猜答案路径一定在最大生成树上，这就转化为了一个 LCA 问题。
*   正确性考场上难以且不必快速证明。
*   对拍解决所有问题。

>   大胆猜结论，对拍就是证明（考场限定）。

## P2296 [NOIP2014 提高组] 寻找道路

*   无需简化题意。
*   假设所有点都满足条件 1，这就是个简单的最短路。
*   题目转化为求所有满足条件 1 的点。
*   简单的思路——建立反图。
*   在反图上，很容易遍历得到终点走不到的所有点。
*   原图有指向这些点的边的所有点都不满足条件 1。
*   也就是反图中这些点出边所指向的点都不满足条件 1。
*   排除之后再原图最短路即可。

## P5022 [NOIP2018 提高组] 旅行

*   简化题意：
    *   给出一棵树或一颗基环树，求一个字典序最小的 DFS 序。
*   给了一个 $\mathcal O(n^2)$ 的时间复杂度。
*   首先考虑一颗树的情况，由于要求的是字典序，直接 $\mathcal O(n)$ 贪心 $DFS$ 即可。
*   对于一颗基环树，有一个非常常见的思路，那就是暴力断边。
*   首先找到环，枚举断掉哪条边，转化成 $\mathcal O(n)$ 的树上贪心 DFS。

## P2680 [NOIP2015 提高组] 运输计划

*   简化题意：
    *   给出一棵带权树，$m$ 条路径，修改某条边边权为 $0$，使得 $m$ 条路径最大长度最短。
*   二分答案。
*   二分修改过后，最长链的长度。
*   对于所有的长度大于 $mid$ 的链（假设有 $K$ 条），对其每一条边打上标记。
*   扫描所有打上了 $K$ 次标记的边，看看这其中是否有一条边，最长的那条链减去这条边的边权之后长度小于等于 $mid$。
*   如何打标记。
    *   树链剖分（无脑，超纲）。
    *   差分（要想一想，码量比树链剖分少）。
*   求出链两端的 LCA，在链的两端点计数器 $+ 1$，LCA 计数器 $- 2$。所有标记打完之后统计子树的计数器和，计数器和为 $K$ 的点指向父亲的边就是被打了 $K$ 次标记的边。

>   适当学习超纲知识有助于减少思维难度提速。  
>   但考前不建议学习新知识，请巩固已有知识。

# Other

## P1600 [NOIP2016 提高组] 天天爱跑步

*   简化题意：
    *   给出一棵无边权树，$m$ 条单向路径，对每个点，给定 $w_i$，询问有多少条路径经过该点，且起点到该点的距离为 $w_i$。
*   所有人的起点等于自己的终点，即 $s_i = t_i$
    *   送的 10 分。
    *   对于每个 $w_j$ 为 $0$ 的点，统计有多少条路径起点 $/$ 终点是它。
    *   其余的点答案为 $0$。
*   $w_j = 0$
    *   又送 10 分。
    *   对于每个点，统计有多少条路径起点是它。
*   无
    *   提示你可以 $\mathcal O(n m)$ 地解决。
    *   其实就是对于每一条路径，模拟跑步过程，对沿途满足距离等于 $w_j$ 的点计数器增加。
    *   这样你就拿到了 25 分暴力，预计 20 分用时不超过 10 分钟，25 分用时不超过 20 分钟。
    *   虽然 25 分暴力性价比不高，但 5 分也是分，另一方面，25 分暴力可以用于正解的对拍。
*   树退化成一条链
    *   接下来的 3 个部分分正式开始提示正解。
    *   不妨认为根节点是 $1$，题目给出的路径分为 2 类：
        *   $S \lt T$（下行）
        *   $S \gt T$（上行）
        *   每条下行路径会对所覆盖的，$S + w_j = j$ 的点 $j$ 的答案有 $+ 1$ 的贡献；
        *   每条上行路径会对所覆盖的，$S - w_j = j$ 的点 $j$ 的答案有 $+ 1$ 的贡献。
    *   也就是说，节点 $j$ 的答案就是覆盖了 $j$ 的，$S = j - w_j$ 的下行路径数目，加上 $S = j + w_j$ 的上行路径数目。
    *   统计方法不难想到：
        1.  对路径分类排序
        2.  *   开一个大小为 $n$ 的数组 $a$，$a[i]$ 记录从 $i$ 出发且仍然覆盖了当前点的下行路径数；
            *   $j$ 从 $1$ 扫到 $n$，先将 $j$ 出发的下行路径计入 $a[j]$，再将 $a[j - w_j]$ 计入答案，再从 $a$ 中删去以 $j$ 为终点的路径
        3.  *   对上行路径做类似处理，开一个大小为 $n$ 的数组 $b$，$b[i]$ 记录从 $i$ 出发且仍然覆盖了当前点的上行路径数；
            *   $j$ 从 $n$ 扫到 $1$，先将 $j$ 出发的上行路径计入 $b[j]$，再将 $b[j + w_j]$ 计入答案，再从 $b$ 中删去以 $j$ 为终点的路径。
*   所有的 $s_i = 1$。
    *   有了刚刚处理一条链的经验，这个部分分的思路将变得格外清晰。
    *   仍然不妨以 $1$ 为根（$dep_1 = 0$），则所有的路径都是从根出发的下行路径。
    *   那么 $w_j = dep_j$ 的点答案为其子树中的终点个数，其余答案为 $0$（统计子树中的终点个数，直接一个深搜，$\mathcal O(n)$，应该没人不会）。
    *   这个部分分比前一个部分分简单很多，建议先行处理。
*   所有的 $t_i = 1$。
    *   这一部分跟上一部分看上去相似，实际上复杂很多。
    *   考虑一条从 $S$ 到 $1$ 的路径，能被经过的点 $j$ 记录到当且仅当 $dep_S - dep_j = w_j$，也就是 $dep_S = w_j + dep_j$。
    *   和我们在一条链时讨论的情况类似，每一个点 $j$ 能记录的路径，其起点的 $dep$ 一定等于一个仅与 $j$ 相关的值。
    *   于是继续开一个大小为 $max_dep$ 的数组 $a$，$a[i]$ 记录当前统计到的路径中起点深度为 $i$ 的条数，然后就发现出现问题了。
    *   处理到 $j$ 时，这个数组内统计的路径，本来应当全从 $j$ 的子树中出发（才能保证路径经过 $j$），但现在，从 $j$ 的“兄节点”的子树中出发的路径也会被统计进来（甚至包括 $j$祖先的兄节点，因为这些统计信息根本不会被删除）。
    *   如果你能想到增量法，那么就离解决本题不远了。
    *   考虑这样一个问题，点 $j$ 会在将子树中所有 $dep = dep_j + w_j$ 的路径计入答案。
    *   而实际上，在刚访问 $j$节点，没有进行任何操作时，$dep_j + w_j$ 就已经是一个确定值了——此时 $a[dep_j] + w_j$ 记录的信息，不包含从 $j$ 的子树中出发的任何路径，将其记录为 $temp$。
    *   接下来递归 DFS，再将从 $j$ 出发的路径计入 $a$，此时 $a[dep_j] + w_j - temp$，正好统计的是 $j$ 子树中的信息，也就是需要被记入答案的部分！
    *   于是这一个部分分也被解决了，而正解需要用到的思路，也已经被推导出来了。
*   无
    *   树上路径，想 LCA。
    *   事实上，一条 $s \rightarrow t$ 的路径，设 $s, t$ 的 LCA 为 $r$，它可以拆成 $s \rightarrow r$ 的上行路径和 $r \rightarrow t$ 的下行路径。
    *   对于 $s \rightarrow r$ 的路径中的点 $j$ ，$s \rightarrow t$ 对其有贡献要求 $dep_s - dep_j = w[j]$。即对于每个 $j$，只有 $dep_s = dep_j + w_j$ 的路径才会在上行时对 $j$ 有贡献。
    *   同理，对于 $r \rightarrow t$ 的路径中的点 $j$，$s \rightarrow t$ 对其有贡献要求 $dis(s, t) - dep_t + dep_j = w_j$。即对于每个 $j$，只有 $dep_t - dis(s, t) = dep_j - w_j$ 的点出发的路径才会在下行时对 $j$ 有贡献。
    *   那么在 DFS 的时候建立两个数组 $cnt_1, cnt_2$，$cnt_1[i]$ 记录当前已统计的路径 $dep_s = i$ 的数目，$cnt_2[i]$ 记录 $dep_t - dis(s, t) = i$ 的数目。
    *   在 DFS 访问 $j$ 时：
        1.  先记录下 $temp_1= cnt_1[dep_j] + w_j, temp_2 = cnt_2[dep_j] - w_j$；
        2.  递归 DFS；
        3.  将从 $j$ 出发的上行路径加入 $cnt_1$，到 $j$ 结束的下行路径加入 $cnt_2$；
        4.  用增量法统计 $j$ 的答案；
        5.  将以 $j$ 为 LCA 的上行路径和以 $j$ 的父节点为 LCA 的下行路径弹出从 $cnt_1$ 与 $cnt_2$。
    *   几个细节：
        1. $dep_j - w_j, dep_t - dis(s, t)$ 可能为负数，可以采用将 $cnt_2$ 整体平移的方法规避负下标；
        2. 注意特判不需要拆的路径。

## P5021 [NOIP2018 提高组] 赛道修建

*   简化题意：
    *   给出一棵带权树，求 $m$ 条边不共用的链，使得最短链长最大。
*   最短链长最大，二分答案。
*   找 $m$ 条长度不小于 $mid$ 的链。
*   贪心。
*   考虑把树转换为有根树，一条链要么是一条整的祖先链，要么是一条由端点 LCA 分成两半的链。
*   考虑这样一个 DFS 过程，首先对所有儿子递归 DFS，得到每条儿子边 $+$ 子树未被匹配的最长链形成的链。链长大于等于 $mid$ 则直接计入已找到。否则加入一个数据结构中。
*   所有儿子 DFS 完毕后，从这些链的最小值起田忌赛马式配对（找使得配对后长度不小于 $mid$ 的另一最短链），配对成功则计入已找到，从数据结构中双双删除。
*   如果全部配对完成，返回 $0$，否则返回未配对的最长链。
*   正确性？对拍，请。

## P2121 拆地毯

## P1262 间谍网络

## P1155 [NOIP2008 提高组] 双栈排序

## P1875 佳佳的魔法药水

## P4180 [BJWC2010] 严格次小生成树

## P2597 [ZJOI2012]灾难

## P3825 [NOI2017] 游戏

## P5540 [BalkanOI2011] timeismoney | 最小乘积生成树

## P1351 [NOIP2014 提高组] 联合权值

## P2661 [NOIP2015 提高组] 信息传递

## P3958 [NOIP2017 提高组] 奶酪

## P3953 [NOIP2017 提高组] 逛公园