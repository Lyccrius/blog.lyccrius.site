---
layout: post
title:  图论
date:   2020-08-20
author: 顾庭枫
categories: course qbxt 6
---

*   一看有没有图
    *   套隐式图模板（尤其是二分图）
    *   分析题目中名词关系，尝试构图（尤其是二分图）
    *   不是图论题
*   二看是什么图
    *   树
        *   LCA
        *   树剖
        *   DP
        *   遍历
    *   DAG
        *   拓扑序DP
        *   贪心
    *   一般图
        *   转化为树 $/$ DAG
        *   最短路
        *   遍历
    *   二分图
        *   匈牙利
*   三看多大的图
    *   $\mathcal O(n)$
        *   Tarjan
        *   遍历
        *   DP
        *   贪心
    *   $\mathcal O(n \log n)$
        *   Dijkstra
        *   Kruskal
        *   倍增
    *   $\mathcal O(n^3)$
        *   Floyd
*   牢记 2 个工具
    *   二分答案
    *   倍增

>   不求最优。  
>   只求能做。

# NOIP

## P1073 [NOIP2009 提高组] 最优贸易

*   简化题意：
    *   求一条 $1 \rightarrow n$ 的（不要求简单）路径，在路径上某个点买 $1$ 次商品，在之后到达的点卖掉，求最大利润。
*   点可重复，一个强连通分量内必可互达。
    *   Tarjan 缩点，变成 DAG
    *   DP
*   另一种做法是分层图，优美（大概），但考试时难以快速反应。

>   考场上先想到的就是最好的。

## P1525 [NOIP2010 提高组] 关押罪犯

*   贪心。
*   将怨气值从大到小排序。
*   尽可能的将怨气值大的两个罪犯分开放。
*   什么样的罪犯必须放在一起？
    *   ——有共同的敌人。
    *   即，对于某一个罪犯，所有不能跟他放在一起的罪犯一定在同一个并查集中。
*   建立 $n$ 个虚点，第 $i$ 个虚点表示与其连通的点与 $i$ 不在一个监狱里。
*   从大到小对于每一个怨气值关系，判断该怨气关系双方 $(u, v)$ 是否在一个并查集中，如果不在，将 $u$ 与 $v$ 对应的虚点相连，$v$ 与 $u$ 对应的虚点相连。

## P1084 [NOIP2012 提高组] 疫情控制

*   简化题意：
    *   一棵带权有根树，有 $m$ 个军队。对于每个军队，移动到其距离不超过 $K$ 且不为根节点的一个点，使得最终根节点与原来的所有叶子的路径上都至少有一个军队。求最小的 $K$。
*   最大值最小。
*   二分答案。
*   每个军队先尽可能向根节点前进，以堵塞更多路径。
*   走不到根节点就地驻扎，走得到根节点分类讨论，支援尚未被堵死的子树。
*   难点在于分类讨论。

## P1967 [NOIP2013 提高组] 货车运输

*   无需简化题意。
*   路径上的最小值最大。
*   先猜二分答案。
*   多组询问，每次二分答案都要 $\mathcal O(m \log z)$，超时。
*   但是很好写，想不下去，不妨先写一个，至少 30 分。
*   事实上，不二分答案直接仿单源最短路求更快（没写过，不保证正确性，也很好写，如果正确应该有 60 分）。
*   再猜，想到一个东西叫做最大瓶颈生成树，树上最小边是所有生成树最小边的最大值，直接求最大生成树就是一个最大瓶颈生成树。
*   盲猜答案路径一定在最大生成树上，这就转化为了一个 LCA 问题。
*   正确性考场上难以且不必快速证明。
*   对拍解决所有问题。

>   大胆猜结论，对拍就是证明（考场限定）。

## P2296 [NOIP2014 提高组] 寻找道路

*   无需简化题意。
*   假设所有点都满足条件 1，这就是个简单的最短路。
*   题目转化为求所有满足条件 1 的点。
*   简单的思路——建立反图。
*   在反图上，很容易遍历得到终点走不到的所有点。
*   原图有指向这些点的边的所有点都不满足条件 1。
*   也就是反图中这些点出边所指向的点都不满足条件 1。
*   排除之后再原图最短路即可。

## P5022 [NOIP2018 提高组] 旅行

*   简化题意：
    *   给出一棵树或一颗基环树，求一个字典序最小的 DFS 序。
*   给了一个 $\mathcal O(n^2)$ 的时间复杂度。
*   首先考虑一颗树的情况，由于要求的是字典序，直接 $\mathcal O(n)$ 贪心 DFS 即可。
*   对于一颗基环树，有一个非常常见的思路，那就是暴力断边。
*   首先找到环，枚举断掉哪条边，转化成 $\mathcal O(n)$ 的树上贪心 DFS。

## P2680 [NOIP2015 提高组] 运输计划

*   简化题意：
    *   给出一棵带权树，$m$ 条路径，修改某条边边权为 $0$，使得 $m$ 条路径最大长度最短。
*   二分答案。
*   二分修改过后，最长链的长度。
*   对于所有的长度大于 $mid$ 的链（假设有 $K$ 条），对其每一条边打上标记。
*   扫描所有打上了 $K$ 次标记的边，看看这其中是否有一条边，最长的那条链减去这条边的边权之后长度小于等于 $mid$。
*   如何打标记。
    *   树链剖分（无脑，超纲）。
    *   差分（要想一想，码量比树链剖分少）。
*   求出链两端的 LCA，在链的两端点计数器 $+ 1$，LCA 计数器 $- 2$。所有标记打完之后统计子树的计数器和，计数器和为 $K$ 的点指向父亲的边就是被打了 $K$ 次标记的边。

>   适当学习超纲知识有助于减少思维难度提速。  
>   但考前不建议学习新知识，请巩固已有知识。

# Other

## P1600 [NOIP2016 提高组] 天天爱跑步

*   简化题意：
    *   给出一棵无边权树，$m$ 条单向路径，对每个点，给定 $w_i$，询问有多少条路径经过该点，且起点到该点的距离为 $w_i$。
*   所有人的起点等于自己的终点，即 $s_i = t_i$
    *   送的 10 分。
    *   对于每个 $w_j$ 为 $0$ 的点，统计有多少条路径起点 $/$ 终点是它。
    *   其余的点答案为 $0$。
*   $w_j = 0$
    *   又送 10 分。
    *   对于每个点，统计有多少条路径起点是它。
*   无
    *   提示你可以 $\mathcal O(n m)$ 地解决。
    *   其实就是对于每一条路径，模拟跑步过程，对沿途满足距离等于 $w_j$ 的点计数器增加。
    *   这样你就拿到了 25 分暴力，预计 20 分用时不超过 10 分钟，25 分用时不超过 20 分钟。
    *   虽然 25 分暴力性价比不高，但 5 分也是分，另一方面，25 分暴力可以用于正解的对拍。
*   树退化成一条链
    *   接下来的 3 个部分分正式开始提示正解。
    *   不妨认为根节点是 $1$，题目给出的路径分为 2 类：
        *   $s \lt t$（下行）
        *   $s \gt t$（上行）
        *   每条下行路径会对所覆盖的，$s + w_j = j$ 的点 $j$ 的答案有 $+ 1$ 的贡献；
        *   每条上行路径会对所覆盖的，$s - w_j = j$ 的点 $j$ 的答案有 $+ 1$ 的贡献。
    *   也就是说，节点 $j$ 的答案就是覆盖了 $j$ 的，$s = j - w_j$ 的下行路径数目，加上 $s = j + w_j$ 的上行路径数目。
    *   统计方法不难想到：
        1.  对路径分类排序
        2.  *   开一个大小为 $n$ 的数组 $a$，$a[i]$ 记录从 $i$ 出发且仍然覆盖了当前点的下行路径数；
            *   $j$ 从 $1$ 扫到 $n$，先将 $j$ 出发的下行路径计入 $a[j]$，再将 $a[j - w_j]$ 计入答案，再从 $a$ 中删去以 $j$ 为终点的路径
        3.  *   对上行路径做类似处理，开一个大小为 $n$ 的数组 $b$，$b[i]$ 记录从 $i$ 出发且仍然覆盖了当前点的上行路径数；
            *   $j$ 从 $n$ 扫到 $1$，先将 $j$ 出发的上行路径计入 $b[j]$，再将 $b[j + w_j]$ 计入答案，再从 $b$ 中删去以 $j$ 为终点的路径。
*   所有的 $s_i = 1$。
    *   有了刚刚处理一条链的经验，这个部分分的思路将变得格外清晰。
    *   仍然不妨以 $1$ 为根（$dep_1 = 0$），则所有的路径都是从根出发的下行路径。
    *   那么 $w_j = dep_j$ 的点答案为其子树中的终点个数，其余答案为 $0$（统计子树中的终点个数，直接一个深搜，$\mathcal O(n)$，应该没人不会）。
    *   这个部分分比前一个部分分简单很多，建议先行处理。
*   所有的 $t_i = 1$。
    *   这一部分跟上一部分看上去相似，实际上复杂很多。
    *   考虑一条从 $s$ 到 $1$ 的路径，能被经过的点 $j$ 记录到当且仅当 $dep_S - dep_j = w_j$，也就是 $dep_s = w_j + dep_j$。
    *   和我们在一条链时讨论的情况类似，每一个点 $j$ 能记录的路径，其起点的 $dep$ 一定等于一个仅与 $j$ 相关的值。
    *   于是继续开一个大小为 $max_{dep}$ 的数组 $a$，$a[i]$ 记录当前统计到的路径中起点深度为 $i$ 的条数，然后就发现出现问题了。
    *   处理到 $j$ 时，这个数组内统计的路径，本来应当全从 $j$ 的子树中出发（才能保证路径经过 $j$），但现在，从 $j$ 的“兄节点”的子树中出发的路径也会被统计进来（甚至包括 $j$祖先的兄节点，因为这些统计信息根本不会被删除）。
    *   如果你能想到增量法，那么就离解决本题不远了。
    *   考虑这样一个问题，点 $j$ 会在将子树中所有 $dep = dep_j + w_j$ 的路径计入答案。
    *   而实际上，在刚访问 $j$节点，没有进行任何操作时，$dep_j + w_j$ 就已经是一个确定值了——此时 $a[dep_j] + w_j$ 记录的信息，不包含从 $j$ 的子树中出发的任何路径，将其记录为 $temp$。
    *   接下来递归 DFS，再将从 $j$ 出发的路径计入 $a$，此时 $a[dep_j] + w_j - temp$，正好统计的是 $j$ 子树中的信息，也就是需要被记入答案的部分！
    *   于是这一个部分分也被解决了，而正解需要用到的思路，也已经被推导出来了。
*   无
    *   树上路径，想 LCA。
    *   事实上，一条 $s \rightarrow t$ 的路径，设 $s, t$ 的 LCA 为 $r$，它可以拆成 $s \rightarrow r$ 的上行路径和 $r \rightarrow t$ 的下行路径。
    *   对于 $s \rightarrow r$ 的路径中的点 $j$ ，$s \rightarrow t$ 对其有贡献要求 $dep_s - dep_j = w[j]$。即对于每个 $j$，只有 $dep_s = dep_j + w_j$ 的路径才会在上行时对 $j$ 有贡献。
    *   同理，对于 $r \rightarrow t$ 的路径中的点 $j$，$s \rightarrow t$ 对其有贡献要求 $dis(s, t) - dep_t + dep_j = w_j$。即对于每个 $j$，只有 $dep_t - dis(s, t) = dep_j - w_j$ 的点出发的路径才会在下行时对 $j$ 有贡献。
    *   那么在 DFS 的时候建立两个数组 $cnt_1, cnt_2$，$cnt_1[i]$ 记录当前已统计的路径 $dep_s = i$ 的数目，$cnt_2[i]$ 记录 $dep_t - dis(s, t) = i$ 的数目。
    *   在 DFS 访问 $j$ 时：
        1.  先记录下 $temp_1= cnt_1[dep_j] + w_j, temp_2 = cnt_2[dep_j] - w_j$；
        2.  递归 DFS；
        3.  将从 $j$ 出发的上行路径加入 $cnt_1$，到 $j$ 结束的下行路径加入 $cnt_2$；
        4.  用增量法统计 $j$ 的答案；
        5.  将以 $j$ 为 LCA 的上行路径和以 $j$ 的父节点为 LCA 的下行路径弹出从 $cnt_1$ 与 $cnt_2$。
    *   几个细节：
        1. $dep_j - w_j, dep_t - dis(s, t)$ 可能为负数，可以采用将 $cnt_2$ 整体平移的方法规避负下标；
        2. 注意特判不需要拆的路径。

## P5021 [NOIP2018 提高组] 赛道修建

*   简化题意：
    *   给出一棵带权树，求 $m$ 条边不共用的链，使得最短链长最大。
*   最短链长最大，二分答案。
*   找 $m$ 条长度不小于 $mid$ 的链。
*   贪心。
*   考虑把树转换为有根树，一条链要么是一条整的祖先链，要么是一条由端点 LCA 分成两半的链。
*   考虑这样一个 DFS 过程，首先对所有儿子递归 DFS，得到每条儿子边 $+$ 子树未被匹配的最长链形成的链。链长大于等于 $mid$ 则直接计入已找到。否则加入一个数据结构中。
*   所有儿子 DFS 完毕后，从这些链的最小值起田忌赛马式配对（找使得配对后长度不小于 $mid$ 的另一最短链），配对成功则计入已找到，从数据结构中双双删除。
*   如果全部配对完成，返回 $0$，否则返回未配对的最长链。
*   正确性？对拍，请。

## P2121 拆地毯

*   简化题意：
    *   选出 $K$ 条不成环的边，使得边权之和最大。
*   如果你对 Kruskal 算法的正确性证明有一定了解的话，你会极易得出结论：
    *   Kruskal 算法做到第 K 条边加入最大生成树时停止，得到的森林即为答案。
*   考场上没必要证明，请直接对拍。
*   或者说我忘了怎么证明了。

## P1262 间谍网络

*   简化题意：
    *   给出一张有向图，支付一个可收买点的价值即可控制该点能到达的所有点。
    *   求能否控制全图，如果能，求出控制全图的最小代价，否则求出不能被控制的点的最小编号。
*   一个显而易见的结论，如果存在一个强连通分量，则只要强连通分量中存在可收买点，则整个环都可被控制。且控制代价为所有可收买点中的最小代价。
    *   所以 Tarjan 缩点，以强连通分量中最小代价作为缩出的点的点权，则得到一个 DAG 森林。
    *   若每个 $0$ 入度点都能被收买，则控制全图最小代价为 $0$ 入度点点权和。
    *   若有 $0$ 入度点不能被收买，则在森林上 BFS 找到不能被收买的最小点编号。

## P1155 [NOIP2008 提高组] 双栈排序

*   简化题意：
    *   给 2 个栈，4 种操作，分别是两个栈的 push 与 pop，让一个排列变得单调递增，求能否做到，以及求字典序最小的操作方案。
*   设排列为 $p_1, p_2, \cdots, p_n$。
*   首先考虑一个栈如何解决这个问题
你会发现，假如存在 $i \lt j \lt k$，满足 $p_j \gt p_i \gt p_k$，则无论如何也不可能通过一个栈使其有序。因为假如 $i \lt j \lt k$，$p_k \lt p_i \lt p_j$，则说明在 $p_k$ 出栈之前 $p_i$ 不可以出栈，但 $p_i$ 出栈前 $p_j$ 不能压入栈中，而 $p_j$ 压入栈中前 $p_k$ 不能压入栈中，自然也不能出栈。
*   所以只要预处理后缀最小值，然后枚举每一对 $i \lt j$ 且 $p_i \lt p_j$ 的 $(i, j)$，即可 $\mathcal O(n^2) \times \mathcal O(1)$ 地验证能否使用单栈排序。
*   事实上，利用后缀最小值的方法，我们可以验证 $p_i$ 和 $p_j$ 能否被压入同一个栈。
*   那么现在我们有了双栈，我们很自然地寄希望于利用第二个栈来解决冲突。
*   即我们已知哪些 $p_i, p_j$ 不能压入同一个栈中，那么不妨将每个数看成一个点，冲突的点对之间连边，然后对点染色，相邻点不能同色。
*   这就是一个经典的二分图判定问题，贪心地 DFS 染色即可。
*   同时，为了满足操作字典序最小，每次我们找到一个编号最小的未染色节点时，我们总是优先将其分配给第一个栈。之后再按照操作的优先级模拟即可得到操作序列。

## P1875 佳佳的魔法药水

*   用类似 Dijkstra 的方法解决这一问题（并不需要最短路式建图）
*   我们发现，对于当前未锁定制作方案的药水，其中的花费最少的药水不可能被其他药水更新。
*   于是每次锁定一种药水的最小花费，并用与它相关的配方更新其他药水的花费。
*   在记录方案数时，如果新合成方案比原来的优，则进行方案数的替换；如果花费相等，则进行方案数的累加。

## P4180 [BJWC2010] 严格次小生成树

*   注意题目要求严格次小，也就是不能和最小生成树边权和相等。
*   如果你对最小生成树的性质比较熟悉，容易猜到一个看起来很对的结论：
    *   一定存在一个严格次小生成树，和最小生成树只有 $1$ 条边不同。
    *   （大胆猜，只要对拍能过就是对的）
*   因此先求出最小生成树。
*   从未被选入的边中取一条边 $x$ 加入最小生成树。
*   接着寻找所形成的环中的最大边和次大边，若最大边等于 $x$，则断掉次大边，否则断掉最大边。
*   对每条非树边做一次即可。

>   记得对拍！

## P2597 [ZJOI2012]灾难

*   简化题意：
    *   给出一个有向无环非连通图，求对于每个点，删除后有多少个点不再能从原来入度为 $0$ 的点到达（即必经之路）。
*   由于不连通，我们可以想办法把图连通起来，建立一个超级生产者，向所有原来的生产者连边，图的答案不会改变。
*   接下来必然考虑拓扑序。
*   考虑一个点，其必经点一定是所有入边必经点的交集，且任意一个必经点的必经点也是该点的必经点。
*   也就是必经点会形成一条链的关系。
*   介绍一个叫做支配树的算法：
    *   对于一张 DAG，支配树初始只包含入度为 $0$的点。之后按拓扑序依次处理。
    *   对于每一个点，求出其所有入边对应点在支配树上的 LCA，然后把这个点挂在 LCA 下作儿子
*   全图处理完后得到的树即为支配树，支配树中 $u$ 是 $v$ 的祖先当且仅当 $u$ 是 $v$ 的必经点
*   那之后只要对每个点求子树大小即是答案。

## P3825 [NOI2017] 游戏

*   题意不太好简化
*   我们先考虑 $d = 0$ 的情况，即每张地图最多只适合 $2$ 种汽车。
*   介绍一个经典图论模型 2-SAT
基本模型如下：$n$ 个布尔变量 $x_1, \cdots, x_n$，有 $m$ 个限制条件，形如：若 $x_i = 0 / 1$ 则必有 $x_j = 0 / 1$，问是否存在一组 $\\{ x_n \\}$ 的取值使得满足所有限制条件。
*   考虑对每个 $x_i$ 建立两个点，分别表示 $x_i$ 取 $0$ 和取 $1$，对于每一个限制，从“若”对应的点向“则”对应的点连一条有向边（注意要对逆否命题进行同样的处理）。
*   那么只要一个点被标记为真，则其能到达的所有点都要标记为真，由此对图进行 Tarjan 缩点，则每一个强连通分量要么同为真，要么同为假。
*   同时，$x_i$ 对应的 $2$ 个点必须一真一假，即不能在同一个强连通分量中。
*   只要这个条件满足，就可以通过对缩点形成的 DAG 进行遍历 $/$ 贪心来找到一组合法取值。
*   那么 $d = 0$ 的情况其实就是个裸的 2-SAT 模型。
*   而对于 $d \gt 0$ 的情况，因为 $d \le 8$，所以可以对这几张特殊的图进行暴力枚举，转化为 $d = 0$ 的情况。
*   然后这题就做完了。
*   实际上，2-SAT 模型还支持更多的限制条件，例如：
    *   $x_i = 0 / 1$
    *   $x_i ~ \text{and} / \text{or} / \text{xor} ~ x_j = 0 / 1$
*   可以考虑一下怎么连边。

## P5540 [BalkanOI2011] timeismoney | 最小乘积生成树

*   题目简单易懂，就是想不出。
*   我们需要把视野从图上拿开，考虑 $\sum a$ 和 $\sum b$，可以看作平面上的一个点的横纵坐标。
*   那么对于仅考虑 $a$ 权值和 $b$ 权值求出来的最小生成树，分别对应的是最靠近 $b$ 轴的点 $A$ 和最靠近 $a$ 轴的点 $B$。
*   我们要找的点一定在线段 $AB$ 的左下方，考虑找到一个距离 $AB$ 最远的点，记 $A(a_A, b_A), B(a_B, b_B)$，我们实际上是要求新求的点距离 $(a_B - a_A) b = (b_B - b_A) a$ 这条直线最近，也就是最小化 $(a_B - a_A) \sum b + (b_A - b_B) \sum a$，因此用 $(a_B - a_A) b[i] + (b_A - b_B) a[i]$ 作为新的边权求最小生成树。
*   于是我们找到了点 $C$，答案一定会在线段 $AC$ 和线段 $BC$ 的左下角，于是递归下去，直找到的点就在线段上。
*   答案一定出现在找到的所有点中，期望点数为 $\log(n!) = \mathcal O(n \log n)$。
*   总复杂度 $\mathcal O(n^2 \log n \log m)$。