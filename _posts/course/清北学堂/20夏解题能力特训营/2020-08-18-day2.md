---
layout: post
title:  基础算法
date:   2020-08-18
author: 王欣灏
categories: course qbxt 6
---

# 二分与分治题目选讲2

## $\color{#9D3DCF} \text{P2491}$ [[SDOI2011] 消防](https://www.luogu.com.cn/problem/P2491)

### 方法一：二分答案

1.  要找的路径一定在直径上。
2.  任意找出一条直径，将直径上的边权设为 $0$，再 $\text{DFS}$ 一遍，就可以找出所有点到直径的距离。
3.  从 “枢纽路径” 到每个点的最大距离有两种情况。
    1.  枢纽到该点；
    2.  枢纽到直径的端点。
4.  二分直径两端到枢纽的距离，再判断枢纽的长度是否满足 $s$。
    1.  二分下界为所有点到枢纽路径的最大距离；
    2.  二分上界为直径长度。

```cpp
void DFS(int u, int from) {
    vertex[u].fa = from;
    d = std::max(d, vertex[u].dis);
    if (vertex[p].dis < vertex[u].dis) p = u;
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        int w = edge[e].weight;
        if (v == from) continue;
        if (vertex[v].ond) continue;
        vertex[v].dis = vertex[u].dis + w;
        DFS(v, u);
    }
    return;
}
```

```cpp
bool check(int x) {
    int l = 0;
    int r = dia.size() - 1;
    while (l + 1 < dia.size() && dia.front() - dia[l + 1] <= x) l++;
    while (r - 1 > 0 && dia[r - 1] <= x) r--;
    return vertex[dia[r]].pre - vertex[dia[l]].pre <= x;
}
```

```cpp
void mian() {
    for (int u = p; u; u = vertex[u].fa) dia.push_back(vertex[u].dis);
    for (int u = p; u; u = vertex[u].fa) vertex[u].ond = true;
    for (int u = p; u; u = vertex[u].fa) vertex[u].pre = vertex[u].dis;
    for (int u = p; u; u = vertex[u].fa) vertex[u].dis = 0, DFS(u, vertex[u].fa);
    int l = 0;
    int r = vertex[dia.back()].pre;
    for (int u = 1; u <= n; u++) l = std::max(l, vertex[u].dis);
    while (l < r) {
        int mid = (l + r) / 2;
        if (check（mid)) r = mid;
        else l = mid + 1;
    }
    std::cout << l;
    return;
}
```

```cpp
    p = 1;
    graph::vertex[p].dis = 0;
    graph::DFS(p, 0);
    graph::vertex[p].dis = 0;
    graph::DFS(p, 0);
    graph::mian();
```

### 方法二：尺取法

同 $\color{#3498DA} \text{P1099}$ [树网的核](https://www.luogu.com.cn/problem/P1099)。

```cpp
void mian() {
    int ans = d;
    for (int u = p, v = p; u; u = vertex[u].fa) {
        while (vertex[v].dis - vertex[u].dis > s) v = vertex[v].fa;
        ans = std::min(ans, std::max(vertex[u].dis, vertex[p].dis - vertex[v].dis));
    }
    d = 0;
    for (int u = p; u; u = vertex[u].fa) vertex[u].ond = true;
    for (int u = p; u; u = vertex[u].fa) vertex[u].dis = 0, DFS(u, vertex[u].fa);
    ans = std::max(ans, d);
    std::cout << ans;
    return;
}
```

# 贪心题目选讲

## $\color{#FFC016} \text{P1090}$ [[NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)

$K$ 叉 $\text{huffman}$ 树模型：

$K$ 叉哈夫曼树是棵 $K$ 叉树，建树的方法就是每次选择 $K$ 个权值最小的点，删除这 $K$ 个点，加入一个权值是这 $K$ 个点之和的新点进去。并且使这被删除的 $K$ 个点的父亲成为那个新点。

具体而言，将 $n$ 堆果子看作 $n$ 个数字加入到一个小根堆，每次合并相当于连续 $K$ 次取出堆顶元素，将取出的 $K4 个数求和，再次加入到堆中。 

然而每次选择 $k$ 个权值最小的点的时候容易让最后一次合并的时候的点不足 $k$个。假设最初有 $n$ 个点，最后有 $1$ 个点，每次合并删除 $k$ 个点又放进 $1$ 个点。那么易得：$(n - 1)$ 是 $(k - 1)$ 的倍数。如果 $(n - 1) \% (k - 1) \neq 0$，那么就要再放入 $(k - 1 - (n - 1) \% (k - 1) )$ 个虚拟点，并且它们的权值为 $0$，它们也参与求最小 $k$ 个点。

```cpp
	while (q.size() >= 2) {
		int a = q.top();
		q.pop();
		int b = q.top();
		q.pop();
		ans += a + b;
		q.push(a + b);
	}
```

## $\color{#52C41A} \text{P1717}$ [钓鱼](https://www.luogu.com.cn/problem/P1717)

不会出现来回奔走的情况，只会从左往右走。

### 方法一：$\text{DP}$

*   阶段：从左往右依次讨论以每个池塘作为终点的情况
*   状态：$dp[i][j]$ 表示在 $j$ 个单位时间内，在前 $i$ 个池塘中最多能钓的鱼数
*   决策：在第 $i$ 个池塘钓多长时间的鱼
*   方程：
    *   $dp[i][j] = \max \\{ dp[i - 1][j], dp[i - 1][j - k - walk[i]] + GetFish[i][k] \\}$
    *   $dp[i - 1][j]$ 表示不在第 $i$ 个池塘钓鱼
    *   $GetFish[i][k]$ 表示在第 $i$ 个池塘钓 $k$ 分钟能钓到的鱼数
    *   $walk[i]$ 表示从 $i - 1$ 号池塘到达 $i$号池塘行走花费的时间
    *   $dp[i - 1][j - k - walk[i]]$ 总共 $j$ 分钟，从 $i - 1$ 到 $i$ 行走花费 $walk[i]$ 分钟，$i$ 号池塘钓鱼花费 $k$ 分钟，剩余 $j - k - walk[i]$ 分钟，这 $j - k - walk[i]$ 是前 $i - 1$ 个池塘可以使用的钓鱼时间。

时间复杂度 $\mathcal O(n h^2)$

```cpp
    std::fill(dp[0], dp[0] + （maxN + 10) * （maxH * 12 + 10), -inF）;
    dp[0][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= H; j++) {
            for (int k = 0; k <= j - t[i - 1]; k++) {
                if ((k - 1) * d[i] < dp[i]) {
                    dp[i][j] = std::max(dp[i][j], dp[i - 1][j - t[i - 1] - k] + k * dp[i] - k * (k - 1) / 2 * d[i]);
                    ans = std::max(ans, dp[i][j]);
                }
            }
        }
    }
```

### 方法二：贪心 $+$ 堆

由于终点不固定，而且只能从左往右走，所以枚举终点，依次讨论每个点作为终点的情况：

假设以 $i$ 号池塘作为终点，那么先用总时间减去从 $1$ 号池塘到 $i$ 号池塘行走耗费的时间，$FishTime = h - walk[i]$，那么剩下的时间（$FishTime$）就是用来钓鱼的时间了。

现在就相当于现在可以在1到i号池塘间任意瞬间移动了，每一个单位时间选当前能够钓到鱼最多的池塘来钓就行了，选最大用大根堆实现。

具体操作，先把 $1$ 到 $i$ 号池塘单位时间能够钓鱼的数量存入大根堆：
1.  每次从堆顶取出能钓到最大数量鱼的湖，并在那里钓一个单位时间的鱼，将钓到的鱼累加钓鱼的总数上；
2.  把该湖下一个单位时间能钓鱼的数量更新（减去 $d_i$）后，重新存入堆中；
3.  总钓鱼时间减去一个单位的时间，重复该过程，直到没有时间或没有鱼可钓了为止。

时间复杂度 $\mathcal O(n h \log h)$

```cpp
struct Node {
    int f;
    int i;

    bool operator<(const Node &other) const {
        return f < other.f;
    }
};
```

```cpp
    for (int i = 1; i <= n; i++) {
        res = 0;
        H -= t[i - 1];
        if (H <= 0) break;
        std::priority_queue<Node> q;
        for (int j = 1; j <= i; j++) q.push((Node) {f[j], j});
        for (int j = 1; j <= H; j++) {
            Node node = q.top();
            q.pop();
            if (node.f < 0) break;
            res += node.f;
            q.push((Node) {node.f - d[node.i], node.i});
        }
        ans = std::max(ans, res);
    }
```

## $\color{#FFC016} \text{P1801}$ [黑匣子](https://www.luogu.com.cn/problem/P1801)

### 方法一：用堆暴力枚举

对于每一个 $\text{GET}$ 操作，我们把当前数列的所有数存入一个小根堆，然后用 $k$ 次取出堆顶元素，其中第 $k$ 次取出的堆顶元素就是数列的第 $k$ 小数。

时间复杂度 $\mathcal O(n m \log m)$

### 方法二：$1$ 个大根堆 $+$ $1$ 个小根堆


1.  将通过 $\text{ADD}$ 操作新加入数列的数字全部存入大根堆（两次 $\text{GET}$ 操作之间加入的数字）；
2.  删除大根堆中最大的 $t - k + 1$ 个数，也就是最后大根堆中只留下了 $k - 1$ 个数字（也就是目前数列的前 $k - 1$ 小个数）；
3.  在第 $2$ 步中，每从大根堆里面删除一个数，就将该数加入到小根堆，最后小根堆里面有了 $t - k + 1$ 个数；
4.  第 $3$ 步完成后，小根堆的堆顶元素一定是当前这 $t$ 个数中第 $k$ 小的。  
   因为前 $k - 1$ 小的数在大根堆里面，于是将小根堆堆顶的数字删除，并将该数字加入到大根堆，大根堆里面就有了 $k$ 个数了，也就是前 $k$ 小的数字。
5.  当讨论下一个 $\text{GET}$ 操作时，也就是求第 $k + 1$ 小的数字，上一次 $\text{GET}$ 操作前数列中的所有数字已存入了两个堆中，我们回到步骤 $1$ 继续执行。

```cpp
struct BlackBox {
    std::priority_queue<int, std::vector<int>, std::less<int> > his;
    std::priority_queue<int, std::vector<int>, std::greater<int> > now;

    void ADD(int x) {
        if (his.empty()) {
            now.push(x);
            return;
        }
        if (his.top() > x) {
            now.push(his.top());
            his.pop();
            his.push(x);
        } else {
            now.push(x);
        }
        return;
    }

    int GET() {
        his.push(now.top());
        now.pop();
        return his.top();
    }
} BB;
```

```cpp
    for (int i = 1; i <= n; i++) v[u[i]] ++;
    for (int i = 1; i <= m; i++) {
        BB.ADD(a[i]);
        while (v[i]) {
            v[i]--;
            std::cout << BB.GET() << '\n';
        }
    }
```

## $\color{#52C41A} \text{P2887}$ [[USACO07NOV] Sunscreen G](https://www.luogu.com.cn/problem/P2887)

考虑贪心：
1.  在还没有分配防晒霜的奶牛中，将所有防晒值下限不大于第 $i$ 瓶防晒霜防晒值（$minSPF \le SPF[i]$）的奶牛都找出来；
2.  从这些奶牛中选择防晒值上限不小于第i瓶防晒霜（$maxSPF \ge SPF[i]$）且该值尽可能小的奶牛，将第i瓶防晒霜分配给它们使用。
3.  实现上述操作，我们容易想到将这些奶牛按防晒值上限用小根堆维护即可。


### 具体实现：贪心 $+$ 小根堆
1.  将奶牛按防晒值下限（$minSPF$）由小到大排序，将防晒霜按防晒值（$SPF$）由小到大排序；
2.  依次讨论每瓶防晒霜，设当前讨论第 $i$ 瓶：将还没有分配防晒霜的且防晒值下限不大于 $SPF[i]$ 的奶牛存入小根堆，该堆以奶牛防晒值上限（$maxSPF$）为关键字；
3.  依次取出堆顶元素，若堆顶元素的值（$maxSPF$）不小于 $SPF[i]$，表示对应的牛可用第 $i$ 瓶防晒霜，涂该牛后将第 $i$ 瓶防晒霜可用的次数减一；
4.  在第 $3$ 步中，若取出的堆顶元素的值（$maxSPF$）小于 $SPF[i]$，表示该牛无法涂到防晒霜。因为防晒霜是按防晒值由小到大顺序讨论的，当讨论到第 $i$ 瓶防晒霜时，当前第 $i$ 瓶也无法涂，后面的防晒霜也无法涂到了，因为后面防晒霜的防晒值都不小于第 $i$ 瓶。而前面的 $i - 1$ 瓶防晒霜已讨论完毕，前 $i - 1$ 瓶该牛都没有被涂到，
5.  回到第 $2$ 步，继续讨论第 $i + 1$ 瓶防晒霜。

时间复杂度 $\mathcal O(C \log C)$

```cpp
struct Cow {
    int minSPF;
    int maxSPF;

    bool operator<(const Cow &other) const {
        return maxSPF > other.maxSPF;
    }
} cow[maxC + 10];

struct Cream {
    int SPF;
    int cover;
} cre[maxL + 10];

bool cmpByMinSPF(const Cow &a, const Cow &b) {
    return a.minSPF < b.minSPF;
}

bool cmpBySPF(const Cream &a, const Cream &b) {
    return a.SPF < b.SPF;
}
```

```cpp
    std::sort(cow + 1, cow + C + 1, cmpByMinSPF);
    std::sort(cre + 1, cre + L + 1, cmpBySPF);
    std::priority_queue<int, std::vector<int>, std::greater<int> > q;
    for (int i = 1, j = 1; i <= L; i++) {
        while (j <= C && cow[j].minSPF <= cre[i].SPF) q.push(cow[j].maxSPF), j++;
        while (!q.empty() && cre[i].cover) {
            int c = q.top();
            q.pop();
            if (cre[i].SPF <= c) {
                cre[i].cover--;
                ans++;
            }
        }
    }
```

# 分治之倍增题目选讲

## $\color{#52C41A} \text{P1613}$ [跑路](https://www.luogu.com.cn/problem/P1613)

用一个 `bool` 类型的 $adjacency$ 数组，$adjacency[i][j][k]$ 表示从 $i$ 到 $j$ 是否存在一条长度为 $2^k$ 得路径。那么如果对于任意一个 $k$，$adjacency[i][j][k] = true$，则说明可以用 $1 \text{s}$ 从 $i$ 到 $j$。

再用 $dis$ 数组来记录两点之间需要用多久到达。这样我们可以用 $adjacency$ 来保存所有的边，并且进行预处理，把所有一秒能到的两个点之间都连上边，并把距离相应调整为 $1$。

接下来求出两点之间的最短路。对于 $50$ 的数据，$\text{Floyd}$ 绝对是最简单可行的办法。

```cpp
void Floyd() {
	for (int p = 1; p <= 64; p++) {
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    if (adj[i][k][p - 1] && adj[k][j][p - 1]) {
                        adj[i][j][p] = true, dis[i][j] = 1;
                    }
                }
            }
        }
    }
	for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);
            }
        }
    }
	return;
}
```

## $\color{#3498DA} \text{P3398}$ [仓鼠找 sugar](https://www.luogu.com.cn/problem/P3398)

记 $ab = \text{LCA}(a, b), cd = \text{LCA}(c, d)$，若相交则必有 $ab$ 在路径 $c \sim d$ 或 $cd$ 在路径 $a \sim b$ 上。

判断一个点 $u$ 是否在路径 $s \sim t$ 上的方法：
1. $u$ 到 $s, t$ 的距离和等于 $s, t$ 间的距离；
   $u, v$ 间的距离为 $dep[u] + dep[v] - 2 \times dep[\text{LCA}(u, v)]$；
2. 以下两个条件同时满足：
   1. $dep[u] \ge dep[\text{LCA}(s, t)]$；
   2. $\text{LCA}(s, x) = x$ 或 $\text{LCA}(t, x) = x$。

```cpp
void mian() {
    std::cin >> a >> b >> c >> d;
    int ab = LCA(a, b);
    int cd = LCA(c, d);
    int abcd = LCA(ab, cd);
    if (vertex[ab].dep < vertex[cd].dep) {
        std::swap(ab, cd);
        std::swap(a, c);
        std::swap(b, d);
    }
    if (LCA(ab, c) == ab || LCA(ab, d) == ab) std::cout << "Y\n";
    else std::cout << "N\n";
    return;
}
```

## $\color{#3498DA} \text{P1967}$ [[NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)

### 方法一：$\text{LCA}$ $+$ 树上倍增

考虑哪些边是必要的（可能出现在路径上）。

显然最大生成树外的边是不会被选入的。

考虑如何求出两个结点之间最小边权的最大值。由于两点间路径唯一，只需找出这条路径即可。

$\text{LCA}$ 的方法是从每一个根结点进行搜索，求出节点深度等信息，然后利用这些信息进行树上倍增。同时可以求出边最小值的信息，从而得到答案。

### 方法二：$\text{Kruscal}$ 重构树

略。

## $\text{POJ 3728}$ [The merchant](http://poj.org/problem?id=3728)

* 路径：$u \rightarrow \text{LCA}(u, v) \rightarrow v$。
* 情况：
  1. 在 $u \rightarrow \text{LCA}(u, v)$ 途中完成买卖；
  2. 在 $\text{LCA}(u, v) \rightarrow v$ 途中完成买卖；
  3. 在 $u \rightarrow \text{LCA}(u, v)$ 途中买，在 $\text{LCA}(u, v) \rightarrow v$ 途中卖。

显然可以通过树上倍增来解决。

于是在线维护：
1. $mx[u][p]$：从 $u$ 到 $u$ 往上 $2^p$ 间的最大值；
2. $mn[u][p]$：从 $u$ 到 $u$ 往上 $2^p$ 间的最小值；
3. $up[u][p]$：从 $u$ 到 $u$ 往上 $2^p$ 间的最大差；
4. $dw[u][p]$：从 $u$ 往上 $2^p$ 到 $u$ 间的最大差。

```cpp
struct SparseTable {
    int fa[maxN + 10][logN + 5];
    int mx[maxN + 10][logN + 5];
    int mn[maxN + 10][logN + 5];
    int up[maxN + 10][logN + 5];
    int dw[maxN + 10][logN + 5];

    int QueryMx(int u, int lca) {
        int ret = 0;
        for (int p = logN; p >= 0; p--) {
            if (vertex[fa[u][p]].dep >= vertex[lca].dep) {
                ret = std::max(ret, mx[u][p]);
                u = fa[u][p];
            }
        }
        return ret;
    }

    int QueryMn(int u, int lca) {
        int ret = inf;
        for (int p = logN; p >= 0; p--) {
            if (vertex[fa[u][p]].dep >= vertex[lca].dep) {
                ret = std::min(ret, mn[u][p]);
                u = fa[u][p];
            }
        }
        return ret;
    }

    int QueryUp(int u, int lca) {
        int ret = 0;
        int t = inf;
        for (int p = logN; p >= 0; p--) {
            if (vertex[fa[u][p]].dep >= vertex[lca].dep) {
                ret = std::max(ret, up[u][p]);
                ret = std::max(ret, mx[u][p] - t);
                t = std::min(t, mn[u][p]);
                u = fa[u][p];
            }
        }
        return ret;
    }

    int QueryDw(int u, int lca) {
        int ret = 0;
        int t = 0;
        for (int p = logN; p >= 0; p--) {
            if (vertex[fa[u][p]].dep >= vertex[lca].dep) {
                ret = std::max(ret, dw[u][p]);
                ret = std::max(ret, t - mn[u][p]);
                t = std::max(t, mx[u][p]);
                u = fa[u][p];
            }
        }
        return ret;
    }
} ST;
```

```cpp
void DFS(int u, int from) {
    vertex[u].dep = vertex[from].dep + 1;
    ST.fa[u][0] = from;
    for (int p = 1; p <= logN; p++) {
        int t = ST.fa[u][p - 1];
        ST.fa[u][p] = ST.fa[t][p - 1];
        ST.mx[u][p] = std::max(ST.mx[u][p - 1], ST.mx[t][p - 1]);
        ST.mn[u][p] = std::min(ST.mn[u][p - 1], ST.mn[t][p - 1]);
        ST.up[u][p] = std::max(std::max(0, ST.mx[t][p - 1] - ST.mn[u][p - 1]), std::max(ST.up[u][p - 1], ST.up[t][p - 1]));
        ST.dw[u][p] = std::max(std::max(0, ST.mx[u][p - 1] - ST.mn[t][p - 1]), std::max(ST.dw[u][p - 1], ST.dw[t][p - 1]));
    }
    for (int e = vertex[u].head; e; e = edge[e].next ){
        int v = edge[e].head;
        if (v == from) continue;
        ST.mx[v][0] = std::max(w[u], w[v]);
        ST.mn[v][0] = std::min(w[u], w[v]);
        ST.up[v][0] = std::max(0, w[u] - w[v]);
        ST.dw[v][0] = std::max(0, w[v] - w[u]);
        DFS(v, u);
    }
    return;
}
```

```cpp
void mian() {
    std::cin >> u >> v;
    int lca = LCA(u, v);
    int ans = 0;
    ans = std::max(ans, ST.QueryUp(u, lca));
    ans = std::max(ans, ST.QueryDw(v, lca));
    ans = std::max(ans, ST.QueryMx(v, lca) - ST.QueryMn(u, lca));
    std::cout << ans << '\n';
    return;
}
```