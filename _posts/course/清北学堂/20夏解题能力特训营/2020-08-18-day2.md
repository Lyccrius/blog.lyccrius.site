---
layout: post
title:  基础算法
date:   2020-08-18
author: 王欣灏
categories: course qbxt 6
---

# 二分与分治题目选讲2

## [$\color{#9D3DCF} \mathrm{P2491}$](https://www.luogu.com.cn/problem/P2491) [SDOI2011] 消防

1. 要找的路径一定在直径上。
2. 任意找出一条直径，将直径上的边权设为 $0$，再 $\text{DFS}$ 一遍，就可以找出所有点到直径的距离。
3. 从 “枢纽路径” 到每个点的最大距离有两种情况。
   1. 枢纽到该点；
   2. 枢纽到直径的端点。
4. 二分直径两端到枢纽的距离，再判断枢纽的长度是否满足 $S$。
   1. 二分下界为所有点到枢纽路径的最大距离；
   2. 二分上界为直径长度。

```cpp
void DFS(int u, int from) {
    vertex[u].fa = from;
    d = std::max(d, vertex[u].dis);
    if (vertex[p].dis < vertex[u].dis) p = u;
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        int w = edge[e].weight;
        if (v == from) continue;
        if (vertex[v].ond) continue;
        vertex[v].dis = vertex[u].dis + w;
        DFS(v, u);
    }
    return;
}
```

```cpp
bool check(int x) {
    int l = 0;
    int r = dia.size() - 1;
    while (l + 1 < dia.size() && dia.front() - dia[l + 1] <= x) l++;
    while (r - 1 > 0 && dia[r - 1] <= x) r--;
    return vertex[dia[r]].pre - vertex[dia[l]].pre <= x;
}
```

```cpp
void mian() {
    for (int u = p; u; u = vertex[u].fa) dia.push_back(vertex[u].dis);
    for (int u = p; u; u = vertex[u].fa) vertex[u].ond = true;
    for (int u = p; u; u = vertex[u].fa) vertex[u].pre = vertex[u].dis;
    for (int u = p; u; u = vertex[u].fa) vertex[u].dis = 0, DFS(u, vertex[u].fa);
    int l = 0;
    int r = vertex[dia.back()].pre;
    for (int u = 1; u <= n; u++) l = std::max(l, vertex[u].dis);
    while (l < r) {
        int mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    std::cout << l;
    return;
}
```

```cpp
    p = 1;
    graph::vertex[p].dis = 0;
    graph::DFS(p, 0);
    graph::vertex[p].dis = 0;
    graph::DFS(p, 0);
    graph::mian();
```

也可以同 [$\color{#3498DA} \mathrm{P1099}$](https://www.luogu.com.cn/problem/P1099) 树网的核 尺取法。

```cpp
void mian() {
    int ans = d;
    for (int u = p, v = p; u; u = vertex[u].fa) {
        while (vertex[v].dis - vertex[u].dis > s) v = vertex[v].fa;
        ans = std::min(ans, std::max(vertex[u].dis, vertex[p].dis - vertex[v].dis));
    }
    d = 0;
    for (int u = p; u; u = vertex[u].fa) vertex[u].ond = true;
    for (int u = p; u; u = vertex[u].fa) vertex[u].dis = 0, DFS(u, vertex[u].fa);
    ans = std::max(ans, d);
    std::cout << ans;
    return;
}
```

# 贪心题目选讲

## [$\color{#FFC016}$ \mathrm{P1090}](https://www.luogu.com.cn/problem/P1090) [NOIP2004 提高组] 合并果子

$K$ 叉 $\text{huffman}$ 树模型：

$K$ 叉哈夫曼树是棵 $K$ 叉树，建树的方法就是每次选择 $K$ 个权值最小的点，删除这 $K$ 个点，加入一个权值是这 $K$ 个点之和的新点进去。并且使这被删除的 $K$ 个点的父亲成为那个新点。

具体而言，将 $n$ 堆果子看作 $n$ 个数字加入到一个小根堆，每次合并相当于连续 $K$ 次取出堆顶元素，将取出的 $K4 个数求和，再次加入到堆中。 

然而每次选择 $k$ 个权值最小的点的时候容易让最后一次合并的时候的点不足 $k$个。假设最初有 $n$ 个点，最后有 $1$ 个点，每次合并删除 $k$ 个点又放进 $1$ 个点。那么易得：$(n - 1)$ 是 $(k - 1)$ 的倍数。如果 $(n - 1) \% (k - 1) \neq 0$，那么就要再放入 $(k - 1 - (n - 1) \% (k - 1) )$ 个虚拟点，并且它们的权值为 $0$，它们也参与求最小 $k$ 个点。

```cpp
	while (q.size() >= 2) {
		int a = q.top();
		q.pop();
		int b = q.top();
		q.pop();
		ans += a + b;
		q.push(a + b);
	}
```

## [$\color{#52C41A} \mathrm{P1717}$](https://www.luogu.com.cn/problem/P1717) 钓鱼

不会出现来回奔走的情况，只会从左往右走。

