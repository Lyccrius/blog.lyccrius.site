---
layout: post
title:  全真模拟考试1
date:   2020-08-17
author: 王欣灏
categories: course qbxt 6
---

## #1. [CSP.AC:227] - 序列

### Problem Description

小王有$1$到$n$这$n$个整数，小杨想让小王把这$n$个整数排成一行使其满足一定的条件

1）最长上升子序列的长度为$x$

2）最长下降子序列的长度为$y$

如果有多个满足要求的排列，输出字典序最小的一个

### Input

输入第一行为三个整数$n,x,y$，含义如题目所述

### Output

第一行为"YES"或"NO"（不含引号），表示答案是否存在。若答案存在，在第二行输出这个序列。

### Sample Input 1

```txt
10 1 10
```


### Sample Output 1

```txt
YES
10 9 8 7 6 5 4 3 2 1
```

### Sample Input 2

```txt
10 6 4
```


### Sample Output 2

```txt
YES
1 2 3 4 6 5 10 9 8 7
```

### Sample Input 3

```txt
10 8 8
```


### Sample Output 3

```txt
NO
```

### Sample Input 4

```txt
10 3 4
```


### Sample Output 4

```txt
YES
2 1 6 5 4 3 10 9 8 7
```

### Hint

对于$50\%$的数据，$n\leq 10$

对于$100\%$的数据，$n\leq 100000$，$1\leq x,y\leq n$

### Solution

#### 50分解法

*   爆搜全排列，按照 $1 \sim n$ 的顺序，找到的第一个满足条件的就是字典序最小的

#### 100分解法

*   观察样例：答案总是 $(1, 2, \cdots, x_1), (x_2, x_2 - 1, \cdots, x_1 + 1), (x_3, x_3 - 1, \cdots, x_2 + 1), \cdots, (n, n - 1, \cdots, x_k + 1)$
*   也就是最前面一段从 $1$ 开始的连续递增序列，后面若干段连续递减序列
*   头尾两段可以没有
*   尝试构造
*   把那些连续递减序列叫做逆序块，显然块大小不超过 $y$
*   将初始序列置为 $1, 2, \cdots, n$，将最后 $y$ 个数逆序得到 $1, 2, \cdots, n - y, (n, n - 1, \cdots, n - y + 1)$
*   等价于在末尾构造了一个 $y$ 大小的逆序块，使得 $\text{LIS}$ 长度减小了 $y - 1$ 变为了 $n - (y - 1)$
*   所以，我们通过不断构造逆序块来减小 $\text{LIS}$ 长度，同时逆序块大小不超过 $y$，也满足 $\text{LIS}$ 的条件
*   再来看无解的情况
*   我们提出了构造逆序块的方法，那么最恰好的情况，所有逆序块大小均为 $y$ 且总长刚好为 $n$，此时 $\text{LIS}$ 长度即为逆序块的个数，记为 $x$，那么有 $xy = n$
*   如果 $xy \lt n$，说明构造了 $x$ 个大小为 $y$ 的逆序块后，序列前段还有数字，此时不可能满足条件，$\text{LIS}$ 必然大于 $x$，无解
*   另一种情况：若 $x + y \gt n + 1$，显然无解

```cpp
#include <iostream>
#include <algorithm>

const int maxN = 1e5;

int n, x, y;
int a[maxN + 10];

int main() {
    std::cin >> n >> x >> y;
    if (1ll * x * y < n || x + y > n + 1) {
        std::cout << "NO\n";
        return 0;
    }
    std::cout << "YES\n";
    for (int i = 1; i <= n; i++) a[i] = i;
    int t = n - x;
    int r = n;
    int l = n - y + 1;
    while (t) {
        l = std::max(l, r - t);
        std::reverse(a + l, a + r + 1);
        r -= y;
        l -= std::min(t, y);
        t -= std::min(t, y - 1);
    }
    for (int i = 1; i <= n; i++) std::cout << a[i] << ' ';
    return 0;
}
```

## 	#2. [CSP.AC:228] - 链接

### Problem Description

​	小王来到了一片森林，森林中有一些树和连接两棵树的无向道路，**保证这些道路能把森林连通**。

​	小王对这片森林做了一些考察，有了两个奇怪的发现：

​	1）森林中的树总共分为两种，不妨记为$0$型树和$1$型树。
    
​	2）这些道路的长度都是$2$的整数次幂且互不相同，第$i$条道路的长度为$2^i$。

​	小王又发现了这片森林的一个神奇之处，任何两棵类型不同的树之间都可以构成一组链接，这一对链接的能量值为两棵树之间的最短路。

​	好奇的小王想知道这片森林所有链接的能量值之和，请你来帮帮他。

### Input

​	输入第一行包含两个整数$n,m$，表示森林中树的数量和无向道路的数量。

​	接下来一行包含$n$个整数$a_1,a_2,...,a_n(a_i=0\ or\ 1)$，表示每一棵树的类型。

​	接下来$m$行，第$i$行表示第$i$条无向道路，包含两个整数$u_i,v_i(1\leq u_i,v_i \leq n)$表示第$i$条无向道路连接的树的编号，并且它的长度为$2^i$。

### Output

​	输出一个整数，所有链接能量值之和对$10^9+7$取模的结果

### Sample Input 1

```txt
3 2
0 1 0
3 1
1 2
```


### Sample Output 1

```txt
10
```

### Sample Input 2

```txt
10 11
0 1 0 1 0 1 0 1 0 1
1 2
1 3
1 4
2 5
2 6
3 7
4 8
5 9
9 10
5 6
2 7
```

### Sample Output 2

```txt
6050
```


### Hint

​对于$20\%$的数据，$n\leq 10$

​对于$40\%$的数据，$n\leq 20$

​对于$100\%$的数据，$n\leq 100000, 1\leq m\leq 200000$

### Solution

#### 20~40分解法

* $\text{Floyd}$
* 每个 $1$ 型点 $\text{SPFA}$

#### 100分解法

*   第 $i$ 条边的权值是 $2^i$，发现 $2^1 + 2^2 + \cdots, + 2^{(i - 1)} \lt 2^i$，所以如果两个点能通过加入前 $i - 1$ 条边连通，那最短路肯定不会经过第 $i$ 条边，于是从 $1$ 到 $n$ 按顺序建最小生成树。
*   对于 $0$ 点和 $1$ 点的最短路，我们只需枚举最小生成树上的每条边，这条边两侧的任意 $0 1$ 点组合的最短路都会通过这条边，所以统计该边两侧的 $0 1$ 点个数，计算贡献即可

```cpp
#include <iostream>
#include <vector>

typedef long long lxl;

const int maxN = 1e5;
const int maxM = 2e5;
const int mod = 1e9 + 7;

int n, m;
int a[maxN + 10];
int u[maxM + 10], v[maxM + 10];
int w = 1;
int tot[2];
lxl ans;

namespace tree {
    struct Vertex {
        int head;
        int size[2];
    } vertex[maxN + 10];

    struct Edge {
        int head;
        int next;
        int weight;
    } edge[maxN * 2 + 10];

    int ecnt;

    void addEdge(int tail, int head, int weight) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].weight = weight;
        edge[ecnt].next = vertex[tail].head;
        vertex[tail].head = ecnt;
        return;
    }

    void DFS(int u, int from) {
        vertex[u].size[a[u]]++;
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            int w = edge[e].weight;
            if (v == from) continue;
            DFS(v, u);
            vertex[u].size[0] += vertex[v].size[0];
            vertex[u].size[1] += vertex[v].size[1];
        }
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            int w = edge[e].weight;
            if (v == from) continue;
            ans = (ans + 1ll * vertex[v].size[0] * (tot[1] - vertex[v].size[1]) % mod * w) % mod;
            ans = (ans + 1ll * vertex[v].size[1] * (tot[0] - vertex[v].size[0]) % mod * w) % mod;
        }
        return;
    }
}

namespace graph {
    struct Vertex {
        int fa;
    } vertex[maxN + 10];

    struct Edge {
        int tail;
        int head;
        int weight;
    };

    std::vector<Edge> edge;

    void addEdge(int tail, int head, int weight) {
        edge.push_back((Edge) {tail, head, weight});
        return;
    }

    struct DisjointSetUnion {
        int Find(int u) {
            if (vertex[u].fa == u) return u;
            return vertex[u].fa = Find(vertex[u].fa);
        }

        void Union(int u, int v) {
            u = Find(u);
            v = Find(v);
            vertex[u].fa = v;
            return;
        }

        void Init() {
            for (int u = 1; u <= n; u++) vertex[u].fa = u;
            return;
        }
    } DSU;

    void Kruscal() {
        DSU.Init();
        for (int e = 0; e < edge.size(); e++) {
            int u = edge[e].tail;
            int v = edge[e].head;
            int w = edge[e].weight;
            int fu = DSU.Find(u);
            int fv = DSU.Find(v);
            if (fu == fv) continue;
            DSU.Union(u, v);
            tree::addEdge(u, v, w);
            tree::addEdge(v, u, w);
        }
        return;
    }
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i], tot[a[i]]++;
    for (int i = 1; i <= m; i++) std::cin >> u[i] >> v[i], w = w * 2 % mod, graph::addEdge(u[i], v[i], w);
    graph::Kruscal();
    tree::DFS(1, 0);
    std::cout << ans;
    return 0;
}
```