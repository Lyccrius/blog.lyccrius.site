---
layout: post
title:  基础算法
date:   2020-08-17
author: 王欣灏
categories: course qbxt 6
---

# 二分与分治题目选讲1

## P1281 书的复制

最大值最小，二分答案。

前面人少抄，倒序处理。

```cpp
bool check(int T) {
    int cur = m;
    for (int i = 1; i <= k; i++) s[i] = 0, t[i] = 0;
    for (int i = k; i >= 1; i--) {
        int t = 0;
        while (cur >= 1 && t + p[cur] <= T) t += p[cur], cur--;
    }
    return cur == 0;
}
```

```cpp
    int l = minP;
    int r = sumP;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    int cur = m;
    for (int i = k; i >= 1; i--) {
        int T = 0;
        while (cur >= 1 && T + p[cur] <= l) {
            T += p[cur];
            if (t[i] == 0) t[i] = cur;
            s[i] = cur;
            cur--;
        }
    }
```

## P2759 奇怪的函数

符合单调性，二分答案。

$$
\begin{aligned}
    x^x & \ge 10^{n - 1} \\
    x \ln x & \ge n - 1
\end{aligned}
$$

```
    lxl l = 1;
    lxl r = inf;
    while (l < r) {
        lxl mid = (l + r) >> 1;
        if (mid * std::log10(1.0 * mid) >= n - 1) r = mid;
        else l = mid + 1;
    }
```

## P1258 小车问题

二分甲乘车路程直至甲乙时间相同。

*   若 $t_1 \lt t_2$，则甲乘车多了，应左移；
*   若 $t_1 \gt t_2$，则甲乘车少了，应右移。

```cpp
bool check(double x) {
    double t11 = x / b;
    double t12 = (s - x) / a;
    double t1 = t11 + t12;
    double s21 = a * t11;
    double t21 = (x - s21) / (a + b);
    double s22 = a * t21;
    double t22 = (s - s21 - s22) / b;
    double t2 = t11 + t21 + t22;
    return t1 <= t2;
}
```

```cpp
    double l = 0;
    double r = s;
    while (r - l >= eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    double t1 = l / b;
    double t2 = (s - l) / a;
    double t = t1 + t2;
```

## P1429 平面最近点对（加强版）

分治。

```cpp
double solve(int l, int r) {
    int mid = (l + r) / 2;
    if (r == l + 1) return dis(node[l], node[r]);
    if (r == l + 2) return std::min(dis(node[l], node[r]), std::min(dis(node[l], node[l + 1]), dis(node[r - 1], node[r])));
    double d = std::min(solve(l, mid), solve(mid + 1, r));
    std::vector<Node> s;
    for (int i = l; i <= r; i++) if (node[mid].x - d <= node[i].x && node[i].x <= node[mid].x + d) s.push_back(node[i]);
    std::sort(s.begin(), s.end(), cmpByY);
    for (int i = 0; i < s.size(); i++) {
        for (int j = i + 1; j < s.size(); j++) {
            if (s[i].y + d <= s[j].y) break;
            d = std::min(d, dis(s[i], s[j]));
        }
    }
    return d;
}
```

# 三分

## NKOI 2000 一元三次方程求解

>   有形如：$ax^3 + bx^2 + cx + d = 0$ 这样的一个一元三次方程。给出该方程中各项的系数（$a, b, c, d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $- 10000$ 至 $10000$ 之间），且根与根之差的绝对值 $\ge 1$。  
>   要求由小到大依次在同一行输出这三个实根（根与根之间留有空格），并精确到小数点后 $4$ 位。

在 $[a, a + 1]$ 这 $20000$ 个区间内，每个区间内至多只能有一个根。

只有当 $f(a) = 0$ 或 $f(a) \times f(a + 1) \lt 0$ 时，方程在此区间内才有解。

*   若 $f(a) = 0$，解即为 $a$；
*   若 $f(a) \times f(a + 1) \lt 0$，则可以用二分求解。

```cpp
double f(double x) {
    double ret = 0;
    ret += a * x * x * x;
    ret += b * x * x;
    ret += c * x;
    ret += d;
    return ret;
}
```

```cpp
double solve(double l, double r) {
    while (r - l >= eps) {
        double mid = (l + r) / 2;
        double y = f(mid);
        if (fabs(y) <= eps) {
            ans.push_back(mid);
            return;
        }
        if (f(l) * y < 0) r = mid;
        else l = mid;
    }
    ans.push_back(l);
    return;
}
```

```cpp
    if (f(-10000) == 0) ans.push(-10000);
    for (int i = -10000; i < 10000; i++) {
        if (ans.size() == 3) break;
        double y1 = f(i);
        double y2 = f(i + 1);
        if (y1 * y2 < 0) solve(i, i + 1);
        else if (y2 == 0) ans.push(i + 1);
    }
```

## P3382 【模板】三分法

*   二分查找所面向的搜索序列的要求是：具有**单调性**（不一定严格单调）；
*   三分法所面向的搜索序列的要求时：**序列为一个凸性函数（单峰函数）**。

```cpp
    while (r - l >= eps) {
        double gap = (r - l) / 3;
        double lmid = l + gap;
        double rmid = r - gap;
        if (f(lmid) <= f(rmid)) l = lmid;
        else r = rmid;
    }
```

时间复杂度 $\mathcal O(\log_\frac{3}{2} n)$

## ZOJ3203 Light Bulb

*   墙上没有：$L = (D \times h) \div H$；
*   墙上有：$L = D - x + H - D \times (H - h) \div x$。

```cpp
double f(double x) {
    double d = (h * x) / (H - h);
    double L;
    if (x + d <= D) {
        L = d;
    } else {
        double l = (h / d) * (x + d - D);
        L = (D - x) + l;
    }
    return L;
}
```

## 函数

>   给定两个下凸二次函数 $f(x), g(x)$，构造 $h(x) = \min \\{ f(x), g(x) \\}$。  
>   求 $h(x)$ 在区间 $[0, 1000]$ 上的最小值。

*   法1：两条对称轴最多把区间分为三段；
*   法2：两个二次函数最多有两个交点，交点隔开的区间上，显然 $h(x) = f(x)$ 或 $h(x) = g(x)$，变为一个函数的情况。

# 二分与分治题目选讲2

## P2571 [SCOI2010]传送带

三分套三分。

```cpp
double dis(double ax, double ay, double bx, double by) {
    double dx = ax - bx;
    double dy = ay - by;
    return std::sqrt(dx * dx + dy * dy);
}

double calc(double Ex, double Ey, double Fx, double Fy) {
    double ret = 0;
    ret += dis(Ax, Ay, Ex, Ey) / P;
    ret += dis(Ex, Ey, Fx, Fy) / R;
    ret += dis(Fx, Fy, Dx, Dy) / Q;
    return ret;
}

double solveF(double lx, double ly, double rx, double ry, double Ex, double Ey) {
    while (std::fabs(rx - lx) >= eps || std::fabs(ry - ly) >= eps) {
        double gx = (rx - lx) / 3;
        double gy = (ry - ly) / 3;
        double lxm = lx + gx;
        double rxm = rx - gx;
        double lym = ly + gy;
        double rym = ry - gy;
        if (calc(Ex, Ey, lxm, lym) > calc(Ex, Ey, rxm, rym)) lx = lxm, ly = lym;
        else rx = rxm, ry = rym;
    }
    return calc(Ex, Ey, lx, ly);
}

double solveE(double lx, double ly, double rx, double ry) {
    while (std::fabs(rx - lx) >= eps || std::fabs(ry - ly) >= eps) {
        double gx = (rx - lx) / 3;
        double gy = (ry - ly) / 3;
        double lxm = lx + gx;
        double rxm = rx - gx;
        double lym = ly + gy;
        double rym = ry - gy;
        if (solveF(Cx, Cy, Dx, Dy, lxm, lym) > solveF(Cx, Cy, Dx, Dy, rxm, rym)) lx = lxm, ly = lym;
        else rx = rxm, ry = rym;
    }
    return solveF(Cx, Cy, Dx, Dy, lx, ly);
}
```