---
layout: post
title:  基础算法
date:   2020-08-17
author: 王欣灏
categories: course qbxt 6
---

# 二分与分治题目选讲1

## [$\color{#52C41A} \mathrm{P1281}$](https://www.luogu.com.cn/problem/P1281) 书的复制

最大值最小，二分答案。

前面人少抄，倒序处理。

```cpp
bool check(int T) {
    int cur = m;
    for (int i = 1; i <= k; i++) s[i] = 0, t[i] = 0;
    for (int i = k; i >= 1; i--) {
        int t = 0;
        while (cur >= 1 && t + p[cur] <= T) t += p[cur], cur--;
    }
    return cur == 0;
}
```

```cpp
    int l = minP;
    int r = sumP;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    int cur = m;
    for (int i = k; i >= 1; i--) {
        int T = 0;
        while (cur >= 1 && T + p[cur] <= l) {
            T += p[cur];
            if (t[i] == 0) t[i] = cur;
            s[i] = cur;
            cur--;
        }
    }
```

## [$\color{#FFc016} \mathrm{P2759}$](https://www.luogu.com.cn/problem/P2759) 奇怪的函数

符合单调性，二分答案。

$$
\begin{aligned}
    x^x & \ge 10^{n - 1} \\
    x \ln x & \ge n - 1
\end{aligned}
$$

```
    lxl l = 1;
    lxl r = inf;
    while (l < r) {
        lxl mid = (l + r) >> 1;
        if (mid * std::log10(1.0 * mid) >= n - 1) r = mid;
        else l = mid + 1;
    }
```

## [$\color{#F39C12} \mathrm{P1258}$](https://www.luogu.com.cn/problem/P1258) 小车问题

二分甲乘车路程直至甲乙时间相同。

* 若 $t_1 \lt t_2$，则甲乘车多了，应左移；
* 若 $t_1 \gt t_2$，则甲乘车少了，应右移。

```cpp
bool check(double x) {
    double t11 = x / b;
    double t12 = (s - x) / a;
    double t1 = t11 + t12;
    double s21 = a * t11;
    double t21 = (x - s21) / (a + b);
    double s22 = a * t21;
    double t22 = (s - s21 - s22) / b;
    double t2 = t11 + t21 + t22;
    return t1 <= t2;
}
```

```cpp
    double l = 0;
    double r = s;
    while (r - l >= eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    double t1 = l / b;
    double t2 = (s - l) / a;
    double t = t1 + t2;
```

## [$\color{#3498DA} \mathrm{P1429}$](https://www.luogu.com.cn/problem/P1429) 平面最近点对（加强版）

分治。

```cpp
double solve(int l, int r) {
    int mid = (l + r) / 2;
    if (r == l + 1) return dis(node[l], node[r]);
    if (r == l + 2) return std::min(dis(node[l], node[r]), std::min(dis(node[l], node[l + 1]), dis(node[r - 1], node[r])));
    double d = std::min(solve(l, mid), solve(mid + 1, r));
    std::vector<Node> s;
    for (int i = l; i <= r; i++) if (node[mid].x - d <= node[i].x && node[i].x <= node[mid].x + d) s.push_back(node[i]);
    std::sort(s.begin(), s.end(), cmpByY);
    for (int i = 0; i < s.size(); i++) {
        for (int j = i + 1; j < s.size(); j++) {
            if (s[i].y + d <= s[j].y) break;
            d = std::min(d, dis(s[i], s[j]));
        }
    }
    return d;
}
```

# 三分

## NKOI 2000 一元三次方程求解

> 有形如：$ax^3 + bx^2 + cx + d = 0$ 这样的一个一元三次方程。给出该方程中各项的系数（$a, b, c, d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $- 10000$ 至 $10000$ 之间），且根与根之差的绝对值 $\ge 1$。  
> 要求由小到大依次在同一行输出这三个实根（根与根之间留有空格），并精确到小数点后 $4$ 位。

在 $[a, a + 1]$ 这 $20000$ 个区间内，每个区间内至多只能有一个根。

只有当 $f(a) = 0$ 或 $f(a) \times f(a + 1) \lt 0$ 时，方程在此区间内才有解。

* 若 $f(a) = 0$，解即为 $a$；
* 若 $f(a) \times f(a + 1) \lt 0$，则可以用二分求解。

```cpp
double f(double x) {
    double ret = 0;
    ret += a * x * x * x;
    ret += b * x * x;
    ret += c * x;
    ret += d;
    return ret;
}
```

```cpp
double solve(double l, double r) {
    while (r - l >= eps) {
        double mid = (l + r) / 2;
        double y = f(mid);
        if (fabs(y) <= eps) {
            ans.push_back(mid);
            return;
        }
        if (f(l) * y < 0) r = mid;
        else l = mid;
    }
    ans.push_back(l);
    return;
}
```

```cpp
    if (f(-10000) == 0) ans.push(-10000);
    for (int i = -10000; i < 10000; i++) {
        if (ans.size() == 3) break;
        double y1 = f(i);
        double y2 = f(i + 1);
        if (y1 * y2 < 0) solve(i, i + 1);
        else if (y2 == 0) ans.push(i + 1);
    }
```

## [$\color{#FFC016} \mathrm{P3382}$](https://www.luogu.com.cn/problem/P3382) 【模板】三分法

* 二分查找所面向的搜索序列的要求是：具有**单调性**（不一定严格单调）；
* 三分法所面向的搜索序列的要求时：：**序列为一个凸性函数（单峰函数）**。

```cpp
    while (r - l >= eps) {
        double gap = (r - l) / 3;
        double lmid = l + gap;
        double rmid = r - gap;
        if (f(lmid) <= f(rmid)) l = lmid;
        else r = rmid;
    }
```

时间复杂度 $\mathcal O(\log_\frac{3}{2} n)$

## [$\mathrm{ZOJ3203}$](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367865) Light Bulb

* 墙上没有：$L = (D \times h) \div H$；
* 墙上有：$L = D - x + H - D \times (H - h) \div x$。

```cpp
double f(double x) {
    double d = (h * x) / (H - h);
    double L;
    if (x + d <= D) {
        L = d;
    } else {
        double l = (h / d) * (x + d - D);
        L = (D - x) + l;
    }
    return L;
}
```

## 函数

> 给定两个下凸二次函数 $f(x), g(x)$，构造 $h(x) = \min \\{ f(x), g(x) \\}$。  
> 求 $h(x)$ 在区间 $[0, 1000]$ 上的最小值。

* 法1：两条对称轴最多把区间分为三段；
* 法2：两个二次函数最多有两个交点，交点隔开的区间上，显然 $h(x) = f(x)$ 或 $h(x) = g(x)$，变为一个函数的情况。

# 二分与分治题目选讲2

## [$\color{#3498DA} \mathrm{P2571}$](https://www.luogu.com.cn/problem/P2571) [SCOI2010]传送带

> 《胡不归》

三分套三分。

```cpp
double dis(double ax, double ay, double bx, double by) {
    double dx = ax - bx;
    double dy = ay - by;
    return std::sqrt(dx * dx + dy * dy);
}

double calc(double Ex, double Ey, double Fx, double Fy) {
    double ret = 0;
    ret += dis(Ax, Ay, Ex, Ey) / P;
    ret += dis(Ex, Ey, Fx, Fy) / R;
    ret += dis(Fx, Fy, Dx, Dy) / Q;
    return ret;
}

double solveF(double lx, double ly, double rx, double ry, double Ex, double Ey) {
    while (std::fabs(rx - lx) >= eps || std::fabs(ry - ly) >= eps) {
        double gx = (rx - lx) / 3;
        double gy = (ry - ly) / 3;
        double lxm = lx + gx;
        double rxm = rx - gx;
        double lym = ly + gy;
        double rym = ry - gy;
        if (calc(Ex, Ey, lxm, lym) > calc(Ex, Ey, rxm, rym)) lx = lxm, ly = lym;
        else rx = rxm, ry = rym;
    }
    return calc(Ex, Ey, lx, ly);
}

double solveE(double lx, double ly, double rx, double ry) {
    while (std::fabs(rx - lx) >= eps || std::fabs(ry - ly) >= eps) {
        double gx = (rx - lx) / 3;
        double gy = (ry - ly) / 3;
        double lxm = lx + gx;
        double rxm = rx - gx;
        double lym = ly + gy;
        double rym = ry - gy;
        if (solveF(Cx, Cy, Dx, Dy, lxm, lym) > solveF(Cx, Cy, Dx, Dy, rxm, rym)) lx = lxm, ly = lym;
        else rx = rxm, ry = rym;
    }
    return solveF(Cx, Cy, Dx, Dy, lx, ly);
}
```

# 全真模拟考试1

## #1. [[CSP.AC:227]](https://noip.ac/rs/show_problem/3020) - 序列

### Problem Description

小王有$1$到$n$这$n$个整数，小杨想让小王把这$n$个整数排成一行使其满足一定的条件

1）最长上升子序列的长度为$x$

2）最长下降子序列的长度为$y$

如果有多个满足要求的排列，输出字典序最小的一个

### Input

输入第一行为三个整数$n,x,y$，含义如题目所述

### Output

第一行为"YES"或"NO"（不含引号），表示答案是否存在。若答案存在，在第二行输出这个序列。

### Sample Input 1

```txt
10 1 10
```


### Sample Output 1

```txt
YES
10 9 8 7 6 5 4 3 2 1
```

### Sample Input 2

```txt
10 6 4
```


### Sample Output 2

```txt
YES
1 2 3 4 6 5 10 9 8 7
```

### Sample Input 3

```txt
10 8 8
```


### Sample Output 3

```txt
NO
```

### Sample Input 4

```txt
10 3 4
```


### Sample Output 4

```txt
YES
2 1 6 5 4 3 10 9 8 7
```

### Hint

对于$50\%$的数据，$n\leq 10$

对于$100\%$的数据，$n\leq 100000$，$1\leq x,y\leq n$

### Solution

#### 50分解法

* 爆搜全排列，按照 $1 \sim n$ 的顺序，找到的第一个满足条件的就是字典序最小的

#### 100分解法

* 观察样例：答案总是 $(1, 2, \cdots, x_1), (x_2, x_2 - 1, \cdots, x_1 + 1), (x_3, x_3 - 1, \cdots, x_2 + 1), \cdots, (n, n - 1, \cdots, x_k + 1)$
* 也就是最前面一段从 $1$ 开始的连续递增序列，后面若干段连续递减序列
* 头尾两段可以没有
* 尝试构造
* 把那些连续递减序列叫做逆序块，显然块大小不超过 $y$
* 将初始序列置为 $1, 2, \cdots, n$，将最后 $y$ 个数逆序得到 $1, 2, \cdots, n - y, (n, n - 1, \cdots, n - y + 1)$
* 等价于在末尾构造了一个 $y$ 大小的逆序块，使得 $\text{LIS}$ 长度减小了 $y - 1$ 变为了 $n - (y - 1)$
* 所以，我们通过不断构造逆序块来减小 $\text{LIS}$ 长度，同时逆序块大小不超过 $y$，也满足 $\text{LIS}$ 的条件
* 再来看无解的情况
* 我们提出了构造逆序块的方法，那么最恰好的情况，所有逆序块大小均为 $y$ 且总长刚好为 $n$，此时 $\text{LIS}$ 长度即为逆序块的个数，记为 $x$，那么有 $xy = n$
* 如果 $xy \lt n$，说明构造了 $x$ 个大小为 $y$ 的逆序块后，序列前段还有数字，此时不可能满足条件，$\text{LIS}$ 必然大于 $x$，无解
* 另一种情况：若 $x + y \gt n + 1$，显然无解

```cpp
#include <iostream>
#include <algorithm>

const int maxN = 1e5;

int n, x, y;
int a[maxN + 10];

int main() {
    std::cin >> n >> x >> y;
    if (1ll * x * y < n || x + y > n + 1) {
        std::cout << "NO\n";
        return 0;
    }
    std::cout << "YES\n";
    for (int i = 1; i <= n; i++) a[i] = i;
    int t = n - x;
    int r = n;
    int l = n - y + 1;
    while (t) {
        l = std::max(l, r - t);
        std::reverse(a + l, a + r + 1);
        r -= y;
        l -= std::min(t, y);
        t -= std::min(t, y - 1);
    }
    for (int i = 1; i <= n; i++) std::cout << a[i] << ' ';
    return 0;
}
```

## 	#2. [[CSP.AC:228]](https://noip.ac/rs/show_problem/3021) - 链接

### Problem Description

​	小王来到了一片森林，森林中有一些树和连接两棵树的无向道路，**保证这些道路能把森林连通**。

​	小王对这片森林做了一些考察，有了两个奇怪的发现：

​	1）森林中的树总共分为两种，不妨记为$0$型树和$1$型树。
    
​	2）这些道路的长度都是$2$的整数次幂且互不相同，第$i$条道路的长度为$2^i$。

​	小王又发现了这片森林的一个神奇之处，任何两棵类型不同的树之间都可以构成一组链接，这一对链接的能量值为两棵树之间的最短路。

​	好奇的小王想知道这片森林所有链接的能量值之和，请你来帮帮他。

### Input

​	输入第一行包含两个整数$n,m$，表示森林中树的数量和无向道路的数量。

​	接下来一行包含$n$个整数$a_1,a_2,...,a_n(a_i=0\ or\ 1)$，表示每一棵树的类型。

​	接下来$m$行，第$i$行表示第$i$条无向道路，包含两个整数$u_i,v_i(1\leq u_i,v_i \leq n)$表示第$i$条无向道路连接的树的编号，并且它的长度为$2^i$。

### Output

​	输出一个整数，所有链接能量值之和对$10^9+7$取模的结果

### Sample Input 1

```txt
3 2
0 1 0
3 1
1 2
```


### Sample Output 1

```txt
10
```

### Sample Input 2

```txt
10 11
0 1 0 1 0 1 0 1 0 1
1 2
1 3
1 4
2 5
2 6
3 7
4 8
5 9
9 10
5 6
2 7
```

### Sample Output 2

```txt
6050
```


### Hint

​对于$20\%$的数据，$n\leq 10$

​对于$40\%$的数据，$n\leq 20$

​对于$100\%$的数据，$n\leq 100000, 1\leq m\leq 200000$

### Solution

#### 20~40分解法

* $\text{Floyd}$
* 每个 $1$ 型点 $\text{SPFA}$

#### 100分解法

* 第 $i$ 条边的权值是 $2^i$，发现 $2^1 + 2^2 + \cdots, + 2^{(i - 1)} \lt 2^i$，所以如果两个点能通过加入前 $i - 1$ 条边连通，那最短路肯定不会经过第 $i$ 条边，于是从 $1$ 到 $n$ 按顺序建最小生成树。
* 对于 $0$ 点和 $1$ 点的最短路，我们只需枚举最小生成树上的每条边，这条边两侧的任意 $0 1$ 点组合的最短路都会通过这条边，所以统计该边两侧的 $0 1$ 点个数，计算贡献即可

```cpp
#include <iostream>
#include <vector>

typedef long long lxl;

const int maxN = 1e5;
const int maxM = 2e5;
const int mod = 1e9 + 7;

int n, m;
int a[maxN + 10];
int u[maxM + 10], v[maxM + 10];
int w = 1;
int tot[2];
lxl ans;

namespace tree {
    struct Vertex {
        int head;
        int size[2];
    } vertex[maxN + 10];

    struct Edge {
        int head;
        int next;
        int weight;
    } edge[maxN * 2 + 10];

    int ecnt;

    void addEdge(int tail, int head, int weight) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].weight = weight;
        edge[ecnt].next = vertex[tail].head;
        vertex[tail].head = ecnt;
        return;
    }

    void DFS(int u, int from) {
        vertex[u].size[a[u]]++;
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            int w = edge[e].weight;
            if (v == from) continue;
            DFS(v, u);
            vertex[u].size[0] += vertex[v].size[0];
            vertex[u].size[1] += vertex[v].size[1];
        }
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            int w = edge[e].weight;
            if (v == from) continue;
            ans = (ans + 1ll * vertex[v].size[0] * (tot[1] - vertex[v].size[1]) % mod * w) % mod;
            ans = (ans + 1ll * vertex[v].size[1] * (tot[0] - vertex[v].size[0]) % mod * w) % mod;
        }
        return;
    }
}

namespace graph {
    struct Vertex {
        int fa;
    } vertex[maxN + 10];

    struct Edge {
        int tail;
        int head;
        int weight;
    };

    std::vector<Edge> edge;

    void addEdge(int tail, int head, int weight) {
        edge.push_back((Edge) {tail, head, weight});
        return;
    }

    struct DisjointSetUnion {
        int Find(int u) {
            if (vertex[u].fa == u) return u;
            return vertex[u].fa = Find(vertex[u].fa);
        }

        void Union(int u, int v) {
            u = Find(u);
            v = Find(v);
            vertex[u].fa = v;
            return;
        }

        void Init() {
            for (int u = 1; u <= n; u++) vertex[u].fa = u;
            return;
        }
    } DSU;

    void Kruscal() {
        DSU.Init();
        for (int e = 0; e < edge.size(); e++) {
            int u = edge[e].tail;
            int v = edge[e].head;
            int w = edge[e].weight;
            int fu = DSU.Find(u);
            int fv = DSU.Find(v);
            if (fu == fv) continue;
            DSU.Union(u, v);
            tree::addEdge(u, v, w);
            tree::addEdge(v, u, w);
        }
        return;
    }
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i], tot[a[i]]++;
    for (int i = 1; i <= m; i++) std::cin >> u[i] >> v[i], w = w * 2 % mod, graph::addEdge(u[i], v[i], w);
    graph::Kruscal();
    tree::DFS(1, 0);
    std::cout << ans;
    return 0;
}
```