---
layout: post
title:  SXB5 第 5 周 动态规划1
date:   2023-01-07
author: dottle
categories: course luogu-class yugu22sx1b
---

## 基本模型

### 背包问题

#### 知识点

* $01$ 背包
* 完全背包
* 多重背包
* 分组背包
* 树上背包
* 方案数背包的撤回

#### 题目

##### [P4141 消失之物](https://www.luogu.com.cn/problem/P4141)

正打算问问多头“方案数背包的撤回”是什么的时候就在学习指导中看到这道题了。

与 $01$ 背包问题不同的是，有一件物品丢失了。

可以想到 $\mathcal O(n^2 m)$ 的暴力，即跑对于每一个丢失的物品 $i$ 跑一边 $01$ 背包，考虑到第 $i$ 件物品时跳过。（状态空间维度需要压缩并使用倒序枚举）

```cpp
#include <iostream>

const int maxN = 2000;
const int maxM = 2000;
const int mod = 10;

int n, m;
int w[maxN + 10];
int cnt[maxN + 10][maxM + 10];

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> w[i];
    for (int i = 1; i <= n; i++) {
        cnt[i][0] = 1;
        for (int j = 1; j <= n; j++) {
            if (j == i) continue;
            for (int k = m; k >= w[j]; k--) {
                cnt[i][k] = (cnt[i][k] + cnt[i][k - w[j]]) % mod;
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) std::cout << cnt[i][j];
        std::cout << '\n';
    }
    return 0;
}
```

居然过了。

考虑到每轮过程中考虑到的物品是从 $n$ 个物品中丢掉第 $i$ 个物品，想到从 $n$ 个物品的状态空间撤回到丢掉第 $i$ 个物品的状态空间。这就是背包方案数的撤回。

先对所有物品跑一边 $01$ 背包。

已知背包方案数的转移为 $f[j] = f[j] + f[j - w[i]]$；

那么背包方案数的撤回为 $f[j] = f[j] - f[j - w[i]]$。

```cpp
#include <iostream>

const int maxN = 2000;
const int maxM = 2000;
const int mod = 10;

int n, m;
int w[maxN + 10];
int f[maxM + 10];
int cnt[maxN + 10][maxM + 10];

int main() {
    f[0] = 1;
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> w[i];
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= w[i]; j--) {
            f[j] = (f[j] + f[j - w[i]]) % mod;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            cnt[i][j] = f[j];
        }
        for (int j = w[i]; j <= m; j++) {
            cnt[i][j] = (cnt[i][j] - cnt[i][j - w[i]] + mod) % mod;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) std::cout << cnt[i][j];
        std::cout << '\n';
    }
    return 0;
}
```

##### [P3188 [HNOI2007]梦幻岛宝珠](https://www.luogu.com.cn/problem/P3188)

一眼 $01$ 背包，但是 $\text{MLE / RE 10 pts}$。

因为 $1 \le W, w_i, v_i \le 2^{30}$。

从特殊条件上考虑。

保证每个 $w_i$ 能写成 $a \times 2^b (a, b, \in \N)$ 的形式，$a \le 10, b \le 30$，且答案不超过 $w^{30}$。

将 $w_i$ 进行二进制拆分，并以 $b$ 为组别进行分组 $01$ 背包。

记 $f_{b, j}$ 为第 $b$ 组内，以 $2^b$ 为容量单位一，容量为 $j$ 的状态空间。

考虑不同组之间关于 $W$ 的合并。发现 $b$ 相邻的组之间的 $w$ 是二倍关系。若在第 $b$ 组下使用了 $j$ 的容量，可看作在第 $b - 1$ 组使用了 $2 j$ 的容量。于是从高位组别向低位组别合并。

若记 $g_{b, j}$ 为从高往低第 $b$ 组使用了 $j$ 的容量，与直接做此题无异，$j$ 的范围过大。但是每组的容量不及 $W$ 那么大，在 $a n$ 以内，于是从反方面考虑。

记 $g_{b, j}$ 为从高往低第 $b$ 组剩余了 $j$ 的容量，第 $b - $ 组剩余容量为 $2 j + W_{i - 1} - k$，其中 $W_{i - 1}$ 表示 $W$ 在二进制下第 $i - 1$ 位的大小，$k$ 为第 $i - 1$ 组使用的容量。

注意 $0 \le k \le \min (a n, 2 j + W_{i - 1} - k)$ 以及 $g$ 初始化为负无穷，因为 $f_{i - 1, k}$ 可能使无法被取到的 $g_{i, j}$ 转移到下一组。

时间复杂度为 $\mathcal O(n^2 \log W)$。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

typedef long long lxl;

const int maxN = 100;
const int maxA = 10;
const int maxB = 30;

int n, W;
int w[maxN + 10];
int v[maxN + 10];
int m[maxB + 10];
int w2[maxB + 5][maxN + 10];
int v2[maxB + 5][maxN + 10];
lxl f[maxB + 10][maxN * 10 + 10];
lxl g[maxB + 10][maxN * 10 + 10];

void init() {
    std::memset(m, 0, sizeof(m));
    std::memset(w2, 0, sizeof(w2));
    std::memset(v2, 0, sizeof(v2));
    std::memset(f, 0, sizeof(f));
    std::memset(g, 0xcf, sizeof(g));
    return;
}

void split() {
    for (int i = 1; i <= n; i++) {
        int b = 0;
        while (!(w[i] & 1)) {
            w[i] >>= 1;
            b++;
        }
        m[b]++;
        w2[b][m[b]] = w[i];
        v2[b][m[b]] = v[i];
    }
    return;
}

void merge() {
    g[maxB][0] = 0;
    for (int b = maxB; b >= 1; b--) {
        g[b - 1][0] = 0;
        g[b - 1][W >> (b - 1) & 1] = 0;
        for (int j = 0; j <= maxA * n; j++) {
            for (int k = 0; k <= std::min(maxA * n, 2 * j + (W >> (b - 1) & 1)); k++) {
                int l = std::min(maxA * n, 2 * j + (W >> (b - 1) & 1) - k);
                g[b - 1][l] = std::max(g[b - 1][l], g[b][j] + f[b - 1][k]);
            }
        }
    }
    for (int j = 1; j <= maxA * n; j++) g[0][0] = std::max(g[0][0], g[0][j]);
    return;
}

void mian() {
    init();
    for (int i = 1; i <= n; i++) std::cin >> w[i] >> v[i];
    split();
    for (int b = 0; b <= maxB; b++) {
        for (int i = 1; i <= m[b]; i++) {
            for (int j = maxA * n; j >= w2[b][i]; j--) {
                f[b][j] = std::max(f[b][j], f[b][j - w2[b][i]] + v2[b][i]);
            }
        }
    }
    merge();
    std::cout << g[0][0] << '\n';
    return;
}

int main() {
    while (std::cin >> n >> W && ~n && ~W) mian();
    return 0;
}
```

