---
layout: post
title:  SXB1 第 1 周 基础优化技巧1
date:   2022-12-10
author: 宣毅鸣
categories: course luogu-class yugu22sx1b
---

# 基础算法

## 三分法

三分法是用来求单峰函数的极值点。

假设当前区间是 $[l, r]$。记区间的两个三等分点是 $lmid, rmid$。

比较 $lmid$ 和 $rmid$ 的值。舍弃更小的一部分。

## P3382 【模板】三分法

我们找 $[l, r]$ 的三等分点 $lmid, rmid$。比较 $f(lmid)$ 和 $f(rmid)$ 的
值。如果 $f(lmid) \le f(rmid)$ 那么答案在 $[lmid, r]$。否则在 $[rmid, l]$。

```cpp
    while (r - l >= eps) {
		double gap = (r - l) / 3.0;
		double lMid = l + gap;
		double rMid = r - gap;
		if (f(lMid) < f(rMid)) l = lMid;
		else r = rMid;
	}
```

## 整体二分

整体二分是把多个查询一起解决，所以这是一个离线算法。

## P3527 [POI2011]MET-Meteors

把所有的国家放在一起二分，这样二分一共有 $\mathcal O(\log n)$ 层，每层只需要 $\mathcal O(n)$ 扫描所有的操作即可。

```cpp
struct Node {
    int id;
    lxl p;
};
```

```cpp
void solve(int L, int R, std::vector<Node> q) {
    int mid = (L + R) >> 1;
    std::vector<Node> q1;
    std::vector<Node> q2;
    for (int i = L; i <= mid; i++) {
        BIT.Add(l[i], a[i]);
        BIT.Add(r[i] + 1, - a[i]);
        if (l[i] > r[i]) BIT.Add(1, a[i]);
    }
    for (int i = 0; i < q.size(); i++) {
        lxl c = 0;
        for (int j = 0; j < v[q[i].id].size(); j++) {
            c += BIT.Ask(v[q[i].id][j]);
            if (c >= q[i].p) break;
        }
        if (c >= q[i].p) q1.push_back(q[i]);
        else q[i].p -= c, q2.push_back(q[i]);
    }
    for (int i = L; i <= mid; i++) {
        BIT.Add(l[i], - a[i]);
        BIT.Add(r[i] + 1, a[i]);
        if (l[i] > r[i]) BIT.Add(1, -a[i]);
    }
    if (L == R) {
        for (int i = 0; i < q1.size(); i++) res[q1[i].id] = L;
        for (int i = 0; i < q2.size(); i++) res[q2[i].id] = -1;
        return;
    }
    solve(L, mid, q1);
    solve(mid + 1, R, q2);
    return;
}
```

```cpp
    for (int i = 1; i <= m; i++) v[o[i]].push_back(i);
    for (int i = 1; i <= n; i++) q.push_back((Node) {i, p[i]});
    solve(1, k, q);
    for (int i = 1; i <= n; i++) if (res[i] > 0) printf("%d\n", res[i]); else printf("NIE\n");
```

## 分治

分治的思想是把原先的大问题分成几个小部分。

当问题规模很小时一般很好处理。

处理完子问题后，通过某些办法合并问题。

CDQ 分治则是在这个基础上，考虑子问题之间的贡献。

## P3810 【模板】三维偏序（陌上花开）

第一维排序，第二维 $CDQ$ 分治，第三维树状数组即可。

```cpp
struct Element {
	int a, b, c;
	int cnt;
	int res;

	bool operator!=(Element other) {
		if (a != other.a) return true;
		if (b != other.b) return true;
		if (c != other.c) return true;
		return false;
	}
};
```

```cpp
void CDQ(int l, int r) {
	if (l == r) return;
	int mid = (l + r) / 2;
	CDQ(l, mid);
	CDQ(mid + 1, r);
	std::sort(ue + l, ue + mid + 1, cmpB);
	std::sort(ue + mid + 1, ue + r + 1, cmpB);
	int i = l;
	int j = mid + 1;
	while (j <= r) {
		while (i <= mid && ue[i].b <= ue[j].b) {
			BIT.Add(ue[i].c, ue[i].cnt);
			i++;
		}
		ue[j].res += BIT.Ask(ue[j].c);
		j++;
	}
	for (int k = l; k < i; k++) BIT.Add(ue[k].c, -ue[k].cnt);
	return;
}
```

```cpp
	std::sort(e + 1, e + n + 1, cmpA);
	for (int i = 1; i <= n; i++) {
		cnt++;
		if (e[i].a != e[i + 1].a || e[i].b != e[i + 1].b || e[i].c != e[i + 1].c) {
			m++;
			ue[m].a = e[i].a;
			ue[m].b = e[i].b;
			ue[m].c = e[i].c;
			ue[m].cnt = cnt;
			cnt = 0;
		}
	}
	CDQ(1, m);
	for (int i = 1; i <= m; i++) res[ue[i].res + ue[i].cnt - 1] += ue[i].cnt;
```