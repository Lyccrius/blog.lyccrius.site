---
layout: post
title:  SXB1 第 1 周 基础优化技巧1
date:   2022-12-10
author: 宣毅鸣
categories: course luogu-class yugu22sx1b
---

# 基础算法

## 三分法

三分法是用来求单峰函数的极值点。

假设当前区间是 $[l, r]$。记区间的两个三等分点是 $lmid, rmid$。

比较 $lmid$ 和 $rmid$ 的值。舍弃更小的一部分。

### P3382 【模板】三分法

我们找 $[l, r]$ 的三等分点 $lmid, rmid$。比较 $f(lmid)$ 和 $f(rmid)$ 的
值。如果 $f(lmid) \le f(rmid)$ 那么答案在 $[lmid, r]$。否则在 $[rmid, l]$。

```cpp
    while (r - l >= eps) {
		double gap = (r - l) / 3.0;
		double lMid = l + gap;
		double rMid = r - gap;
		if (f(lMid) < f(rMid)) l = lMid;
		else r = rMid;
	}
```

## 整体二分

整体二分是把多个查询一起解决，所以这是一个离线算法。

### P3527 [POI2011]MET-Meteors

把所有的国家放在一起二分，这样二分一共有 $\mathcal O(\log n)$ 层，每层只需要 $\mathcal O(n)$ 扫描所有的操作即可。

```cpp
struct Node {
    int id;
    lxl p;
};
```

```cpp
void solve(int L, int R, std::vector<Node> q) {
    int mid = (L + R) >> 1;
    std::vector<Node> q1;
    std::vector<Node> q2;
    for (int i = L; i <= mid; i++) {
        BIT.Add(l[i], a[i]);
        BIT.Add(r[i] + 1, - a[i]);
        if (l[i] > r[i]) BIT.Add(1, a[i]);
    }
    for (int i = 0; i < q.size(); i++) {
        lxl c = 0;
        for (int j = 0; j < v[q[i].id].size(); j++) {
            c += BIT.Ask(v[q[i].id][j]);
            if (c >= q[i].p) break;
        }
        if (c >= q[i].p) q1.push_back(q[i]);
        else q[i].p -= c, q2.push_back(q[i]);
    }
    for (int i = L; i <= mid; i++) {
        BIT.Add(l[i], - a[i]);
        BIT.Add(r[i] + 1, a[i]);
        if (l[i] > r[i]) BIT.Add(1, -a[i]);
    }
    if (L == R) {
        for (int i = 0; i < q1.size(); i++) res[q1[i].id] = L;
        for (int i = 0; i < q2.size(); i++) res[q2[i].id] = -1;
        return;
    }
    solve(L, mid, q1);
    solve(mid + 1, R, q2);
    return;
}
```

```cpp
    for (int i = 1; i <= m; i++) v[o[i]].push_back(i);
    for (int i = 1; i <= n; i++) q.push_back((Node) {i, p[i]});
    solve(1, k, q);
    for (int i = 1; i <= n; i++) if (res[i] > 0) printf("%d\n", res[i]); else printf("NIE\n");
```

## 分治

分治的思想是把原先的大问题分成几个小部分。

当问题规模很小时一般很好处理。

处理完子问题后，通过某些办法合并问题。

CDQ 分治则是在这个基础上，考虑子问题之间的贡献。

### P1177 【模板】快速排序

归并排序。

### P3810 【模板】三维偏序（陌上花开）

第一维排序，第二维 $CDQ$ 分治，第三维树状数组即可。

```cpp
struct Element {
	int a, b, c;
	int cnt;
	int res;

	bool operator!=(Element other) {
		if (a != other.a) return true;
		if (b != other.b) return true;
		if (c != other.c) return true;
		return false;
	}
};
```

```cpp
void CDQ(int l, int r) {
	if (l == r) return;
	int mid = (l + r) / 2;
	CDQ(l, mid);
	CDQ(mid + 1, r);
	std::sort(ue + l, ue + mid + 1, cmpB);
	std::sort(ue + mid + 1, ue + r + 1, cmpB);
	int i = l;
	int j = mid + 1;
	while (j <= r) {
		while (i <= mid && ue[i].b <= ue[j].b) {
			BIT.Add(ue[i].c, ue[i].cnt);
			i++;
		}
		ue[j].res += BIT.Ask(ue[j].c);
		j++;
	}
	for (int k = l; k < i; k++) BIT.Add(ue[k].c, -ue[k].cnt);
	return;
}
```

```cpp
	std::sort(e + 1, e + n + 1, cmpA);
	for (int i = 1; i <= n; i++) {
		cnt++;
		if (e[i].a != e[i + 1].a || e[i].b != e[i + 1].b || e[i].c != e[i + 1].c) {
			m++;
			ue[m].a = e[i].a;
			ue[m].b = e[i].b;
			ue[m].c = e[i].c;
			ue[m].cnt = cnt;
			cnt = 0;
		}
	}
	CDQ(1, m);
	for (int i = 1; i <= m; i++) res[ue[i].res + ue[i].cnt - 1] += ue[i].cnt;
```

### AT_joisc2017_j 誘拐 2 (Abduction 2)

每次找到最大的一条车流指数，可以把矩阵分成两部分。然后维护边界上的答案函数。

注意到每个询问最多递归 $\mathcal O(H + W)$ 层，所以总分治次数是 $\mathcal O((H + W)Q)$ 的。

*	STL+搜索：https://www.luogu.com.cn/record/78649912
*	线段树+搜索：https://www.luogu.com.cn/record/72026452
*	倍增表+搜索：https://www.luogu.com.cn/record/97137334
*	倍增表+分治：https://www.luogu.com.cn/record/101187763

## 倍增法

倍增法，意思就是每次翻倍。

常见的应用有 ST 表和 LCA。

ST 表常用于处理区间最大最小值问题和一些类似的问题。

预处理 $f_{i, j}$ 表示从 $i$ 开始长度为 $2^j$ 的区间的最大 $/$ 最小值。

$f_{i, j}$ 可以通过 $f_{i, j − 1} f_{i + 2^{j − 1}, j − 1}$ 合并得出。

询问区间 $[l, r]$ 的值的时候，找到最大的 $k$ 使得 $2^k \le r − l + 1$。用 $f_{l, k}$ 和 $f_{r − 2^k + 1, k}$ 合并。

缺点是会有一段区间重复算。时间复杂度 $\mathcal O(n \log n) − \mathcal O(1)$。

### ZCMU5141 环倍晋三

设 $f_{i, j}$ 表示从 $j$ 开始跳 $2^i$ 后的节点，$g_{i, j}$ 表示从 $j$ 开始跳 $2^i$ 步的中间跳过的点的和。

每次用 $i \rightarrow i + 1$。询问的时候把 $m$ 二进制分解一下即可。

# 字符串初阶

STL 中的 map 虽然功能强大，但是跑的比较慢。可以通过手写哈希表来加速这一过程。

哈希函数每次是给出一个整数，对应存放到某一个位置。

可以初始函数直接用 $x \bmod p$，其中 $p$ 是一个质数。

如果当前位置已经被别的整数占用，那么找下一个位置。直到找到相同的数或者空位置为止。

此时就是 $x$ 对应的储存位置。

当 $p$ 取到 $2n$ 左右时，如果给出的数字随机，每次期望时间复杂度 $\mathcal O(1)$。

## Hash

Hash 是把字符串 $S$ 映射到整数的一个函数。

由于这是一个函数，所以如果字符串相同，得到的整数也相同。

我们希望如果字符串不相同，得到的整数大概率也不相同。

可以把字符串看成一个 $26$ 进制 (或者别的进制) 的大整数，把他对于某一个质数 $P$ 取模后的结果作为函数值。

那么两个随机的不同的字符串得到的函数值相同的概率大概就是 $\frac{1}{P}$。

需要注意，如果有多个字符串进行两两比较，那么比较的次数可能达到 $\mathcal O(n^2)$。此时需要调整更大的整数 $P$，或者取两个不同的质数 $P_1, P_2$ 做双 Hash。

不建议用自然溢出做 Hash。

注意到这个算法计算一个字符串的 Hash 值的复杂度是 $\mathcal O(n)$ 的。

如果要多次询问一个字符串的子串的 Hash 值，并没有很好的提升。

可以预处理 $f_i$ 表示前 $i$ 个字符组成的字符串的 Hash 值。

那么 $S[l, r]$ 的 Hash 值就等于 $f_r − f_{l − 1} \times base^{r − l + 1}$ 对 $P$ 取模的值。

预处理 $base$ 的幂次后就可以 $\mathcal O(n)$ 预处理 $\mathcal O(1)$ 查询了。

### 例

>	给出一个大串 $S$ 和小串 $s$。求大串 $S$ 有多少个子串和 $s$ 失配位置不超过 $k$。  
>	
>	$\lvert S \rvert, \lvert s \rvert, k \le 5$。

枚举子串的起点，每次二分下一个不同的位置。

时间复杂度 $\mathcal O(n k \log m)$。

## 字典树

字典树是用一棵树来储存多个字符串的结构。

每一条边代表一个字符，从根节点到某个节点经过的路径代表一个字符串。

用 $next_{i, j}$ 表示 $i$ 节点后接入 $j$ 这个字符指向哪个节点。

有些时候需要知道哪些节点是结尾节点，可以在那些节点的位置打上标记。

### 例

>	给出一些字符串，总长度不超过 $10^7$。求是否存在一个串是另一个串的前缀。

直接把所有串插入 Trie 树即可。

### LOJ2742 「JOI Open 2016」销售基因链

>	有 $n$ 个由 $A, G, U, C$ 组成的字符串，给出 $m$ 个询问，每次给出 $P, Q$。
>	
>	求包含前缀 $P$ 且包含后缀 $Q$ 的字符串有多少个。
>	
>	$n, m \le 10^5, \sum \lvert S_i \rvert, \sum \lvert P_i \rvert, \sum \lvert Q_i \rvert \le 2 \times 10^6$。

对前缀和后缀都建立字典树，包含前缀相当于一个子树。

也就是求两个树的子树并。DFS 转换后二维数点即可。

## 01Trie

将二进制看成一个 $01$ 字符串，可以把数值插入到 Trie 树中。一般叫做 01Trie。

可以用来处理一些数值位运算最值问题。

### P4551 最长异或路径

点 $x$ 到点 $y$ 的路径 $\oplus$ 可以看成 $x$ 到根的路径权值 $\oplus$ 和 $y$ 到根路径权值 $\oplus$ 再 $\oplus$ 起来。

把所有点点权依次插入 Trie 树，每次插入前贪心求出最大值即可。

### LOJ6469 Magic

>	给出 $n$ 个数，定义 $f(i)$ 表示 $i$ 的十进制位数。求 $\sum_{1 \le i \lt j \le n} f(a_i \oplus a_j)$。
>	
>	$a_i \le 10^{18}, n \le 5 \times 10^4$。

可以看成求 $a_i \oplus a_j \ge 1, 10, 100 \cdots$

用 01Trie 即可。

## KMP

KMP 的核心是要求 $next_i$，表示 $S[1 \cdots i]$ 最长的前后缀相同的串长度（不能是整个串）。

容易观察到，当 $i + 1$ 时，$next_i$ 最多 $+ 1$。

并且如果 $next_i + 1$ 不符合条件，就要往前找 $next_i$。

在匹配别的字符串的时候，先求出短的子串的 $next$ 数组，接下来如果不能匹配就往前跳 $next$。

### CF808G Anthem of Berland

设 $f_{i, j}$ 表示 $S$ 的前 $i$ 位，当前匹配到了 $T$ 的第 $j$ 位，之前匹配的最大次数。

考虑当前能否匹配，如果不能就跳 $next$。