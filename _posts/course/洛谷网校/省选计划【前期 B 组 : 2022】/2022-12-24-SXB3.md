---
layout: post
title:  SXB3 第 3 周 数据结构1
date:   2022-12-24
author: noip
categories: course luogu-class yugu22sx1b
---

# 简单数据结构

## 线段树

## 平衡树

*   全称“平衡二叉搜索树”，常见的类型有：
    1.  Splay
    2.  Treap
    3.  AVL Tree
    4.  Red Black Tree
    5.  Scape Goat Tree
    6.  Weight Balanced Leafy Tree（特殊结构）

### 二叉搜索树

*   性质：一个节点x左子树所有点的关键字都比x的关键字小，右子树所有点的关键字都比x的关键字大。

*   限于篇幅，这里只讲一下 Treap 和 Splay。

### Treap

*   “树堆”
*   “Tree + Heap”
*   性质：每个点随机分配一个权值，使treap同时满足堆性质和二叉搜索树性质。
*   复杂度：期望 $\mathcal O(\log n)$。
*   设每个节点的关键字是 $key$，随机权值是 $rand$。
    1.  如果 $v$ 是 $u$ 的左儿子，则 $key[v] \lt key[u]$；
    2.  如果 $v$ 是 $u$ 的右儿子，则 $key[v] \gt key[u]$；
    3.  如果 $v$ 是 $u$ 的子节点，则 $rand[u] \gt rand[v]$。
*   Treap 维护权值的时候一般会把相同的权值放在同一个节点上。
*   所以一个 Treap 节点需要维护以下信息：
    *   左右儿子
    *   关键字
    *   关键字出现次数
    *   堆随机值
    *   节点大小（即子树大小）

```cpp
struct Node {
    int lson;
    int rson;
    int val;
    int cnt;
    int size;
    int rand;
};
```

```cpp
void PushUp(int u) {
    node[u].size = node[node[u].lson].size + node[node[u].rson].size + node[u].cnt;
    return;
}
```

#### 旋转

*   平衡二叉搜索树主要通过旋转来保持树的平衡，即保证复杂度。
*   旋转有单旋和双旋，Treap只需要单旋，这一点比较简单。

```cpp
void RotateL(int &u) {
    int t = node[u].rson;
    node[u].rson = node[t].lson;
    node[t].lson = u;
    node[t].size = node[u].size;
    PushUp(u);
    u = t;
    return;
}
```

```cpp
void RotateR(int &u) {
    int t = node[u].lson;
    node[u].lson = node[t].rson;
    node[t].rson = u;
    node[t].size = node[u].size;
    PushUp(u);
    u = t;
    return;
}
```

#### 插入

*   先给这个节点分配一个随机的堆权值。
*   然后把这个节点按照 BST 的规则插入到一个叶子上。
*   从根节点开始，逐个判断当前节点的值与插入值的大小关系。
    *   如果插入值小于当前节点值，则递归至左儿子；
    *   如果插入值大于当前节点值，则递归至右儿子。
*   然后通过旋转来调整，使得 Treap 满足堆性质。

```cpp
void Insert(int &u, int x) {
    if (!u) {
        u = ++ncnt;
        node[u].val = x;
        node[u].cnt = 1;
        node[u].size = 1;
        node[u].rand = rand();
        return;
    }
    node[u].size++;
    if (node[u].val == x) {
        node[u].cnt++;
    } else if (node[u].val > x) {
        
    }
}