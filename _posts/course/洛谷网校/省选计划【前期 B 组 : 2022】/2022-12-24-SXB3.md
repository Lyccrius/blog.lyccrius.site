---
layout: post
title:  SXB3 第 3 周 数据结构1
date:   2022-12-24
author: noip
categories: course luogu-class yugu22sx1b
---

#   简单数据结构

##  线段树

##  平衡树

*   全称“平衡二叉搜索树”，常见的类型有：
    1.  Splay
    2.  Treap
    3.  AVL Tree
    4.  Red Black Tree
    5.  Scape Goat Tree
    6.  Weight Balanced Leafy Tree（特殊结构）

##  二叉搜索树

*   性质：一个节点 $u$ 左子树所有点的关键字都比 $u$ 的关键字小，右子树所有点的关键字都比 $u$ 的关键字大。

*   限于篇幅，这里只讲一下 Treap 和 Splay。

##  Treap

*   “树堆”
*   “Tree + Heap”
*   性质：每个点随机分配一个权值，使treap同时满足堆性质和二叉搜索树性质。
*   复杂度：期望 $\mathcal O(\log n)$。
*   设每个节点的关键字是 $key$，随机权值是 $rand$。
    1.  如果 $v$ 是 $u$ 的左儿子，则 $key[v] \lt key[u]$；
    2.  如果 $v$ 是 $u$ 的右儿子，则 $key[v] \gt key[u]$；
    3.  如果 $v$ 是 $u$ 的子节点，则 $rand[u] \gt rand[v]$。
*   Treap 维护权值的时候一般会把相同的权值放在同一个节点上。
*   所以一个 Treap 节点需要维护以下信息：
    *   左右儿子
    *   关键字
    *   关键字出现次数
    *   堆随机值
    *   节点大小（即子树大小）

```cpp
struct Node {
    int lson;
    int rson;
    int val;
    int cnt;
    int size;
    int rand;
};
```

```cpp
void PushUp(int u) {
    node[u].size = node[node[u].lson].size + node[node[u].rson].size + node[u].cnt;
    return;
}
```

### 旋转

*   平衡二叉搜索树主要通过旋转来保持树的平衡，即保证复杂度。
*   旋转有单旋和双旋，Treap只需要单旋，这一点比较简单。

```cpp
void RotateL(int &u) {
    int t = node[u].rson;
    node[u].rson = node[t].lson;
    node[t].lson = u;
    node[t].size = node[u].size;
    PushUp(u);
    u = t;
    return;
}
```

```cpp
void RotateR(int &u) {
    int t = node[u].lson;
    node[u].lson = node[t].rson;
    node[t].rson = u;
    node[t].size = node[u].size;
    PushUp(u);
    u = t;
    return;
}
```

### 插入

*   先给这个节点分配一个随机的堆权值。
*   然后把这个节点按照 BST 的规则插入到一个叶子上。
*   从根节点开始，逐个判断当前节点的值与插入值的大小关系。
    *   如果当前节点值大于插入值，则递归至左儿子；
    *   如果当前节点值小于插入值，则递归至右儿子。
*   然后通过旋转来调整，使得 Treap 满足堆性质。

```cpp
void Insert(int &u, int val) {
    if (u == 0) {
        u = ++ncnt;
        node[u].val = val;
        node[u].cnt = 1;
        node[u].size = 1;
        node[u].rand = rand();
        return;
    }
    node[u].size++;
    if (node[u].val == val) {
        node[u].cnt++;
    } else if (node[u].val > val) {
        Insert(node[u].lson, val);
        if (node[node[u].lson].rand < node[u].rand) RotateR(u);
    } else if (node[u].val < val) {
        Insert(node[u].rson, val);
        if (node[node[u].rson].rand < node[u].rand) RotateL(u);
    }
    return;
}
```

### 删除

*   和普通的 BST 删除一样：
    *   如果当前节点值大于删除值，则递归至左儿子；
    *   如果当前节点值小于删除值，则递归至右儿子；
    *   若当前节点数值的出现次数大于 $1$，则减一（通常将同一个权值缩掉）；
    *   若当前节点数值的出现次数等于 $1$： 
        *   若当前节点没有左儿子与右儿子，则直接删除该节点（置 $0$）； 
        *   若当前节点没有左儿子或右儿子，则将左儿子或右儿子替代该节点； 
        *   若当前节点有左儿子与右儿子，则不断旋转当前节点，并走到当前节点新的对应位置，直到没有左儿子或右儿子为止。 

```cpp
void Delete(int &u, int val) {
    if (u == 0) return;
    if (node[u].val == val) {
        if (node[u].cnt > 1) {
            node[u].cnt--;
            node[u].size--;
        } else {
            if (node[u].lson == 0 || node[u].rson == 0) {
                u = node[u].lson + node[u].rson;
            } else if (node[node[u].lson].rand < node[node[u].rson].rand) {
                RotateR(u);
                Delete(u, val);
            } else {
                RotateL(u);
                Delete(u, val);
            }
        }
    } else if (node[u].val > val) {
        node[u].size--;
        Delete(node[u].lson, val);
    } else if (node[u].val < val) {
        node[u].size--;
        Delete(node[u].rson, val);
    }
    return;
}
```

### 查询

*   递归到叶子节点，一路维护信息即可。

```cpp
int QueryRnk(int u, int val) {
    if (u == 0) return 1;
    if (node[u].val == val) {
        return node[node[u].lson].size + 1;
    } else if (node[u].val > val) {
        return QueryRnk(node[u].lson, val);
    } else if (node[u].val < val) {
        return QueryRnk(node[u].rson, val) + node[node[u].lson].size + node[u].cnt;
    }
}
```

```cpp
int QueryKth(int u, int k) {
    if (u == 0) return 0;
    if (k <= node[node[u].lson].size) {
        return QueryKth(node[u].lson, k);
    } else if (k > node[node[u].lson].size + node[u].cnt) {
        return QueryKth(node[u].rson, k - node[node[u].lson].size - node[u].cnt);
    } else {
        return node[u].val;
    }
}
```

### 维护权值

### 分裂合并

*   用于维护序列，支持将 Treap 按前 $k$ 个位置分裂为两棵树。
*   分裂的时候维护两棵树，分别代表左边和右边的部分。

### 复杂度

*   因为保证了堆性质，所以复杂度期望下是正确的。
*   Treap 只需要保证堆性质复杂度就期望正确。

##  Splay

*   “伸展树”
*   “自适应查找树”
*   每次对一个节点进行操作的时候通过一种方法把这个点旋转至根。

### 分裂

*   用于维护序列，支持将 Splay 按前 $k$ 个位置分裂为两棵树。
*   直接把第 $k$ 个位置 Splay 到根，然后断开根的右儿子。

### 合并

*   将右边部分的第一个位置 Splay 到根，然后让其左儿子为左边部分。

### 复杂度

*   可以证明复杂度为均摊 $\mathcal O(m \log n)$。
*   可能存在一次操作复杂度特别高。
*   具体复杂度证明在 OI 里完全没用，想了解的同学可以课后了解。
*   Splay 具有“自适应性”。
*   大概就是说 Splay 会根据操作的特点调整树结构，使得操作尽可能高效。
*   可以去了解了解 Splay 的动态最优性猜想，是个著名的 Open Problem。

### Disadvantage

*   可以通过势能分析证明 Splay 的复杂度是均摊 $\mathcal O(\log n)$ 的，也就是说 Splay 在很多次操作中可能会有一次 $\mathcal O(n)$ 复杂度的操作。
*   而且这样的操作也很好构造。
*   所以 Splay 不适合做一些需要撤销操作/可持久化的题目（虽然可以通过随机旋转什么的方法来规避，但还是感觉很吃力）。
*   自身常数比较大。

### Advantage

*   Splay 用来维护序列还是比较好写的，用来维护名次树感觉不好写。
*   由于自适应性，Splay 不需要特殊的技巧就可以高效启发式合并，还可以高效实现 LCT（STT）等动态树。

##  WBLT

*   全称：Weight Balanced Leafy Tree
*   这个 Weight Balanced 是指的 Balanced by Boundary，也就是 BB[$\alpha$]。
*   和 clj 那个定义不一样。
*   大概可以理解为通过旋转而不是重构来满足替罪羊树那个平衡关系。
*   也就是说替罪羊树是 Weight Balanced Tree 的一种。
*   线段树就是一种 Leafy Tree，也就是说把信息都存在叶子上，非叶节点都是存储了信息的合并的虚点（大家可以感性理解一下大概是什么样的一个结构）。
*   优点：目前最好写的平衡树，可持久化效率很高。
*   缺点：非可持久化的情况下要两倍空间，拿来写 LCT（STT）很吃力。

##  替罪羊树

*   定义常数平衡因子 $\alpha$。
*   如果一个点的某个儿子，占到了子树大小的 $\alpha$，则认为不平衡，重构这个子树。
*   复杂度也是带均摊的，均摊 $\mathcal O(\log n)$，最坏单次操作 $\mathcal O(n)$。
*   复杂度证明平凡。

##  大概拿来解决什么样的题

*   给你一个序列，每次查询区间的分治信息，可能有单点修改或者区间修改。
*   给你一棵树，每次查询路径的分治信息，可能有单点修改或者路径修改。

##  Notice

*   这里维护的信息是可快速合并的信息，具体怎么定义快速合并比较复杂，这里不进行严谨介绍，只感性理解。
*   建议考虑线段树合并区间答案的时候，考虑如果答案都在左区间，都在右区间的情况，然后剩下的情况就是这次合并需要额外维护的。
*   有可能考虑合并需要额外维护的信息时需要额外在线段树节点上维护新的信息。

##  P2023 [AHOI2009] 维护序列

1.  区间加；
2.  区间乘；
3.  区间和；
*   取膜。

##  Problem

*   如果只是区间加或者区间乘，直接打个标记就可以了。
*   但是同时有两个操作怎么办？

### Solution

*   当然是打两个标记啦，不过需要注意一下处理顺序。
*   维护两个标记，分别是加标记和乘标记。
*   分别设为 $add$ 和 $mul$。
*   如果一个节点被加上了 $x$，则 $add += x$。
*   如果一个节点被乘上了 $x$，则 $add *= x, mul *= x$。
*   注意取膜。
*   即对于标记按顺序维护。
*   先加后乘。

##  常见的打标记的操作

*   区间加
*   区间乘
*   区间染色（区间修改为一个数）
*   区间翻转
*   区间 $\text{xor}$

##  P4513 小白逛公园

*   序列，单点修改，询问区间最大子段和。

### Solution

*   著名的新手杀手题。。。
*   很经典来着。
*   对于每个区间，维护一个左边的最大前缀，右边的最大后缀，以及区间内部的答案。
*   每次合并的时候，即答案选取左子区间的 $\max$，右子区间的 $\max$，或者左子区间的最大后缀，右子区间的最大前缀即可。
*   很简单的题。

##  P2042 [NOI2005] 维护数列

### Solution

*   本题我们还是考虑用平衡树维护序列。
*   首先先分析需要多少种标记：
*   因为有区间修改和区间翻转操作，所以需要两种标记，分别是修改和翻转标记。
*   插入和删除的部分很简单，是维护序列的平衡树的基本操作。
*   然后我们需要维护的信息是：和，最大子段和。
*   最大子段和就用之前小白逛公园的经典方法即可，注意翻转操作时需要交换当前节点的最大前缀和后缀，因为发生了翻转。
*   总时间复杂度 $\mathcal O(n + m \log n)$。

##  P5482 [JLOI2011]不等式组

*   你需要维护一堆不等式：
    1.  插入一个 $ax + b \gt c$ 的不等式；
    2.  删除第 $i$ 个插入的；
    3.  查询 $x = k$ 的时候成立的不等式个数。

### Solution

*   如果 $a \gt 0$：$ax + b \gt c \Leftrightarrow x \gt (c – b) / a$；
*   如果 $a \lt 0$：$ax + b \gt c \Leftrightarrow x \lt (c – b) / a$；
*   如果 $a = 0$：是否成立是确定性的。
*   开个平衡树维护值（按值域开个树状数组也行）。
*   然后每次插入取个整。
*   查询直接查 $rank$ 即可。
*   注意细节。

##  P1471 方差

### Solution

*   可以通过维护区间和来维护区间平均数。
*   其实就是区间和 $/$ 区间长度。
*   但是方差呢？
*   这里直接粘一个题解里面的公式了。
*   方差可以通过维护平方和和和的平方来算出来。
*   很多这种题直接推推式子就可以维护了。

$$s^2 = \frac{a_1^2 + a_2^2 + a_3^2 + \cdots + a_n^2}{n}- \overline a^2$$

##  Problem

>   给一个长为 $N$ 的数列，有 $M$操作，每次操作是以下三种之一：
>   1.  修改数列中的一个数；
>   2.  求数列中某连续一段所有数的两两乘积的和 $\bmod 1000000007$；
>   3.  求数列中某连续一段所有相邻两数乘积的和 $\bmod 1000000007$。

### Solution

*   假设 $x$ 节点的儿子为 $y$ 和 $z$。
*   $x$ 相邻两数乘积的和为：
    *   $y$ 相邻两数乘积的和 $+$ $z$ 相邻两数乘积的和 $+$ $y$ 最右边的数 $*$ $z$ 最左边的数；
*   $x$ 任意两数乘积的和为：
    *   $y$ 任意两数乘积的和 $+$ $z$ 任意两数乘积的和 $+$ $y$ 的和 $*$ $z$ 的和；
*   然后直接维护即可。

##  P4198 楼房重建

*   给一个序列 $a$，每次修改一个位置的值，查询有多少个位置 $i$ 满足 $[1, i - 1]$ 里的所有 $j$，都有 $a[j] \lt a[i]$。

### Solution1

*   发现一个楼房能被看到可以等价于它的斜率比之前的任何一个都大。
*   所以说我们这里可以直接维护斜率，而不用管楼的高度。
*   问题转化为：
    1.  单点修改；
    2.  查询全局有多少位置是前缀最大值。
*   可以试试分块维护。
*   复杂度好像是 $\mathcal O(n \sqrt{(n \log n)})$ 的。
*   这里不仔细讲了。

### Solution2

*   考虑用线段树维护。
*   对于线段树每个结点维护两个值：$ans$ 和 $max$，$ans$ 表示只考虑这个区间内的可以被看到的楼房，$max$ 表示这个区间的最大楼房斜率。
*   如何合并区间？
*   合并左右区间的时候：
*   显然左区间的答案不会变化。
*   问题就是考虑右区间有多少个楼房在左区间的约束条件下仍然可以被看到。
*   如果右区间最大值都小于等于左区间最大值，那么右区间就没有贡献了，相当于是被整个挡住了。
*   如果右区间最大值大于左区间最大值。
*   考虑右区间的两个子区间：左子区间、右子区间。
*   如果左子区间的最大值小于等于左区间最大值。
*   那么就递归处理右子区间。
*   因为相当于左子区间里面所有楼房都被前面的楼房挡住了了，递归查询右边有多少楼房没被挡住。
*   否则就递归处理左子区间，然后加上右子区间原本的答案，因为这个约束条件弱于左子区间对右子区间的约束，所以只考虑这个约束条件对左子区间的影响。
*   由于要合并 $\mathcal O(\log n)$ 次，每次合并会递归 $\mathcal O(\log n)$ 个节点。
*   所以总复杂度 $\mathcal O(m \log^2 n)$。
*   实际上常数非常小。

##  P4036 [JSOI2008]火星人

*   维护一个字符串序列：
    1.  单点插入；
    2.  单点修改；
    3.  查询两个区间的 $LCP$ 的长度。
*   $LCP$ 就是两个字符串的最长公共前缀。
*   $n, m \le 1.5e5$，询问次数 $\le 1e4$。

### Solution

*   如何判断两个字符串是否相等？
    *   哈希。
*   如何在带插入的情况下维护一个区间的哈希值？
    *   使用平衡树，预处理 $base$ 的每个次幂的值，这样可以合并两个区间的哈希值。
*   如何查询 $LCP$？
    *   可以使用二分答案的方法。
    *   二分一个区间长度，使用平衡树维护区间哈希的方法来查询这个长度的两个前缀是否相等。
*   时间复杂度 $\mathcal O(m \log^2 n)$，可以优化为 $\mathcal O(m \log^2 n / \log \log n)$。
*   其实题目中说了询问次数比较少，询问是 $\mathcal O(\log^2 n)$的，插入是 $O(\log n)$ 的。

##  Problem

*   有两个字符串序列 $A, B$。
*   每次修改 $B$ 序列的一个位置，或者询问 $A$ 序列有多少长 $\lvert B \rvert$ 的区间，满足这个区间与 $B$ 序列对应的字符串完全匹配。

##  P2757 [国家集训队]等差子序列

##  P6327 区间加区间sin和

*   考虑这个区间 $\sin$ 和如何维护。
*   大家都记得数学课学过一个东西叫做和差角公式吗？

$$
\begin{aligned}
    \sin(x + y) & = \sin x \cos y + \cos x \sin y \\
    \cos(x + y) & = \cos x \cos y − \sin x \sin y
\end{aligned}
$$
*   所以我们维护区间的 $\sin$ 和，$\cos$ 和，然后就可以打区间加标记了，这个标记可以合并，也可以下放.

##  P7706 「Wdsr-2.7」文文的摄影布置

*   直接线段树维护，考虑信息合并。
*   合并节点 $A$ 和 $B$ 的时候，如果三元组全部在 $A$ 内或者在 $B$ 内的话，那直接使用左儿子或者右儿子答案即可。
*   缺失的是什么？
*   左边有 $i$，右边有 $j, k$，或者左边有 $i, j$，右边有 $k$。
*   维护子树内的最大值以及子树内最大的 $a[i] - b[j] (i \lt j)$，最大的 $a[i] - b[j] (i \gt j)$ 即可直接合并。
*   总时间复杂度 $\mathcal O(n + m \log n)$。

##  P6864 [RC-03] 记忆

##  P5278 算术天才⑨与等差数列

*   P3792 由乃与大母神原型和偶像崇拜
*   给了你一个长度为 $n$ 的序列：
    1.  询问 $l, r, k$，问区间 $[l, r]$ 内的数从小到大排序后能否形成公差为 $k$ 的等差数列；
    2.  修改一个位置的值。
*   可以先思考一个简单版本：查询的 $k = 1$
*   $n \le 5e5$。

### Solution1

*   首先通过维护区间的 $\min$ 和 $\max$ 就可以知道这个区间是首项为多少，公差为 $k$ 的等差序列了。
*   直接维护这个信息比较复杂，所以考虑有什么其他的方法可以快速维护。
*   首先维护区间的排序后的顺序非常困难。
*   所以考虑维护区间的某些信息，使得这个区间被随机打乱之后维护出来的值是一样的。
*   首先可以想到区间和。
*   那我们同时维护平方和，乘积，立方和之类的不就好了吗。
*   一个给定首项和公差的等差序列的和，平方和是很好计算的。
*   通过维护这些信息就可以极高概率确定这个区间是不是满足条件的了。
*   那如果出题人构造数据卡你呢？
*   有个确定性的做法，但感觉还是 Hash 好玩。
*   其实这个题就是一个维护区间 Hash 的思想。

### Solution2

*   有没有确定性算法呢？
*   首先我们还是要维护区间的 $\min$ 和 $\max$，这样能知道首项和末项。
*   然后考虑一个等差数列的性质：
    *   公差为 $k$ 的等差数列中任意选出两个元素，他们做差一定是 $k$ 的倍数。
*   这样想到，如果把原序列做个差分呢？
*   把一个等差数列重排一下，然后做一个差分，这个差分数组的 $\gcd$ 一定是恰好等于 $k$ 的，这个是必要条件。
    1.  如果这个等差数列差分后 $\gcd = a \times k$，我们发现这个等差数列的公差一定是 $a \times k \gt k$。
    2.  如果这个等差数列公差是 $k$，差分数组的 $\gcd$ 一定也是 $k$，否则和 $1$ 一样反证了。
*   考虑把原序列差分，然后维护区间 $\gcd$。
*   还需要什么？还需要区间中不能出现重复的数。
*   这个我们对每个数维护前驱，然后变成一个数点的问题了。
*   总时间复杂度 $\mathcal O(m \log^2 n)$。
*   其实这个条件比数点弱，是查区间是否每个数的前驱都在区间外，所以维护区间前驱的 $\max$ 就可以了。
*   区间 $\gcd$ 是 $\mathcal O(\log n + \log v)$ 的。
*   总时间复杂度 $\mathcal O(m(\log n + \log v))$。

##  Codechef DGCD

*   给出一个长为 $n$ 的序列，有 $m$ 次操作：
    1.  询问区间 $\gcd$；
    2.  区间加。

### Solution

*   在序列上如何维护呢？
*   $\gcd(a, b) = \gcd(a - b, b)$。
*   将每个位置差分：
    *   $b[i] = a[i - 1] - a[i]$。
*   则 $a$ 的区间加对应了 $b$ 的单点修改。
*   $a$ 的区间 $\gcd$ 和 $b$ 的区间 $\gcd$（特判端点）相同。
*   所以我们可以维护差分后的序列，区间加变成了单点修改，就可以维护了，注意需要特判端点。

$$
\begin{aligned}
    & \gcd(a[l], a[l + 1], \cdots a[r]) \\
    = & \gcd(a[l], a[l + 1] - a[l], a[l + 2], \cdots a[r]) \\
    = & \gcd(a[l], a[l + 1] - a[l], a[l + 2] - a[l + 1], a[l + 3] - a[l + 2], \cdots a[r] - a[r - 1]) \\
    = & \gcd(a[l], b[l + 1], b[l + 2], b[l + 3], \cdots b[r]);
\end{aligned}
$$

*   区间 $\gcd$ 是 $\mathcal O(\log n + \log v)$ 的。

##  Problem

*   有一个序列，每个位置是一个 $(a, b)$ 的二元组，表示经过这个位置的时候如果值是 $a$ 则变成 $b$，如果值是 $b$ 则变成 $a$，否则不变。
*   每次询问给 $l, r, x$，求 $x$ 按顺序经过区间 $[l, r]$ 变化后的值。

##  P4344 [SHOI2015] 脑洞治疗仪

*   题意即：
    1.  区间赋 $0$；
    2.  区间最长连续 $0$；
    3.  把一个区间的 $1$ 依次填到另一个区间。

### Solution

*   使用线段树维护序列，对每个节点维护其是否为全 $1$，以及内部最长 $0$ 段，以及左右最长 $0$段。
*   对于 $3$ 操作，我们查区间和，这样就可以知道区间有多少 $1$ 了。
*   然后我们在填到的区间中二分一下填到哪个位置用完了我们挖出来的 $1$。
*   为了实现这两步需要维护每个节点代表的区间和。
*   然后就把 $3$ 操作转换为了：
    *   区间修改为 $0$ 或 $1$。
*   这样的操作。
*   每次直接二分位置然后线段树的话时间复杂度为 $\mathcal O(n + m \log^2 n)$。
*   可以做到 $\mathcal O(n + m \log n)$，在线段树上二分即可。

##  P3215 [HNOI2011]括号修复 / [JSOI2011]括号序列

*   区间不匹配括号一定是一堆左括号和一堆右括号。
*   每个节点记录下有多少左括号和右括号。
*   合并的时候左儿子的右括号和右儿子的左括号进行抵消，剩下的进行拼接。
*   三个修改操作都可以打标记。
*   其中 `Invert` 操作我们需要每个节点维护两个答案，分别对应区间没有被 `Invert`，以及被 `Invert` 的答案。
*   区间被 `Invert` 时交换上述两个信息即可。
*   总时间复杂度 $\mathcal O(n + m \log n)$。

##  P3586 [POI2015] LOG-Logistyka

### Solution

*   对于每次询问：
    *   如果 $a_i \ge s$，则 $a_i$ 可以每 $s$ 次操作都被选中；
    *   如果 $a_i \lt s$，则 $a_i$ 可以被 $a_i$ 次操作选中。
*   设数列中大于等于 $s$ 的数有 $k$ 个，小于 $s$ 的数的和为 $sum$。
*   则只需要判断 $sum \ge (c - k) \times s$ 即可。
*   发现需要维护小于 $x$ 的数的个数，小于 $x$ 的数的权值和。
*   于是我们用平衡树维护这个序列里面的所有值即可。

##  HDU5683 zxa and xor

*   给一个长为 $n$ 的序列，有 $m$ 次单点修改。
*   每次修改完了之后你需要输出所有 $(a_i + a_j)$ 满足 $1 \le i \lt j \le n$ 的 $\text{xor}$ 和。

### Solution

*   看到位运算怎么办？无脑拆位分别算贡献。
*   第 $k$ 位的计算答案则为有多少 $(i, j)$ 满足 $2^k \le (a_i + a_j) \lt 2^{k + 1}$。
*   使用一个数据结构维护值域。
*   每次 $a_i$ 修改的时候，对第 $k$ 位的贡献为有多少 $j$ 满足 $a_j$ 在 $[2^k - a_i, 2^{k + 1} - a_i)$ 中。
*   总共有 $\log v$ 个位。
*   所以总时间复杂度 $\mathcal O(n + m \log n \log v)$。

##  P6105 [Ynoi2010] y-fast trie

### Solution

*   我们把每个数对 $C$ 取模，所以可以认为值域在 $[0, C)$ 中。
*   发现 $x + y$ 在 $[0, 2C)$ 中，所以最多减去一个 $C$。
*   对每个 $x$，找出最大的 $y$ 使得 $x + y \lt C$（不减去 $C$）。
*   对每个 $x$，找出最大的 $y$（减去一个 $C$）。
*   发现 $x + y \ge C$ 的情况可以直接找出最大的两个 $x$ 和 $y$，平凡。
*   只需要考虑 $x + y \lt C$ 的情况。
*   如果我们把所有数都排序，假设 $x \lt y$，则对于 $x_1, x_2$，对应的是 $y_1, y_2$。
*   如果 $x_1 \le x_2$，则 $y_1 \ge y_2$，这个满足单调性。

### Solution1

*   问题即，给出一个点集，支持插入删除，和查询 $\max(x + y)$，使得 $x + y \lt C$。
*   再继续分析一下，发现如果 $x, y \lt C / 2$，这个也是平凡的。
*   $x, y \lt C / 2$ 可以推出 $x + y < C$，所以选两个最大的 $C / 2$ 以内的数就可以覆盖这部分的贡献。
*   目前非平凡的部分在于从 $[0, C / 2)$ 中选一个数 $x$，$[C / 2, C)$ 中选一个数 $y$，$x + y$ 的贡献。
*   $x + y \lt C$ 等价于 $x \lt C - y$。
*   我们可以认为最大化 $x + y$ 是在最小化 $C - x - y$。
*   于是用一棵平衡树维护，这里平衡树这个结构是用来满足 $x \lt C - y$ 这个条件的。
*   每个在 $[0, C / 2)$ 中的 $x$ 就直接插入，每个在 $[C / 2, C)$ 中的 $y$，就变成 $C - y$ 然后插入。
*   平衡树需要维护子树内最小的 $C - y$，最大的 $x$，最小的 $C - y - x$。
*   具体一点来说，所有 $[0, C / 2)$ 中的数 $x$ 看做 $A$ 集合，所有 $[C / 2, C)$ 中的数 $y$ 变成 $C - y$ 后看做 $B$ 集合.
*   我们要在 $A$ 和 $B$ 集合中选出两个数 $a, b$，使得：
    *   $a \lt b$，$b - a$ 最小。
*   平衡树可以维护这个。
*   这个信息显然可以合并。
*   于是我们使用分治结构，做到了 $\mathcal O(\log n)$ 单次修改。
*   总时间复杂度 $\mathcal O(n \log n)$。

### Solution2

*   还可以发现：
    *   对每个 $A$ 集合中的 $x$，维护出其在 $B$ 集合中的后继 $C - y$；
    *   对每个 $B$ 集合中的 $C - y$，维护出其在 $A$ 集合中的前驱 $x$。
*   这样一定是最优的。
*   每次修改这个前驱后继变动是 $\mathcal O(1)$ 的。
*   这样就可以不用手写平衡树，只需要 STL 的 set 就可以了。
*   总时间复杂度 $\mathcal O(n \log n)$。

##  Petrozavodsk Camp2018 MIPT Contest B. Bag of Bags

有 $N$（$\le 3 \times 10^5$）个物品，每个物品有实际大小 $a_i$ 和容量 $b_i$，$a_i \lt b_i$，若物品 $i$ 和 $j$ 满足 $a_i \lt b_j$ 且 $a_j \gt b_i$，则称它们是合适的。依次放入这些物品，某时如果产生了矛盾（存在三个物品 $i, j, k$ 满足 $i$ 和 $j$，$j$ 和 $k$ 是合适的但是 $i$ 和 $k$ 不合适）则扔掉该物品。模拟这个过程。

### Solution

*   考虑这个 $a_i \lt b_j$ 且 $a_j \lt b_i$ 实际上就是线段有交的所有情况。
*   题目要求即相交的一些线段两两有交。
*   对每个极大相交集合维护其交的区间。
*   每次插入线段，若与多个极大相交集合相交，则不满足条件，需要删除，否则判断其是否与对应的极大相交集合当前的交的区间相交，是的话则符合条件，新线段的加入可能会缩掉对应的极大相交集合当前的交的区间。
*   需要查询前驱后继，使用 set 或者平衡树来维护，总时间复杂度 $\mathcal O(n \log n)$，使用 vEB 树可以优化到 $\mathcal O(n \log \log n)$。

##  P6617 查找 Search

*   序列，给定常数 $w$：
    1.  单点修改；
    2.  查询区间是否存在两个数和为 $w$。
*   $5e5$，$4s$，值域 $1e9$。

### Solution

*   看到问题可以先想到二维数点的转化。
*   每个点 $x$，设置其前驱为离其最近的 $w - x$ 的位置。
*   这个和区间颜色数的转化类似。
*   如何带修改？
*   每次修改可能影响 $\mathcal O(n)$个位置：
    $w - x, x, x, x, x, x, x, \cdots$
*   这样后面每个位置的前驱都是 $w - x$。
*   如果修改了 $w - x$ 的值，这样会导致 $\mathcal O(n)$ 个修改。
*   观察性质？
*   注意到这个是存在性判定。
*   如果存在两个 $(i_1, j_1), (i_2, j_2)$ 使得 $a[i_1] + a[j_1] = w, a[i_2] + a[j_2] = w$，而且 $[i_2, j_2]$ 包含了 $[i_1, j_1]$，则 $(i_2, j_2)$ 没有任何意义。
*   这样每个点只存在 $\mathcal O(1)$ 个配对关系。

*   由于是存在性，所以我们维护 $b[i]$ 表示每个点的前驱。
*   如果区间 $[l, r]$ 内 $b[i]$ 最大值在 $[l, r]$ 中，则存在，否则不存在。
*   这样只需要 RMQ 线段树，和 set 维护前驱后继即可。
*   $\mathcal O(n + m \log n)$。

##  P5069 [Ynoi2015] 纵使日薄西山

### Solution

*   可以发现如果一个位置被操作了，那这个值和旁边两个值会一起减，而且一个位置被操作意味着这个值不会比旁边两个值小。
*   所以这里旁边两个值就不会有贡献了，因为会被中间那个一直操作给提前减到 $0$。
*   将原序列进行极长单调划分。
*   发现对于每个极长单调区间，答案一定是所有奇数位置或者所有偶数位置的和。
*   可以发现每次单点修改只会影响到这个点以及左右两个点是否成为局部极大值。
*   还有可能影响到旁边两个极长单调区间的状态。
*   这里影响是 $\mathcal O(1)$ 的，所以可以高效维护。
*   细节比较多。
*   $\mathcal O(m \log n)$。

##  HDU6013 Lotus and Thermodynamics

*   一眼分治信息还能打标记。

##  李超线段树

*   P4069 [SDOI2016]游戏
*   P4097 [HEOI2013]Segment

### Solution

*   写个线段树。
*   每个节点维护一个永久化的标记，标记存的是一个等差数列，表示这个节点对这个等差数列取了 $\max$。
*   如果这个节点被打上了一个新标记，我们可以选择把一边的标记下放。
*   那我们肯定考虑 PushDown 小的那一段，直接 PushDown 到对应的儿子上即可。
*   可以发现每次 PushDown 的时候只会下放到子树内的一个儿子里。
*   每次 PushDown 的复杂度是 $\mathcal O(1)$，每个标记会 PushDown $\mathcal O(\log n)$ 次。
*   所以复杂度为 $\mathcal O(m \log^2 n)$。
*   查询就是，我们和线段树一样找出和这个位置有关的 $\mathcal O(\log n)$ 个线段树节点，然后计算这个位置在这些节点上的高度，取个 $\max$。
*   查询复杂度 $\mathcal O(\log n)$。
*   应该可以通过多叉树平衡做到 $\mathcal O(m \log^2 n / \log \log n)$。

##  P5608 [Ynoi2013] 文化课

### Solution

*   对原序列建一棵线段树，考虑怎么在线段树上面修改和查询。
*   定义 极长 “X” 段为一个极长的子区间，使得区间中符号均为乘法。

####    区间值修改

*   维护出区间中每个极长的 “X” 段的长度，可以发现这个存在一个自然根号：
*   假设区间长度为 $size$，则最多只有 $\mathcal O(\sqrt{size})$ 种极长 “X” 段的长度。
*   每次对区间进行值修改的时候，即对这个长度为 $\mathcal O(\sqrt{size})$ 的多项式进行求值，暴力计算即可，求值复杂度为 $\mathcal O(\sqrt{size})$，即可以 $\mathcal O(\sqrt{size})$ 的时间将一个节点值进行修改，同时维护信息。

####    区间符号修改

*   每次对区间符号进行修改的时候，区间的信息只会变成区间和或者区间乘积，所以我们每个节点要维护区间和和区间乘积。
*   符号修改之后，这个节点的极长 “X” 段只会有 $\mathcal O(1)$ 种了。
*   符号进行修改可能影响一些节点的极长 “X” 段，考虑如何维护这个。
*   对一个节点，我们可以归并两个儿子的极长 “X” 段，来维护出这个节点的极长 “X” 段。
*   对一个大小为 $size$ 的节点进行归并，代价是 $\mathcal O(\sqrt{size})$ 的。
*   注意需要特判左儿子的最右极长 “X” 段是否和右儿子的最左极长 “X” 段进行合并。

####    区间信息合并

*   合并区间信息的时候，只需要把左右儿子信息加起来，同时特判 $\mathcal O(1)$ 个位置即可。
*   这 $\mathcal O(1)$ 个位置就是左儿子的最右部分和右儿子的最左部分。
*   可以处理：
    *   标记对标记的影响；
    *   标记对信息的影响；
    *   信息和信息的合并；
*   所以我们正确性有保证了。

####    复杂度

*   我们所有地方的复杂度都是 $\mathcal O(\sqrt{size})$ 的。
*   线段树在每层只会递归到 $2 = \mathcal O(1)$ 个节点中，所以每层只有 $\mathcal O(1)$ 个节点的信息需要更新。
*   总时间复杂度 $\mathcal O(m \sqrt n)$，空间复杂度 $\mathcal O(n)$。

##  CF280D k-Maximum Subsequence Sum

### Solution

*   我们先考虑 $k = 1$ 的情况。
*   对于 $k = 1$，其实就是求最大子段和。
*   对于 $k = 2, 3 \cdots$，一个比较自然的想法是每次取剩下部分的最大子段和，但这里实际上是有问题的，因为不一定 $k$ 的情况一定是 $k - 1$ 的基础上增加 $1$ 个区间。
*   这里有一种也被叫做“模拟费用流”的思路。
*   每次选出一个区间后，我们将区间乘 $- 1$。
*   这样如果下次选到了已经选到过的元素，相当于抵消掉了，没有选过这个元素。
*   可以发现，如果当前有 $k - 1$ 个被选了的子段，再选择任何一个区间都会导致有 $k$ 个被选了的子段，并且由于每次选择的是当前的最大子段，所以这里正确性也是有保证的。
*   问题变为区间 $*= - 1$，区间最大子段和。
*   可以使用维护区间乘 $- 1$ 前与后的最大子段和来处理，即同时维护最大子段和与最小子段和，当节点 $*= - 1$ 后，则交换节点的最大子段和与最小子段和。
*   总时间复杂度 $\mathcal O(n + m k \log n)$。

#   简单的均摊复杂度问题

##  序列染色段数均摊

*   特点：修改有区间染色操作。
*   用平衡树维护区间的颜色连续段。
*   区间染色每次最多只会增加 $\mathcal O(1)$ 个连续颜色段，用平衡树维护所有连续段即可。
*   均摊的颜色段插入删除次数 $\mathcal O(n + m)$。
*   应用：
    *   区间染色，维护区间的复杂信息；
    *   区间排序；
    *   “ODT”类问题；
*   注意这里这个颜色段数均摊是有 $2 \sim 3$ 的常数，常数很大。

##  Problem

*   给一个序列，每个位置是一个 $3 \times 3$ 的矩阵：
    1.  区间修改为一个给定的矩阵；
    2.  查询区间矩阵从左到右的乘积。
*   要求 $1 \log$。

### Solution

*   如果用线段树直接做的话，会发现复杂度是 $2 \log$ 的。
*   我们线段树每次 PushDown 的时候，要根据左右两个儿子的 $size$ 而重新计算矩阵快速幂。
*   如何解决这个问题？

### Solution1

*   我们可以把线段树建成一个 $2^k$ 长度形式的。
*   然后记录下区间修改矩阵的 $2^0, 2^1, \cdots 2^k$ 次幂的值。
*   每次 PushDown 的时候，儿子的长度也是 $2^k$ 形式的，这样可以直接利用记录的信息求解。
*   $\mathcal O(n + m \log n)$。

### Solution2

*   使用序列上的颜色段均摊。
*   每个完整的颜色段我们计算出快速幂。
*   每次查询区间乘积时，发现会完整包含一些颜色段，以及边界上会有 $\mathcal O(1)$ 个不完全包含的段。
*   $\mathcal O(1)$ 个不完整的段直接快速幂即可。
*   $\mathcal O((n + m) \log n)$。

##  CF444C DZY Loves Colors

##  CF453E Little Pony and Lord Tirek

*   给一个序列：
    *   每个位置有初值 $a_i$，最大值 $m_i$，这个值每秒会增大 $r_i$，直到 $m_i$。
*   有 $m$ 个发生时间依此增大的询问，每次询问区间和并且将区间的所有数字变成 $0$。

### Solution

*   这个问题每次查询是区间查询并赋值，可以考虑颜色段均摊的方法。
*   假设一段上次修改时间是 $x$，这次修改时间是 $y$，这段的贡献怎么求？
*   将贡献分为这段时间充能满了和没满的分别讨论。
*   计算出一个数组 $a[i]$ 表示 $i$ 位置从 $0$ 开始充能充 $a[i]$ 秒，使得充 $a[i] + 1$ 秒后满。
*   区间中没充满能的位置即所有 $i$，满足 $a[i] \lt y - x$，我们要求这些位置的 $r[i]$ 的和。
*   区间中充满能的位置即上述的补，我们要求这些位置 $m[i]$ 的和。
*   即变成区间 $a[i] \lt x’$ 的 $b[i]$ 的和，二维数点即可。
*   有初值，颜色段均摊导致查询次数 $\mathcal (n + m)$ 次。
*   总时间复杂度 $\mathcal O((n + m) \log n)$。

##  重量平衡树

*   平衡树旋转/重构的节点的 $size$ 的和是 $\mathcal O(n \log n)$。
*   这样可以在旋转的时候暴力重构一些信息。
*   一般用来解决动态标号问题：
    *   序列
    1.  在 $x$ 后面插入 $y$；
    2.  查询 $x$ 和 $y$ 在序列上的先后问题，这个要求 $\mathcal O(1)$。
*   可以线性解决，但是由于其他部分一般带 $\log$ 所以 OI 中一般采用 $\mathcal O(n \log n)$ 的解决方法。
*   应用：
    *   套用动态标号法可以得到平衡树维护后缀数组的算法，被称为“后缀平衡树”；
    *   可以实现树套树的外层树插入。

##  P5610 [Ynoi2013] 大学

*   序列：
    1.  区间 $x$ 倍数 $/ x$；
    2.  区间和。
*   强制在线。
*   序列长度 $\le 1e5$，值域 $\le 5e5$。

### Solution

*   考虑到一个数最多被除 $\log$ 次，如果除数非 $1$。
*   所以问题变成了如何快速找出 $x$ 的倍数。
*   我只会一个很无聊很幼稚很简单很暴力的做法。
*   就是把每个下标插入到其因数的所有平衡树里。
*   然后每次 $x$ 的倍数 $/ x$，就在 $x$ 对应的平衡树里面暴力查询一段区间的每个数是否是 $x$ 倍数。
*   由于平衡树的复杂度是 $O(\log n + s)$（$s$ 是这个区间的点数）。
*   $d(v)$ 表示 $\le v$ 的所有数里面最大的约数个数。
*   所以总复杂度是 $\mathcal O(n dd(v) + n \log n \log v + m \log n)$。

##  Problem

*   
    1.  输入 $l, r, x$，区间 $[l, r]$ 所有数除以 $x$ 后下取整；
    2.  求区间和。
*   值域 $[0, 10^9]$。

##  CF438D The Child and Sequence

*   维护一个长为 $n$ 的序列，有 $m$ 次操作：
    1.  单点修改；
    2.  区间每个位置对 $p$ 取模，$p$ 是每次给出的；
    3.  求区间和。
*   $p \le 1e9$。

### Solution

*   如果 $x \ge 2p$，$x \bmod p \le p \le 2p / 2 \le x$；
*   如果 $p \le x \lt 2p$，$x \bmod p = x - p \lt x / 2$。
*   所以每个数每次会减半，最多 $\log v$ 次之后就变成 $0$ 了。
*   线段树维护一个区间最大值，能减就减。
*   总复杂度 $\mathcal O((n + m) \log n \log v)$。

##  HDU6315 Naive Operations

*   给两个序列 $a$ 和 $b$，$b$ 是 $1 \sim n$ 的排列：
    1.  $a$ 区间加 $1$；
    2.  求区间内所有 $\lfloor a_i / b_i \rfloor$ 的和。

### Solution

*   假设进行了 $n$ 次全局加。
*   发现全局的和是 $\sum_{i = 1}^n \frac{n}{i} = \mathcal O(n \log n)$。
*   这是一个调和级数。
*   用树状数组维护答案序列。
*   于是每次如果有一个点的答案发生变化，就在一个点位置 $+ 1$ 即可。
*   总复杂度 $\mathcal O(m \log^2 n)$。
*   怎么找出每次修改的位置呢?
*   线段树维护序列，每个位置初始是 $- b_i$。
*   每次区间加 $1$ 相当于线段树的区间加 $1$。
*   每次操作完之后，找哪些位置是 $0$，这个可以维护一个最大值来维护出来。
*   把这些 $0$ 位置直接进行修改即可。

##  HDU5634 Rikka with Phi

*   给一个长 $n$ 的序列，$m$ 次操作：
    1. 区间 $[l, r]$ 中所有 $a_i$ 变成 $\varphi(a_i)$；
2. 区间 $[l, r]$ 中所有 $a_i$ 变成 $x$；
3. 区间和。

##  HDU5997 rausen loves cakes

##  CF702F T-Shirts

### Solution

*   对所有衣服按照 $q[i]$ 从大到小排序。
*   对每个人维护 $a[i]$ 表示其剩余的钱，$b[i]$ 表示其买的衣服数量。
*   对所有人按照 $a[i]$ 从小到大排序，初始 $b[i] = 0$。
*   之后枚举每件衣服 $j = 1 \sim n$。
*   衣服 $j$ 对人的影响就是把全局 $a[i] \ge c[j]$ 的人都 $a[i] -= c[j]$，并且 $b[i]++$。
*   用一棵平衡树维护每个人，按 $a$ 从小到大排列。
*   每次找出所有 $a[i] \ge c[j]$ 的人，将其 $a[i] -= c[j]$，并且 $b[i]++$。
*   这里我们考虑令 $x = c[j]$，所有在 $[0, x)$ 内的数不动，把所有在 $[x, 2x]$ 内的数暴力修改，之后将 $\gt 2x$ 的数直接打一个 $b$ 加，$a$ 减的标记。
*   这里平衡树可以打标记，因为我们这样可以保证不会出现值域重叠的情况。
*   可以发现 $[x, 2x]$ 内的元素至少减半了，所以这样的暴力操作对每个点最多进行 $O(\log v)$ 次。
*   总时间复杂度 $\mathcal O((n + m) \log n \log v)$。

##  LOJ6029 「雅礼集训 2017 Day1」市场

### Solution

*   对线段树每个节点维护 $\min$ 和 $\max$。
*   如果区间除的时候，$\lfloor \max / d \rfloor = \lfloor \min / d \rfloor$，则这次区间除可以用一次区间减代替。
*   如果 $\lfloor \max / d \rfloor \neq \lfloor \min / d \rfloor$，则递归到两边分别计算。
*   每次区间除，如果递归了，那么 $\max - \min$ 都会减半。
*   考虑每个节点的极差。
*   每次一个节点如果 $\lfloor \max / d \rfloor \neq \floor \min / d \rfloor$ 则发生递归，此时 $\max - \min$ 会减半。
*   一个节点如果不递归，则只需要一个全局减标记。
*   每次区间加可以让线段树上 $\log n$ 个节点的 $\max - \min$ 增加 $v$，于是之后会多递归 $\log n \times \log v$ 次。
*   于是总时间复杂度为均摊 $\mathcal O(n \log v + m \log n \log v)$。

##  UOJ228 基础数据结构练习题

### Solution

*   $\sqrt ~$ 这个操作肯定是一个均摊，因为下降很快。
*   但是有区间加，怎么办呢？
*   想一想感觉可以维护值相同的连续段试试？
*   然后就 TLE 了。
*   发现会被奇怪的数据卡。
*   发现这种情况仅当 $a = b - 1$ 且 $b$ 是完全平方数的时候会出现。
*   于是想办法维护一下区间极差就可以判掉这种情况。
*   由于取 $\sqrt ~$ 的次数是 $\mathcal O(\log \log v)$ 的，
*   所以总复杂度是 $\mathcal O((n + m) \log n \log \log v)$。
*   大概是使用所有连续段以外相邻位置的差来作为势能的均摊。

##  LOJ504 「LibreOJ β Round」ZQC 的手办

##  P5068 [Ynoi2015] 我回来了

*   P6609 [Code+#7]教科书般的亵渎

*   我们考虑亵渎什么时候可以被触发。
*   首先他一定会触发一次，那么这个时候需要让场上所有人的血量 $- d$，想要触发下一次，一定需要有一个人的血量在 $[1, d]$ 的范围内，如果触发第三次呢？不难发现就是需要有一个人的血量在 $[d + 1, 2d]$ 的范围内，以此类推。
*   所以对于伤害值为 $d$ 的情况，亵渎能够被触发的次数就是最大的 $k$，使得对任意 $i$ 在 $[1, k)$，存在 $h_j \in [i \times (d - 1) + 1, i \times d)$。
*   因为每次只有插入一个数，所以我们发现对每个 $d$，$k$ 一定会逐渐变大。
*   变化量是多少呢？
*   可以发现这个实际上是 $n / 1 + n / 2 + \cdots + n / n = \mathcal O(n \log n)$，是一个调和级数。
*   我们用平衡树维护每个 $d$ 当前延伸到的位置，每次插入 $x$ 的时候即在平衡树上暴力找出有哪些 $d$ 需要继续向后延伸，然后一直延伸。
*   每次一个 $d$ 改变了延伸到的位置后需要一个树状数组进行单点修改。
*   总时间复杂度 $\mathcal O(n \log^2 n + m \log n)$。

##  P7447 [Ynoi2007] rgxsxrs

### Solution

*   考虑用一种特殊的值域分块方法，按值在 $[0, 1), [1, 2), [2, 4), [4, 8), [8, 16) \cdots$ 进行分块，这样共有 $\mathcal O(\log v)$ 块。
*   每次区间大于 $x$ 减去 $x$ 时，对于一个块 $[2^k, 2^{k + 1})$：
    1.  若 $2^k \gt x$，则在这个块中的所有元素一定需要减去一个 $x$；
    2.  若 $2^{k + 1} \le x$，则在这个块中的所有元素一定不需要减去一个 $x$；
    3.  若 $2^k \le x \lt 2^{k + 1}$，则这个块中最大的某几个元素需要减去一个 $x$。
*   对在每个值域块内的所有下标，开不同的线段树维护，这样共 $\mathcal O(\log v)$ 棵线段树。
    1.  对每棵线段树维护区间 $\min$，修改时若区间 $\min$ 减去 $x$ 后不属于这个值域块，则会掉落到更低的值域块中，将其二分出来后移动到另一棵线段树中，由于 $\mathcal O(\log v)$ 个块，所以这样的操作最多进行 $O(n \log v)$ 次，剩下的元素进行一次区间 $- x$；
    2.  啥都不用做；
    3.  对每棵线段树维护区间 $\max$，若区间 $\max \gt x$，则将其修改为减去 $x$ 后的值，这里因为 $x$ 在 $[2^k, 2^{k + 1})$ 中，所以 $\max$ 减去 $x$ 后大小会减半，于是这样的操作对于每个数只会发生 $\mathcal O(\log v)$ 次。
*   可以使用 $\mathcal O(\log v)$ 棵平衡树，这样空间复杂度是线性的，但是常数非常大。
*   有个推荐的写法是先底层对序列按 $\mathcal O(\log v)$ 大小分块，然后在这个基础上建立线段树，这样线段树只有 $\mathcal O(n / \log v)$ 个节点，然后线段树每个节点维护 $\mathcal O(\log v)$ 的信息而不是开 $\mathcal O(\log v)$ 棵线段树每个维护 $\mathcal O(1)$ 的信息，这个对缓存有好处。
*   总时间复杂度 $\mathcal O((n + m) \log n \log v)$。

##  P5066 [Ynoi2014] 人人本着正义之名

*   考虑用平衡树维护序列，将一段连续的同色极长段缩为一个点。
*   发现操作具有对称性，本质上只有：
    *   区间染色为 $0 / 1$；
    *   区间每个数 $\text{or} / \text{and}$ 上左 $/$ 右；
    *   区间和；
*   这三种操作。
*   发现第二种操作其实就是让区间中 $0 / 1$ 的同色极长段各自向左 $/$ 右扩散一格的位置。
*   我们修改的时候不修改这个给定的区间，而是让区间两端点根据操作种类和所在的同色极长段的颜色进行调整，具体来说就是检查一下是否包含这个同色极长段，然后调节我们这次修改的区间的位置。
*   然后问题便转化为，每次区间中 $0 / 1$ 的同色极长段各自变大 $1$ 或者缩小 $1$，这个可以通过在缩点平衡树结构上打标记来实现。
*   因为有可能一个同色极长段在缩了之后变成 $0$，所以我们需要维护一下区间内最小的同色极长段长度，如果是 $0$ 则暴力将其删去，同时合并两边的段。
*   可以发现每次修改只会增加 $\mathcal O(1)$ 个同色极长段，每次删除可以花 $\mathcal O(\log n)$ 的代价减少一个同色极长段。
*   总时间复杂度 $\mathcal O((n + m) \log n)$，空间复杂度 $\mathcal O(n)$。

##  LOJ6777 「2021 营员交流」大毒瘤

### 分析

*   重点在于均摊的性质。
*   考虑使用连续段均摊来解决。
*   问题在于批处理范围修改操作。

### Solution

*   维护每个极长的有树的段以及有火的段。
*   树生长操作就是区间有树的段每个位置加一个数。
*   放火操作就是区间内部所有树段被删除。
*   每次蔓延可以直接打一个区间树段长度 $- 2$ 的标记，然后把减到 $0$ 以下的树段删除，两边的火段合并。
*   问题在于每次蔓延删掉的树高度不一定一样，因为每个位置是不对称的，有高度这个因素。
*   考虑对每个火，维护出其左右的树高度分别是多少。
*   然后维护区间的所有火左右的树高度的和。
*   这样区间蔓延的时候就是区间树高度和减去区间所有火两边树高度和。
*   考虑将树按照高度分为不同的段，每个段内高度一样。
*   每次区间加的时候，只有两端的连续段可能被拆分为两个新的段，所以这样的段总共 $\mathcal O(n + q)$ 个。
*   如果一个火的段旁边树的段高度发生变化，那一定是原来的树的段被烧没了，于是维护区间每个火段旁边树段的最短长度，烧没了递归下去处理一下即可，这里均摊递归 $\mathcal O(n + q)$ 次。
*   还需要注意一个均摊是区间如果很多火的段，我把这些段浇灭了的话会导致区间这些火都变成树。
*   但这些树高度是一样的，所以也是同样的连续段。
*   然后火的段数显然也有均摊，所以这里还是均摊 $\mathcal O(n + q)$ 次。
*   总时间复杂度 $\mathcal O((n + q) \log n)$。

##  Petrozavodsk Camp2018 MIPT Contest H.Halve and Merge

*   给出 $N$（$\le 2 \times 10^5$）个数的排列和 $M$ 个操作。操作分为两种：
    1.  问位置 $p$ 的数字是什么；
    2.  将区间 $[1, x]$ 和区间 $[x + 1, N]$ 执行归并操作，得到的结果覆盖原序列。
*   注意这里是单纯套用传统归并操作的做法，结果显然不一定有序。

##  PKUSC2021D1T2 逛街

*   给定长度为 $n$ 的序列 $a_i$，$Q$ 次操作：
    *   `1 l r`：$\forall l \le i \lt r, a_i = \max \\{ a'_i, a'_{i + 1} \\}$，其中 $a'_i$ 为未修改前 $a_i$ 的权值；
    *   `2 l r`：求出 $\sum_{x \in S} a_x$，其中 $S = \\{ x \vert l \le x \ le r, \forall l \le i \lt x, a_i \lt a_x \\}$。
*   $1 \le n, Q \le 3 \times 10^5$，$1 \le a_i \le 10^9$，$a_i$ 互不相同。

### Solution

*   这个结构是类似于颜色段均摊的。
*   将值相同的连续段缩起来，每次修改就是区间内每个颜色段长度会发生变化。
*   对于每一段：
    *   如果这一段的值比相邻两段的值都大，则操作后这一段长度会 $+ 1$；
    *   如果这一段的值比相邻两段的值都小，则操作后这一段长度会 $- 1$；
    *   如果这一段比相邻两段中一个大一个小，则操作后这一段长度不变。
*   这里可以使用颜色段均摊的方法维护。
*   使用平衡树维护缩了颜色段的序列，每一段有信息 $a, b$ 表示长度以及每次操作后会变长 $b$，有标记 $c$ 表示进行了 $c$ 次修改操作。
*   平衡树额外维护一个区间 $a$ 的和。
*   每次区间进行修改操作时，区间 $c += 1$，$a += b$。
*   这里需要特判一个颜色段消失的情况。
*   颜色段消失等价于 $a = 0$，平衡树需要额外维护区间最小的 $a$，这里只需要对 $b = - 1$ 的段维护这个信息，每次修改的时候一起变小
*   颜色段消失的时候在平衡树上二分，递归进所有 $\min(a) = 0$ 的儿子，这样可以 $\mathcal O(\log n)$ 代价干掉一个颜色段，由于颜色段均摊，这部分时间复杂度 $\mathcal O((n + m) \log n)$。
*   再考虑这题的询问。
*   询问的信息是楼房重建，我们可以在平衡树上直接维护楼房重建的信息，区间询问的时候需要自顶向下定位到具体的左右端点所在颜色段，之后单点修改的时候和楼房重建类似维护。
*   总时间复杂度 $\mathcal O((n + m) \log^2 n)$。
*   离线的话应该可以少个 $\log$，比较麻烦。

##  P3747 [六省联考 2017] 相逢是问候

*   由欧拉定理，每个数最多变换 $\mathcal O(\log v)$ 次。
*   因为这里指数每次变为 $\varphi(p)$，
    *   当 $p$ 为偶数时，$\varphi(p)$ 至少 $/ 2$；
    *   当 $p$ 为奇数时，$\varphi(p)$ 为偶数；
*   如果 $\varphi(p) = 1$，则继续下去值不变。
*   于是暴力即可。
*   需要维护区间中每个数是否下次还能进行题目中的操作。
*   每个数可以操作 $\mathcal O(\log v)$ 次，每次操作需要 $\mathcal O(\log v)$ 的快速幂，这里均摊的代价是 $\mathcal O(\log^2 v)$。
*   总复杂度 $\mathcal O((n + m) (\log n + \log v) \log v)$。

##  Old Driver Tree

*   在有类区间染色操作，以及保证数据随机的情况下，可以用一个平衡树维护颜色连续段的暴力来解决。
*   复杂度期望 $\mathcal O((n + m) \log \log n)$，可以做到 $\mathcal O(n + m)$，但是不实际。
*   在线可以做到：
    *   $\mathcal O((n + m) \log \log n)$（直接做）；
    *   $\mathcal O((n + m) \log \log \log n)$（使用 exponential tree）；
    *   $\mathcal O(n + m)$（使用 $\mathcal O(\log n / \log w)$ 的动态前驱数据结构）；
*   离线可以简单的做到 $\mathcal O(n + m)$，压位即可。
*   可以证明复杂度是期望 $\mathcal O((n + m) \log n)$ 的。
*   假设有 $k$ 种操作，其中一种是区间染色，定义势能为颜色段个数。
*   每次操作的时候有两种可能性：
    1.  以 $\mathcal O(x)$ 的代价消除 $\mathcal O(x)$ 势能，势能 $+ 2$，概率 $1 / k$；
    2.  以 $\mathcal O(x)$ 的代价啥都没做，势能 $+ 2 $，概率 $1 - 1 / k$。
*   势能的均摊是 $\mathcal O(n + m)$。
*   于是这部分总的代价是 $\mathcal O((n + m) k)$。
*   所以复杂度瓶颈在于平衡树而不是暴力的均摊部分。
*   应用：
    *   各种题都能用，基本上不会被卡。
    *   因为大部分出题人都觉得序列维护的那种数据结构题只需要随机数据就足够强了。
    *   不过要注意，别被没有区间染色的部分分给卡了。
    *   可以水掉各种题。

##  CF1446D2 Frequency Problem (Hard Version)

*   给一个序列。
*   求最长的子段使得其中有至少两个出现次数最多的元素。
*   输出最长子段长度。
*   加强一下，$n \le 1e6$。

### Solution

*   可以证明，这两个出现次数最多的元素中，必定有一个是全局的众数。
*   假设众数 $x$ 出现次数为 $a$，我们目前考虑一个值 $y$，计算 $y$ 与 $x$ 的答案最大是多少，$y$ 出现 $b$ 次。
*   我们如果得到一个 $\mathcal O(a + b)$ 的算法，这个题就是根号题了。
*   我们要得到一个 $\mathcal O(b \times PolyLog(n))$ 的算法。
*   初始将每个 $x$ 出现的位置标记为无意义的位置。
*   我们枚举 $y$ 出现的每个位置，然后找离这些位置最近的x出现的无意义位置（左右两边都找），然后将这些位置标记为有意义的位置。
*   可以证明标记结束后无意义的位置和答案无关。
*   一个位置 $A$ 无意义，即对其前面所有 $y$ 出现的位置 $B$，$[B, A]$ 之间一定 $x$ 出现次数 $\gt y$，同理对后面也成立，所以这个位置不可能是答案端点。
*   所以只有 $\mathcal O(b)$ 个可能的答案端点，这里用线段树维护就是 $\mathcal O(b \log n)$ 的。
*   由于所有数的出现次数和为 $n$。
*   所以得到一个 $\mathcal O(n \log n)$ 的算法。

##  P4062 [Code+#1]Yazid 的新生舞会

### Solution

*   令 $x = 1 \sim n$。
*   求有多少区间出现次数过半的元素为 $x$。
*   和上一题一样，我们把所有 $x$ 出现的位置，其前后第一个非 $x$ 的位置标记。
*   然后一个非 $x$ 的位置没有被标记，等价于任何包含这个位置的区间，其内部 $x$ 出现次数都 $\le$ 其他值出现次数。
*   于是对答案有贡献的区间一定是被标记的连续区间的子区间。
*   这些连续区间长度和为 $\mathcal O(n)$。
*   考虑每段被连续标记的区间。
*   将 $x$ 位置设为 $+ 1$，非 $x$ 位置设为 $- 1$。
*   记 $pre[i] = pre[i - 1] + (a[i] == x ? 1 : - 1)$。
*   一个区间 $(i, j)$ 对答案有贡献等价于 $pre[j] - pre[i -1 ] \gt 0$ 且 $j \gt i$。
*   这个就是个顺序对，直接做就行。
*   总时间复杂度 $\mathcal O(n \log n)$。
*   其实这两题都能线性。

##  P5073 [Ynoi2015] 世上最幸福的女孩

*   维护序列支持：
    1.  全局加；
    2.  区间最大子段和。

### Solution1

*   由于可以加负数，
*   设 $pre[x]$ 为 $x$ 时刻全局加的值。
*   按照 $pre$ 从小到大处理。
*   这样就转换为了只加正数。
*   考虑分块。
*   每块维护一下块内长为 $1 \sim \sqrt n$ 的最大前缀，最大后缀，最大子段和。
*   如果一个整块加了，那么这个整块块内的最大子段长度肯定是不降的。
*   每次查询的时候按照当前的全局加标记确定出每个块内的最大子段和。
*   然后把跨块的询问用左边块的最大后缀和右边块的最大前缀拼起来。
*   即可。
*   总复杂度 $\mathcal O(m \sqrt n + n \sqrt n)$。

### Solution2

*   这个根号太屑了，考虑 $PolyLog$。
*   线段树维护：
    *   每个节点的左，右，内部最大子段和的凸函数。
*   凸函数是一个区间的半平面交，每个下标 $x$ 对应的意义是这个节点被整体加了 $x$ 后，该节点的左，右，内部最大子段和的值是多少。
*   设左最大子段和是 $pre$，右最大子段和是 $suf$，内部最大子段和是 $mid$。
*   然后建树的时候可以发现：

$$
\begin{aligned}
    node[u].pre & = \max(node[node[u].lson].pre, node[node[u].rson].pre + node[node[u].lson].sum) \\
    node[u].suf &   = \max(node[node[u].lson].suf + node[node[u].rson].sum, node[node[u].rson].suf) \\
    node[u].res & = \max(node[node[u].lson].res, node[node[u].rson].res, node[node[u].lson].suf + node[node[u].rson].pre)
\end{aligned}
$$

*   这个可以类比单点修改区间最大子段和理解。
*   我们来看看这个需要支持什么操作。
*   需要支持：
    1.  把一个凸函数加上一个常数；
    2.  求一个凸函数 $a$，满足 $a[i] = \max(b[i], c[i])$，其中 $b, c$ 为凸函数；
    3.  求一个凸函数 $a$，满足 $a[i] = b[i] + c[i]$，其中 $b, c$ 为凸函数。
*   可以发现这三个性质都满足。
*   而且可以通过归并两个儿子的凸函数来得到 $node[u]$ 的凸函数。
*   于是预处理复杂度 $\mathcal O(n \log n)$。
*   每次查询的时候直接在线段树上查询区间即可。
*   总复杂度 $\mathcal O((n + m) \log n)$。

##  LOJ3673 「北大集训 2021」简单数据结构

### Solution

*   可以发现修改操作都是全局的。
*   如果进行了 $x$ 次 $2$ 操作，则第 $i$ 个位置加上了 $i x$。
*   这个时候进行 $1$ 操作，值为 $v$。
*   等价于对第 $i$ 个位置，将 $a[i]$ 对 $v - i x$ 取 $\min$，之后加上 $i x$。
*   $+ i x$ 的贡献是好算的，问题转换为每次 $a[i]$ 对直线 $(- x) i + v$ 取 $\min$，并且直线斜率单调。
*   对所有被取 $\min$ 过的点和没有的点分别处理。
*   对取 $\min$ 的点，进行新的取 $\min$ 操作可以计算出这次修改对哪个区间的 $i$ 有影响，然后就是有一些位置有值，区间修改为等差数列，区间和，是简单分治信息。
*   具体而言，每次修改会覆盖掉轮廓上后缀的一些线段，对每条线段加的等差数列不同。
*   这里有颜色段均摊，总的区间加操作是 $\mathcal O(n + m)$ 次的。
*   对没有被取 $\min$ 的点，只需要每次高效找到应该被取 $\min$ 的点即可，因为这里只会删除，有均摊。
*   考虑直接维护原问题，当一个点被取 $\min$ 时，相当于这个点被删除，我们问题转换为每次找到需要被取 $\min$ 的点，于是维护 $\max$。
*   全局加等差数列 $1, 2, \cdots m$，区间 $\max$ 和 全局加 $1$，区间最大前缀和 等价。
*   方式是假设右侧的序列是 $a$，构造 $b[i] = a[1] + \cdots + a[i]$。
*   则最大的 $a[1] + \cdots + a[x]$ 等价于 最大的 $b[x]$。
*   $a$ 全局加 $1$ 等价于 $b$ 全局加等差数列。
*   于是可以用 P5073 的方法维护后面这一部分的数据结构。
*   这一部分时间复杂度 $\mathcal O((n + m) \log m)$。
*   前一部分时间复杂度 $\mathcal O(n + m \log n)$。
*   总时间复杂度 $\mathcal O((n + m) \log m + m \log n)$。

#   扫描线

##  B 维正交分解

*   在一个 B 维直角坐标系下，第 $i$ 维坐标在一个整数范围 $[l_i, r_i]$ 间，内部的点集。
*   一般 $1$ 维正交范围简称区间，$2$ 维正交范围简称矩形，$3$ 维正交范围简称立方体。

##  A-side 的 B 维正交分解

*   对于 B 维正交范围，每一维都有两个限制，即有两条边（side），这样是一个 2B-side 的 B 维正交范围。
*   如果部分维只有一个限制，则是一个 A-side 的 B 维正交范围。
*   如果有一维没有限制，则这一维是平凡的，没有任何意义，可以简化到一个 (B - 1) 维的问题。
*   A-side 的 B 维正交范围不能确定出是哪些维，如果维不对称的话需要特殊说明。

##  一维扫描线

*   对于一个静态的二维问题，我们可以使用扫描线扫一维，数据结构维护另一维。
*   在扫描线从左到右扫的过程中，会在数据结构维护的那一维上产生一些修改与查询。
*   如果查询的信息可差分的话直接使用差分，否则需要使用分治。
*   另一种看待问题的角度是站在序列角度，而不站在二维平面角度。
*   如果我们这样看待问题，则扫描线实际上是枚举了右端点 $r = 1, \cdots, n$，维护一个数据结构，支持查询对于当前的 $r$，给定一个值 $l$，$l$ 到 $r$ 的答案是什么。
*   即扫描线扫询问右端点，数据结构维护所有左端点的答案。

##  Notice

*   其实看到任何范围修改查询问题，如果能差分的话，想都不想就差分是不会有问题的，我推荐直接这样做。
*   典型的差分方法：
    *   序列区间 $[l, r]$ 差分为 $[1, r] - [1, l - 1]$ 的前缀；
*   树上差分；
*   二维前缀和的差分。

##  原因

*   “自由度”的问题。
*   通过差分我们可以将一个高维问题以常数的代价转换为低维问题。
*   而问题低一维往往会简单非常多。
*   考虑线段树查询区间的时候访问的点个数，以及线段树查两次前缀访问的点个数。
*   可以发现常数代价在大部分情况下都不存在。
*   所以建议大家做题看到可以差分的区间，树路径等范围，想都不想直接差分掉。

##  直接做一维扫描线

*   问题可差分的时候，我们通过差分可以将一个 4-side 矩形查询问题变为两个 3-side 矩形查询问题的差。
*   将第一维的 1-side 的区间（即前缀）扫描线扫掉，数据结构维护 2-side 的区间查询，支持：
    1.  单点修改，区间查询；
    2.  区间修改，单点查询；
    3.  区间修改，区间查询；
*   中的一种。

##  静态区间查询类问题

*   静态的序列，只有区间查询。
*   一般维度只有 $2$。

##  基础问题

*   给一个长为 $n$ 的序列，有 $m$ 次查询，每次查区间 $[l, r]$ 中值在 $[x, y]$ 内的元素个数。

### 分析

*   这个问题叫做二维数点。
*   我们可以发现等价于我们要查询一个二维平面上矩形内的和。
*   这里讲一下这个问题最简单的处理方法，扫描线 + 树状数组。
*   这个问题是一个静态的二维问题。
*   我们通过扫描线可以将静态的二维问题转换为动态的一维问题。
*   维护动态的一维问题就使用数据结构维护序列，这里可以使用树状数组。
*   这里可以将询问的矩形差分为 3-side 矩形来减少问题的自由度。
*   总时间复杂度 $\mathcal O((n + m) \log n)$。

##  基础问题

*   给一个二维平面，上面有 $n$ 个矩形，每个矩形坐标 $[1, n]$。
*   有 $m$ 次查询，每次查询一个二维平面上的点被多少矩形包含。

### 分析

*   我们通过扫描线可以将静态的二维问题转换为动态的一维问题。
*   维护动态的一维问题就使用数据结构维护序列。
*   那在这道题中，我们扫描线每进入一个矩形的时候就进行区间 $+ 1$，走出一个矩形的时候就进行区间 $- 1$。
*   扫描线上的数据结构维护的是当前 $x$ 坐标下，每个 $y$ 坐标被多少矩形包含。

##  P1972 [SDOI2009] HH的项链

*   给定一个长为 $n$ 的序列，$m$ 次查询区间中有多少不同的数。

### 分析

*   这类问题我们可以考虑推导性质。
*   之后使用扫描线枚举所有右端点，数据结构维护每个左端点的答案的方法来实现。
*   我们也可以将问题转换到二维平面上。
*   变为一个矩形查询信息的问题。

### Solution1

*   对于每个位置 $i$，预处理出 $pre[i]$ 表示 $i$ 左边离 $i$ 最近的 $j$ 满足 $a[i] == a[j]$。
*   然后查询区间中的不同数，我们可以只把每个数在区间中最后一次出现时统计进去。
*   扫一遍数组，扫到每个右端点的时候，维护每个左端点对应的答案。
*   我们想对区间中每个出现的数，恰好统计一次。
    *   如果一个数在区间中第一次出现，则上次的出现位置 $pre[i] \lt l$；
    *   如果一个数在区间中不是第一次出现，则上次的出现位置 $pre[i] \ge l$。
*   问题变为区间 $[l, r]$ 中，满足 $pre[i] \lt l$ 的 $i$ 个数。
*   我们可以差分，将区间 $[l, r]$ 差分为前缀 $[1, r]$ 减去前缀 $[1, l - 1]$。
*   问题变为前 $x$ 个数中 $pre[i] \lt l$ 的 $i$ 个数。
*   考虑将询问离线，即先读入所有询问，后记录下来。
*   假设一个询问是对于区间 $[l, r]$ 的，则我们在 $r$ 位置记录一下，我们这里有个询问，查询的是 $\lt l$ 的元素个数，对答案贡献是正的。
*   在 $l - 1$ 位置记录一下，我们这里有个询问，查询的是 $\lt l$ 的元素个数，对答案贡献是负的。
*   于是我们从 $1$ 扫到 $n$，假设现在扫到了 $i$，我们开一个值域上的树状数组存下前 $i$ 个元素。
*   每次从 $i$ 到 $i + 1$，即先将 $i + 1$ 位置的值插入值域树状数组。
*   然后进行这个位置上的查询。
*   注意一个位置上可能有多个查询，但总共的查询次数是 $\mathcal O(m)$ 的总时间复杂度 $O((n + m) \log n)$。

### Solution2

*   其实我们还可以从另一个角度考虑这个问题
我们枚举每个右端点，数据结构维护每个左端点的答案。
*   每次右端点从 $r$ 变成 $r + 1$ 的时候，考虑 $a[r + 1] = y$ 这个值上次出现的位置为序列上的 $x$ 位置，即 $a[x] = y$。
*   这个区间 $[x + 1, r + 1]$ 中原本没有 $y$，现在有 $y$ 了。
*   于是进行一个区间加。
*   数据结构维护的每个单点值就是对当然右端点为 $r$，每个左端点和当前右端点构成的区间的答案。

##  HDU5654 xiaoxin and his watermelon candy

*   给一个长为 $n$ 的序列，有 $m$ 次询问，每次询问给一个区间 $[l, r]$。
*   求区间内有多少不同的三元组 $(a_i, a_j, a_k)$ 满足：
    *   $i = j - 1, j = k - 1$；
    *   $a_i \le a_j \le a_k$。
*   两个三元组 $(a, b, c)$，$(d, e, f)$ 不同当且仅当 $a \neq d$ 或 $b \neq e$ 或 $c \neq f$。

### Solution

*   只有 $\mathcal O(n)$ 个可能的三元组，先全部找出来。
*   对每个三元组，找左边第一个和其完全相同的三元组。
*   然后问题转换为区间颜色数。
*   总时间复杂度 $\mathcal O((n + m) \log n)$。

##  CF1000F One Occurrence

*   给定长为 $n$ 的序列，$m$ 次查询区间中有多少值只出现一次。

### 分析

*   这道题我们使用二维平面的方法分析。
*   思路就是将询问区间 $[l, r]$ 看做是二维平面上的一个点。
*   然后计算序列中每个位置对哪些询问有贡献。
*   之后变成先进行一些矩形加，后进行一些单点求值的问题。