---
layout: post
title:  ABCF
date:   2023-05-09
categories: course haoma
---

## $^*$ABC181F Silver Woods

合法答案最大化，考虑二分答案。

关于 `check`，记当前答案为 $r$，则 $d = 2r$，当 $dis(i, j) \lt d$ 时，不能从点 $i, j$ 间经过。

考虑什么情况下不能从 $(- \infty, 0)$ 移动到 $(\infty, 0)$，即满足上述条件的点对构成的连通块使得上界 $(x, 100)$ 与下界 $(x, -100)$ 连通。

注意上下界也应当看作钉子处理，比较距离时只考虑 $y$ 轴即可。

记 $w = maxR = 100$，时间复杂度 $\mathcal O(n^2 \log w \alpha(n))$。

```cpp
    dbl l = 0;
    dbl r = 100;
    while (r - l > eps) {
        dbl mid = (l + r) / 2;
        if (check(mid * 2)) l = mid;
        else r = mid;
    }
```

```cpp
bool check(dbl d) {
    DSU.Init();
    for (int i = 1; i <= n; i++) if (100 - y[i] < d) DSU.Union(n + 1, i);
    for (int i = 1; i <= n; i++) if (y[i] + 100 < d) DSU.Union(0, i);
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (dis2(i, j) < d * d) {
                DSU.Union(i, j);
            }
        }
    }
    return DSU.Find(0) != DSU.Find(n + 1);
}
```

## ABC183F Confluence

并查集套 `std::multiset` 维护集合与班级，采用启发式合并。

```cpp
    for (int i = 1; i <= n; i++) DSU.node[i].s.insert(c[i]);
```

```cpp
    void Union(int u, int v) {
        u = Find(u);
        v = Find(v);
        if (u == v) return;
        if (node[u].s.size() > node[v].s.size()) std::swap(u, v);
        node[u].fa = v;
        for (auto w : node[u].s) node[v].s.insert(w);
        return;
    }
```

```cpp
            std::cout << DSU.node[DSU.Find(x)].s.count(y) << '\n';
```

TLE 两个点。

不难发现时间复杂度瓶颈在于一个班级 $C$ 在一次 `Union` 中被枚举了 $\lvert C \rvert$ 次，且单次贡献为 $1$。

使用 `std::set` 维护集合内班级类型，使用 `std::map` 维护班级内学生数量，优化为枚举 $1$ 次且单次贡献为 $\lvert C \rvert$。

```cpp
    for (int i = 1; i <= n; i++) DSU.node[i].m[c[i]] = 1;
    for (int i = 1; i <= n; i++) DSU.node[i].s.insert(c[i]);
```

```cpp
    void Union(int u, int v) {
        u = Find(u);
        v = Find(v);
        if (u == v) return;
        if (node[u].s.size() > node[v].s.size()) std::swap(u, v);
        node[u].fa = v;
        for (auto w : node[u].s) {
            node[v].s.insert(w);
            node[v].m[w] += node[u].m[w];
        }
        return;
    }
```

```cpp
            std::cout << DSU.node[DSU.Find(x)].m[y] << '\n';
```

## ABC184F Programming Contest

注意到 $n$ 很小，考虑搜索。

可以考虑从大往小搜，并使用后缀和优化。

```cpp
    std::sort(a + 1, a + n + 1);
    std::reverse(a + 1, a + n + 1);
    for (int i = n; i >= 1; i--) s[i] = s[i + 1] + a[i];
    DFS(0, 1);
```

```cpp
void DFS(lxl now, int cur) {
    if (now > t) return;
    if (now + s[cur] <= ans) return;
    ans = std::max(ans, now);
    if (cur > n) return;
    DFS(now + a[cur], cur + 1);
    DFS(now, cur + 1);
    return;
}
```

TLE 一个点。

使用折半搜索加二分优化 $\mathcal O(2^n)$ 为 $\mathcal O(2^{\frac{n}{2}} \log 2^{\frac{n}{2}})$。

```cpp
void DFS(vlc &res, lxl now, int cur) {
    if (now > t) return;
    res.push_back(now);
    if (cur > n) return;
    DFS(res, now + a[cur], cur + 2);
    DFS(res, now, cur + 2);
    return;
}
```

```cpp
    DFS(resl, 0, 1);
    DFS(resr, 0, 2);
    std::sort(resl.begin(), resl.end());
    std::sort(resr.begin(), resr.end());
    resl.erase(std::unique(resl.begin(), resl.end()), resl.end());
    resr.erase(std::unique(resr.begin(), resr.end()), resr.end());
    for (int i = 0; i < resl.size(); i++) {
        int j = std::upper_bound(resr.begin(), resr.end(), t - resl[i]) - resr.begin() - 1;
        if (j >= 0) ans = std::max(ans, resl[i] + resr[j]);
    }
```

## ABC185F Range Xor Query

一眼线段树板子，贺！