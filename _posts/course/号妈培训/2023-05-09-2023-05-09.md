---
layout: post
title:  ABCF
date:   2023-05-09
categories: course haoma
---

## $^*$ABC181F Silver Woods

合法答案最大化，考虑二分答案。

关于 `check`，记当前答案为 $r$，则 $d = 2r$，当 $dis(i, j) \lt d$ 时，不能从点 $i, j$ 间经过。

_考虑什么情况下不能从 $(- \infty, 0)$ 移动到 $(\infty, 0)$，即满足上述条件的点对构成的连通块使得上界 $(x, 100)$ 与下界 $(x, -100)$ 连通。_

注意上下界也应当看作钉子处理，比较距离时只考虑 $y$ 轴即可。

记 $w = maxR = 100$，时间复杂度 $\mathcal O(n^2 \log w \alpha(n))$。

```cpp
    dbl l = 0;
    dbl r = 100;
    while (r - l > eps) {
        dbl mid = (l + r) / 2;
        if (check(mid * 2)) l = mid;
        else r = mid;
    }
```

```cpp
bool check(dbl d) {
    DSU.Init();
    for (int i = 1; i <= n; i++) if (100 - y[i] < d) DSU.Union(n + 1, i);
    for (int i = 1; i <= n; i++) if (y[i] + 100 < d) DSU.Union(0, i);
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (dis2(i, j) < d * d) {
                DSU.Union(i, j);
            }
        }
    }
    return DSU.Find(0) != DSU.Find(n + 1);
}
```

## ABC182F Valid payments

数学不会。

## $^*$ABC183F Confluence

并查集套 `std::multiset` 维护集合与班级，采用启发式合并。

```cpp
    for (int i = 1; i <= n; i++) DSU.node[i].s.insert(c[i]);
```

```cpp
    void Union(int u, int v) {
        u = Find(u);
        v = Find(v);
        if (u == v) return;
        if (node[u].s.size() > node[v].s.size()) std::swap(u, v);
        node[u].fa = v;
        for (auto w : node[u].s) node[v].s.insert(w);
        return;
    }
```

```cpp
            std::cout << DSU.node[DSU.Find(x)].s.count(y) << '\n';
```

TLE 两个点。

_不难发现时间复杂度瓶颈在于一个班级 $C$ 在一次 `Union` 中被枚举了 $\lvert C \rvert$ 次，且单次贡献为 $1$。_

_使用 `std::set` 维护集合内班级类型，使用 `std::map` 维护班级内学生数量，优化为枚举 $1$ 次且单次贡献为 $\lvert C \rvert$。_

```cpp
    for (int i = 1; i <= n; i++) DSU.node[i].m[c[i]] = 1;
    for (int i = 1; i <= n; i++) DSU.node[i].s.insert(c[i]);
```

```cpp
    void Union(int u, int v) {
        u = Find(u);
        v = Find(v);
        if (u == v) return;
        if (node[u].s.size() > node[v].s.size()) std::swap(u, v);
        node[u].fa = v;
        for (auto w : node[u].s) {
            node[v].s.insert(w);
            node[v].m[w] += node[u].m[w];
        }
        return;
    }
```

```cpp
            std::cout << DSU.node[DSU.Find(x)].m[y] << '\n';
```

## $^*$ABC184F Programming Contest

注意到 $n$ 很小，考虑搜索。

可以考虑从大往小搜，并使用后缀和优化。

```cpp
    std::sort(a + 1, a + n + 1);
    std::reverse(a + 1, a + n + 1);
    for (int i = n; i >= 1; i--) s[i] = s[i + 1] + a[i];
    DFS(0, 1);
```

```cpp
void DFS(lxl now, int cur) {
    if (now > t) return;
    if (now + s[cur] <= ans) return;
    ans = std::max(ans, now);
    if (cur > n) return;
    DFS(now + a[cur], cur + 1);
    DFS(now, cur + 1);
    return;
}
```

TLE 一个点。

_使用折半搜索加二分优化 $\mathcal O(2^n)$ 为 $\mathcal O(\frac{n}{2} 2^{\frac{n}{2}})$。_

```cpp
void DFS(vlc &res, lxl now, int cur) {
    if (now > t) return;
    res.push_back(now);
    if (cur > n) return;
    DFS(res, now + a[cur], cur + 2);
    DFS(res, now, cur + 2);
    return;
}
```

```cpp
    DFS(resl, 0, 1);
    DFS(resr, 0, 2);
    std::sort(resl.begin(), resl.end());
    std::sort(resr.begin(), resr.end());
    resl.erase(std::unique(resl.begin(), resl.end()), resl.end());
    resr.erase(std::unique(resr.begin(), resr.end()), resr.end());
    for (int i = 0; i < resl.size(); i++) {
        int j = std::upper_bound(resr.begin(), resr.end(), t - resl[i]) - resr.begin() - 1;
        if (j >= 0) ans = std::max(ans, resl[i] + resr[j]);
    }
```

## ABC185F Range Xor Query

一眼线段树板子，贺！

## ABC186F Rook on Grid

没有翻译。

没有题解。

好吧自己做出来了。

行和列分开处理。

*   $r[i]$ 表示第 $i$ 行最小障碍物坐标
*   $c[i]$ 表示第 $j$ 列最小障碍物坐标

考虑先往下走再往右走，走到 $(i, 1)$ 时，贡献为 $r[i] - 1$，当 $r[i] = 1$ 时无法继续往下走。

找到第一个 $r[i] = 1$ 的 $i$，$(i, h]$ 行换一种方式处理：将 $i$ 加入第 $r[i] + 1$ 列的标记区。

一个行标记 $x$ 出现在第 $y$ 列的标记区，表示第 $x$ 行被障碍物阻挡，且第 $x$ 行的 $[y, w]$ 部分需要通过先往右走再往下走计算贡献。

处理完行，开始考虑列。

考虑先往右走再往下走，走到 $(1, i)$ 时，贡献为标记区前缀并集内小于 $c[i]$ 的元素个数，当 $c[i] = 1$ 时无法继续往右走。

可能文字无法很好的表述，可以画图模拟尝试理解。

计算标记前缀并集元素个数可以使用权值线段树维护。

```cpp
int main() {
    std::cin >> h >> w >> m;
    for (int i = 1; i <= h; i++) r[i] = w + 1;
    for (int i = 1; i <= w; i++) c[i] = h + 1;
    for (int i = 1; i <= m; i++) {
        std::cin >> x >> y;
        r[x] = std::min(r[x], y);
        c[y] = std::min(c[y], x);
    }
    bool flag = true;
    for (int i = 1; i <= h; i++) {
        if (flag) {
            ans += r[i] - 1;
            if (r[i] <= w) t[r[i] + 1].push_back(i);
            if (r[i] == 1) flag = false;
        } else {
            t[2].push_back(i);
        }
    }
    for (int i = 1; i <= w; i++) {
        if (c[i] == 1) break;
        for (auto j : t[i]) SGT.Add(1, 1, h, j, 1);
        ans += SGT.Ask(1, 1, h, 1, c[i] - 1);
    }
    std::cout << ans << '\n';
    return 0;
}
```

## ABC187F Close Group

第一眼：什么神仙题？

第二眼：$n = 18$ 直接状压。

```cpp
bool check(int s) {
    vic q;
    for (int i = 1; i <= n; i++) {
        if (s & (1 << i)) {
            q.push_back(i);
        }
    }
    for (int i = 0; i < q.size(); i++) {
        for (int j = i + 1; j < q.size(); j++) {
            if (a[q[i]][q[j]] == 0) {
                return false;
            }
        }
    }
    return true;
}
```

```cpp
    for (int i = 2; i < (1 << (n + 1)); i++) {
        if (check(i)) {
            f[i] = 1;
        } else {
            for (int j = i; j; j = (j - 1) & i) {
                if (j == i) continue;
                int k = i ^ j;
                f[i] = std::min(f[i], f[j] + f[k]);
            }
        }
    }
    std::cout << f[(1 << (n + 1)) - 1] << '\n';
```

## ABC188F +1-1x2

倒序记忆化搜索。

```cpp
lxl DFS(lxl now) {
    if (now == x) return 0;
    if (now < x) return x - now;
    if (f[now]) return f[now];
    f[now] = now - x;
    if (now & 1) f[now] = std::min(f[now], std::min(DFS(now - 1), DFS(now + 1)) + 1);
    else f[now] = std::min(f[now], DFS(now / 2) + 1);
    return f[now];
}
```

## ABC189F Sugoroku2

期望 DP 不会。

## ABC190F Shift and Inversions

先求一遍逆序对数，然后考虑最左侧元素移至右侧的影响。

```cpp
    for (int i = 1; i <= n; i++) {
        res += SGT.Ask(1, 0, n, a[i], n);
        SGT.Add(1, 0, n, a[i], 1);
    }
    for (int i = 1; i <= n; i++) {
        std::cout << res << '\n';
        res += n - a[i] - a[i] - 1;
    }
```