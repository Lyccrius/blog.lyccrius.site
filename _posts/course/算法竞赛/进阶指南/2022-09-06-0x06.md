---
layout: post
title: "《算法竞赛进阶指南》0x06 倍增"
date:   2022-09-06
categories: course sfjs jjzn
---

倍增，字面意思就是 “成倍增长”。

这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间在 $$2$$ 的整数次幂位置上的值作为代表。

当需要其他位置上的值时，我们通过 “任意整数可以表示成若干个 $$2$$ 的次幂项的和” 这一性质，使用之前求出的代表值拼成的所需的值。

所以倍增算法也要求我们递推的问题的状态空间关于 $$2$$ 的次幂具有可划分性。

“倍增” 与 “二进制划分” 两个思想互相结合，降低了求解很多问题的时间与空间复杂度。

我们之前学习的快速幂其实就是 “倍增” 与 “二进制划分” 思想的一种体现。

试想一个这样的问题：

> 给定一个长度为 $$N$$ 的数列 $$A$$，然后进行若干次询问，每次给定一个整数 $$T$$，求出最大的 $$k$$，满足 $$\sum_{i = 1}^k{A[i] \leq T}$$。你的算法必须是在线的（必须即使回答每一个询问，不能等待收到所有询问后再统一处理），假设 $$0 \leq T \leq \sum_{i = 1}^N{A[i]}$$。

最朴素的做法当然是从前向后枚举 $$k$$，每次询问花费的时间与答案的大小有关，最坏情况下为 $$\mathcal{O}(N)$$。

如果我们能够先花费 $$\mathcal{O}(N)$$ 的时间预处理 $$A$$ 数组的前缀和数组 $$S$$，就可以二分 $$k$$ 的位置，比较 $$S[k]$$ 与 $$T$$ 的大小来确定二分上下界的变化，每次询问花费的时间都是 $$\mathcal{O}(\log{N})。

这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数 $$T$$ 都非常小，造成答案 $$k$$ 也非常小，那么该算法可能还不如从前往后枚举更优。

我们可以设计这样一种倍增算法。

1. 令 $$p = 1$$，$$k = 0$$，$$sum = 0$$。
2. 比较 “$$A$$ 数组中 $$k$$ 之后的 $$p$$ 个数的和” 与 $$T$$ 的关系，也就是说，如果 $$sum + S[k + p] - S[k] \leq T$$，则令 $$sum += S[k + p] - S[k]$$，$$k += p$$，$$p *= 2$$，即累加上这 $$p$$ 个数的和，然后把 $$p$$ 的跨度增长一倍。  
   如果 $$sum + S[k + p] - S[k] > T$$，则令 $$p /= 2$$。
3. 重复上一步，直到 $$p$$ 的值变为 $$0$$，此时 $$k$$ 就是答案。

这个算法始终在答案大小的范围内实施 “倍增” 与 “二进制划分” 思想，通过若干长度为 $$2$$ 的次幂的区间拼成最后的 $$k$$，时间复杂度级别为答案的对数，能够应对 $$T$$ 的各种大小情况。

### 【例题】<a href="https://lycccrius.github.io/solution/acwing/109" target="_blank">Genius ACM</a>

## ST 算法竞赛进阶指南
在 RMQ 问题（区间最值问题）中，著名的 $$ST$$ 算法就是倍增的产物。

给定一个长度为 $$N$$ 的数列 $$A$$，ST 算法能在 $$\mathcal{O}(N \log{N})$$ 时间的预处理后，以 $$\mathcal{O}(1)$$ 的时间复杂度在线回答 “数列 $$A$$ 中下标在 $$l \sim r$$ 之间的数的最大值是多少” 这样的区间最值问题。

一个序列的字区间显然有 $$O(N^2)$$ 个，