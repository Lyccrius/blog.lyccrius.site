---
layout: post
title:  1.3 高效算法设计举例
date:   2022-11-15
categories: course sfjs rmjd-xlzn
---

## 例题17 [$\color{#F39C12}年龄排序$](https://www.luogu.com.cn/problem/UVA11462)

数据太大，但整数范围很小，可以用计数排序方法。

## 例题18 [$\color{#FFC016}开放式学分制$](https://www.luogu.com.cn/problem/UVA11078)

$\mathcal{O} (n^2)$ 在 $n = 100~000$ 的规模面前无能为力。对于每个固定的 $j$，我们应该选择的是小于 $j$ 且 $A_i$ 最大的 $i$，而和 $A_j$ 的具体数值无关。这样，我们从小到大枚举 $j$，顺便维护 $A_i$ 的最大值即可。

## 例题19 [$\color{#3498DA}计算器谜题$](https://www.luogu.com.cn/problem/UVA11549)

计算器显示出的数将出现循环，所以不妨一个一个地模拟，每次判断新得到的数是否以前出现过。$k$ 的范围太大，开不下数组 $vis$。在这种情况下，一个简便的方法是利用 $\text{STL}$ 的集合。

当然，也可以用哈希表，但和 $\text{set}$ 一样，空间开销比较大。

假设有两个小孩子在一个 “可以无限向前跑” 的跑道上赛跑，同时出发，但其中一个小孩的速度是另一个的两倍。如果跑道是直的，跑得快的小孩永远在前面；但如果跑道有环，则跑得快的小孩将 “追上” 跑得慢的小孩。

这个算法称为 $\text{Floyd}$ 判圈算法，不仅将空间复杂度将为 $\mathcal{O} (1)$，运行时间也将缩短。

## 例题20 [$\color{#9D3DCF}流星$](https://www.luogu.com.cn/problem/UVA1398)

流星的轨迹是没有直接意义的，有意义的只是每个流星在照相机视野内出现的时间段。给出 $n$ 个开区间 $(L_i, R_i)$，求出一个数 $t$，使得包含它的区间数最多。

维护信息，而不是重新计算。

把 “扫描线碰到一个左端点” 和 “扫描线碰到一个右端点” 看成是事件。先按照从左到右的顺序给事件排序，对于位置相同的时间，把右端点事件排在前面。每遇到一个 “左端点事件”，计数器加 $1$；每遇到一个 “右端点事件”，计数器减 $1$。这里的计数器保存的正是我们要维护的信息：扫描线和多少个开区间相交。

## 例题21 [$\color{#3498DA}子序列$](https://www.luogu.com.cn/problem/UVA1121)

令 $B_i = A_1 + A_2 + \cdots + A_i$，规定 $B_0 = 0$，则可以在 $\mathcal{O} (1)$ 时间内求出子序列的值：$A_i + A_{i + 1} + \cdots + A_j = B_j - B_{i - 1}$。

对于终点 $j$，我们的目标是要找到一个让 $B_j - B_{i - 1} \ge S$，且 $i$ 尽量大（$i$ 越大，序列长度 $j - i + 1$ 就越小）的值，也就是找一个让 $B_{i - 1} \le B_j - S$ 最大的 $i$。

由于 $j$ 是递增的，$B_j$ 也是递增的，所以 $B_{i - 1} \le B_j - S$ 的右边也是递增的。换句话说，满足条件的 $i$ 也是递增的。

整个算法的时间复杂度为 $\mathcal{O} (n)$。

## 例题22 [$\color{#3498DA}最大子矩阵$](https://www.luogu.com.cn/problem/UVA1330)

把每个格子向上延伸的连续空格看成一条悬线，并用 $\text{up} (i, j)$、$\text{left} (i, j)$、$\text{right} (i, j)$ 表示格子 $(i, j)$ 的悬线长度以及该选线向左、向右运动的 “运动极限”。

每个格子 $(i, j)$ 对应着一个以 $i$ 行为下界、高度为 $\text{up} (i, j)$，左右边界分别为 $\text{left} (i, j)$ 和 $\text{right} (i, j)$ 的矩形。这些矩形中面积最大的就是题目所求。

当第 $i$ 行第 $j$ 列不是空格时，$3$ 个数组的值均为 $0$，否则 $\text{up} (i, j) = \text{up} (i - 1, j) + 1$，$\text{left} (i, j) = \max \\{ \text{left} (i - 1, j), \text{lo} + 1 \\}$。其中 $\text{lo}$ 是第 $i$ 行中，第 $j$ 列左边的最近障碍格的编号。$\text{right}$ 也可以同理计算，但需要从右往左计算，因为要维护第 $j$ 列右边最近的障碍格的列编号 $\text{ro}$。

时空复杂度均为 $\mathcal{O} (m n)$。

## 例题23 [$\color{#9D3DCF}遥远的星河$](https://www.luogu.com.cn/problem/UVA1398)

除非所有输入点都在同一行或者同一列上（此时答案为 $n$），最优矩形的 $4$ 条边都至少有一个点。枚举 $4$ 条边界所穿过的点，然后统计点数，时间复杂度为 $\mathcal{O} (n^5)$。

考虑部分枚举，即只枚举矩形的上下边界，用其他方法确定左右边界。

对于竖线 $i$，用 $\text{left} [i]$ 表示竖线左边位于上下边界上的点数，$\text{on} [i]$ 和 $\text{on2} [i]$ 表示竖线上位于上下边界之间的点数，$\text{on} [i]$ 不统计位于上下边界上的点数，而 $\text{on2} [i]$ 要统计。这样，给定左右边界 $i$ 和 $j$ 时，矩形边界上的点数为 $\text{left} [j] - \text{left} [i] + \text{on} [i] + \text{on2} [j]$。当右边界 $j$ 确定时，$\text{on} [i] - \text{left} [i]$ 应最大。

枚举完上下边界后，花 $\mathcal{O} (n)$ 时间按照从左到右的顺序扫描一边所有点，计算 $\text{left}$、$\text{on}$、$\text{on2}$ 数组，然后枚举右边界 $j$，同时维护 $\text{on} [i] - \text{left} [i] ~ (i \lt j)$ 的最大值。

## 例题24 [$\color{#3498DA}废料堆$](https://www.luogu.com.cn/problem/UVA10755)

解决高维问题的常见策略是降维。先来看看本题的二维情况：给定一个数字矩阵，求一个和最大的连续子矩阵。我们枚举上下边界 $y_1$ 和 $y_2$（规定 $x$ 从左到右递增，$y$ 从上到下递增），则问题转化为了一位问题。

设 $S(x, y)$ 为满足 $x' \le x, y' \le y$ 的所有 $A[x'][y']$ 之和，即以 $(x, y)$ 为右下角的矩形中所有元素之和，这样所有子矩形的元素之和由 $4$ 个 “前缀矩形” 的元素之和经过加减之后得到。

这个关系也可以用来递推出整个 $S$ 数组，即

$$S(0, y) = S(x, 0) = 0$$

$$S(x, y) = S(x - 1, y) + S(x, y - 1) - S(x - 1, y - 1) + A[x][y]$$

上述方法可以很方便地推广到三位情形，时间复杂度为 $\mathcal{O} (n^5)$。

## 例题25 [$\color{#3498DA}侏罗纪$](https://www.luogu.com.cn/problem/UVA1326)

在一个字符串中，每个字符出现的次数本身是无关紧要的，重要的只是这些次数的奇偶性，因此想到用一个二进制的位表示一个字母（$1$ 表示出现奇数次，$0$ 表示出现偶数次）。

问题转化为求尽量多的数，使得它们的 $\text{xor}$ （异或）值为 $0$。

注意到 $\text{xor}$ 值为 $0$ 的两个整数必需完全相等，可以把字符串分成两部分：首先计算前 $n / 2$ 个字符串所能得到的所有 $\text{xor}$ 值，并将其保存到一个映射 $S$（$\text{xor}$ 值 $\to$ 前 $n / 2$ 个字符串的一个子集）中；然后枚举后 $n / 2$ 个字符串所能得到的所有 $\text{xor}$ 值，并每次都在 $S$ 中查找。

这样的策略称为中途相遇法。