---
layout: post
title:  Part7 数据结构
date:   2023-01-20
categories: course sfoi
---

> 灵活地运用数据结构可以高效地查询并处理需要的信息。

## Part 7.1 链表

> 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。

## Part 7.2 栈

> 栈，是一种后进先出（FILO）的数据结构。

## Part 7.3 队列

> 队列，是一种先进先出（FIFO）的数据结构。

## Part 7.4 并查集

> 并查集常用于处理一些不相交集合的合并和查询问题。

## Part 7.5 二叉堆

> 二叉堆是一棵完全二叉树，堆中某个节点的值总是不大于或不小于其父节点的值。

## Part 7.6 ST表

> ST表可以离线查询区间最值。

### [$\color{#9D3DCF} \text{P5344}$](https://www.luogu.com.cn/problem/P5344) 【XR-1】逛森林



### [$\color{#9D3DCF} \text{P2048}$](https://www.luogu.com.cn/problem/P2048) [NOI2010] 超级钢琴

定义数对 $(i, j)$ 为 $A[i \sim j]$ 所构成的超级和弦，且保证 $L \le j - i + 1 \le R$。

定义 $B[]$ 为 $A[]$ 的前缀和，则和弦 $(i, j)$ 的美妙程度为 $B[j] - B[i - 1]$。

定义一个集合 $S$ 称为美妙程度前 $k$ 大的和弦预备役，我们用优先队列来维护它以求得答案最值。

对于一个 $i$，在所有符合条件 的 $j$ 中，选择一个 $j$ 使得 $B[j] - B[i - 1]$ 最大。由于 $B[i - 1]$ 一定，可转化为 $B[]$ 上的 $\text{RMQ}$ 问题求解。

要求前 $k$ 大不同的超级和弦之和，想到 [P2085 最小函数值](https://www.luogu.com.cn/problem/P2085)。定义一个局面为各个函数的自变量分布情况。对于一个函数，将当前局面下可能产生最小函数值的自变量 $x$ 及其因变量 $y$ 加入优先队列。每次取出一个最小函数值并将其输出，然后重新考虑对于该函数的哪些 $x$ 可能产生最小函数值。

沿用与之相同的思路：定义一个局面为各个和弦的选择情况。对于一个 $i$，将当前局面下可能成为预备役中元素的和弦 $(i, j)$ 加入优先队列。每次取出一个和弦并将其贡献统计到答案中，然后重新考虑对于该和弦的 $i$ 可能与哪些 $j$ 成为预备役中元素。

对于一个局面中的 $i$，若 $j$ 已经对答案产生贡献，则 $j'$ 可能出现在 $[i + L - 1, j - 1]$ 及 $[j + 1, i + R - 1]$。再次转化为 $\text{RMQ}$ 问题。重复此过程，直至对答案产生贡献的和弦个数为 $k$。

```cpp
#include <iostream>
#include <queue>
#include <cmath>

void promote() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
    return;
}

typedef long long lxl;

const int maxN = 5e5;
const int maxK = 5e5;
const int logN = 19;

int n, k, L, R;
int A[maxN + 10];
int B[maxN + 10];

struct SpareTable {
    int f[maxN + 10][logN + 5];
    int g[maxN + 10][logN + 5];

    void Init() {
        for (int i = 1; i <= n; i++) f[i][0] = B[i];
        for (int i = 1; i <= n; i++) g[i][0] = i;
        for (int p = 1; p <= logN; p++) {
            for (int i = 1; i <= n; i++) {
                if (i + (1 << p) - 1 > n) break;
                int j = i + (1 << (p - 1));
                if (f[i][p - 1] > f[j][p - 1]) {
                    f[i][p] = f[i][p - 1];
                    g[i][p] = g[i][p - 1];
                } else {
                    f[i][p] = f[j][p - 1];
                    g[i][p] = g[j][p - 1];
                }
            }
        }
        return;
    }

    int Query(int l, int r) {
        int p = std::log2(r - l + 1);
        r = r - (1 << p) + 1;
        if (f[l][p] > f[r][p]) return g[l][p];
        else return g[r][p];
    }
} ST;

struct Node {
    int i;
    int g;
    int l;
    int r;
    int res;

    bool operator<(const Node &other) const {
        return res < other.res;
    }
};

std::priority_queue<Node> q;
lxl ans;

int main() {
    promote();
    std::cin >> n >> k >> L >> R;
    for (int i = 1; i <= n; i++) std::cin >> A[i];
    for (int i = 1; i <= n; i++) B[i] = B[i - 1] + A[i];
    ST.Init();
    for (int i = 1; i + L - 1 <= n; i++) {
        int l = i + L - 1;
        int r = std::min(i + R - 1, n);
        int g = ST.Query(l, r);
        q.push((Node) {i, g, l, r, B[g] - B[i - 1]});
    }
    while (k--) {
        Node node = q.top();
        q.pop();
        ans += node.res;
        if (node.g > node.l) {
            int g = ST.Query(node.l, node.g - 1);
            q.push((Node) {node.i, g, node.l, node.g - 1, B[g] - B[node.i - 1]});
        }
        if (node.g < node.r) {
            int g = ST.Query(node.g + 1, node.r);
            q.push((Node) {node.i, g, node.g + 1, node.r, B[g] - B[node.i - 1]});
        }
    }
    std::cout << ans << '\n';
    return 0;
}
```