---
layout: post
title:  第9章 树
date:   2023-01-19
categories: course srqc jjp
---

树结构广泛存在于我们的日常生活中，刻画了一种广泛存在的事物关系。

树结构是一种常见的数据组织形式，体现的关系是一种 “一对多” 的关系。

## 树的性质与遍历

### 例1：公司的组织架构

树是一种特殊的图，树必须是**连通的**。

### 例2：[P5908 猫猫和企鹅](https://www.luogu.com.cn/problem/P5908)

* **解法**1：深度优先遍历
* **解法**2：广度优先遍历

在一些题目中，具有特殊形态的树也有一些特殊的名称，通常也伴随着特殊的性质。许多题目会提供特殊树的部分分，可以把树上问题简化为序列问题或者是层数为 $2$ 树的问题，进而得到一些分数。

1. **链**：如果一棵树除了最后一个结点，每个结点都只有一个子结点，可以发现此时树退化成了线性表。当树退化成链时，从根结点开始采取深度优先遍历会产生最高的递归层数（与结点数相同），通常会用检验程序是否会递归溢出，即所谓的 “爆栈”。但也可以将树上问题直接转变成序列问题，使问题简化。
2. **“菊花图”**：树的层数为 $2$，即除了根结点外每个结点都直接连向根结点。当树的形态是 “菊花图” 时，某些算法会多次扫描点点连边，产生较高的复杂度。但正是因为这种树的深度为 $2$，故也可能存在一些可以暴力求解的性质。

## 树的直径与重心

树作为一种特殊的结构，其自身也具有一些特殊的性质来帮助解决一些树上问题。

### 例3：[P1099 [NOIP2007 提高组] 树网的核](https://www.luogu.com.cn/problem/P1099)

### 例4：[P1395 会议](https://www.luogu.com.cn/problem/P1395)

在一棵树中，如果我们选择某个结点为根，可以使得它的所有子树中最大的子树最小，那么这个结点就被称作这棵树的**重心**。从这个定义中，可以推出重心的四个性质。

1. 以重心为树根时，所有子树的大小不超过全树大小的一半。
2. 树中所有点到某个点到距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
3. 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
4. 在一棵树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

对于求每个点的子树大小，假设将点 $u$ 的子树大小记录进数组 $size[u]$ 中，那么可以得到以下的流程，设当前进入的点为 $u$：

1. 初始化 $size[u] = 1$。
2. 逐一枚举 $u$ 的所有子结点，然后递归 $\text{DFS}$，进入这些子结点。
3. 回溯回到 $u$ 的时候，将该子结点的 $size$ 累加进 $size[u]$ 中。

```cpp
void DFS(int u, int from) {
    vertex[u].size = 1;
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        if (v == from) continue;
        DFS(v, u);
        vertex[u].size += vertex[v].size;
    }
    return;
}
```

记这棵树总的结点为 $n$，在计算出 $size[u]$ 之后，可以得到 $n - size[u]$ 就是根方向子树的大小。

令 $f[u]$ 为把 $u$ 作为根结点，其最大的子树的大小。在遍历的过程中同时统计 $f$ 数组的最小值和对应的结点编号，最后留下的结点编号就是树的重心。

```cpp
void DFS(int u, int from) {
    vertex[u].size = 1;
    vertex[u].dist = 0;
    vertex[u].f = 0;
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        if (v == from) continue;
        DFS(v, u);
        vertex[u].size += vertex[v].size;
        vertex[u].dist += vertex[v].size + vertex[v].dist;
        vertex[u].f = std::max(vertex[u].f, vertex[v].size);
    }
    vertex[u].f = std::max(vertex[u].f, n - vertex[u].size);
    if (z > vertex[u].f || (z == vertex[u].f && u <= x)) {
        z = vertex[u].f;
        y = vertex[u].dist;
        x = u;
    }
    return;
}
```

## 最近公共祖先

### 例5：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

**最近公共祖先**（$\text{Lowest Common Ancestor, LCA}$）是讨论树上两个点的联系时最重要的一个概念。从图上来看，最近公共祖先是从树根到这两个结点的路径开始分叉的起点，在讨论树上的一些路径问题时，她是一个非常关键的路径分界点。

假设目前要求点 $u$ 和 $v$ 的最近公共祖先。

1. 首先找到两点中深度较深的点（在树上的深度越深表示其越往下），不妨设深度较深的点为 $u$，不停的将 $u$ 往上提，直到 $u$ 的深度和 $v$ 一样。
2. 同时将 $u$ 和 $v$ 向上提，直到 $u$ 和 $v$ 变成了同一个点。这个点就是要求的最近公共祖先。

分析这个算法，每次询问最近公共祖先的时候最坏的情况是需要爬完整棵树，所以每次询问的复杂度是 $\mathcal O(n)$ 的。

**解法 $1$（倍增算法）**：

```cpp
void DFS(int u, int from) {
	vertex[u].ancestor[0] = from;
	vertex[u].depth = vertex[from].depth + 1;
	for (int p = 1; p <= logN; p++) vertex[u].ancestor[p] = vertex[vertex[u].ancestor[p - 1]].ancestor[p - 1];
	for (int e = vertex[u].head; e; e = edge[e].next) {
		int v = edge[e].head;
		if (v != from) DFS(v, u);
	}
	return;
}

int LCA(int u, int v) {
	if (vertex[u].depth < vertex[v].depth) std::swap(u, v);
	for (int p = logN; p >= 0; p--) if (vertex[vertex[u].ancestor[p]].depth >= vertex[v].depth) u = vertex[u].ancestor[p];
	if (u == v) return u;
	for (int p = logN; p >= 0; p--) {
		if (vertex[u].ancestor[p] != vertex[v].ancestor[p]) {
			u = vertex[u].ancestor[p];
			v = vertex[v].ancestor[p];
		}
	}
	return vertex[u].ancestor[0];
}
```

这里有个细节，最后求得的最近公共祖先是 $vertex[u].ancestor[0]$，而不是 $u$。这是因为循环最终只枚举到了 $0$，而 $2^0 = 1$，所以找到的目标并不是两个点本身，而是它们的父亲结点。

由于 $n$ 的二进制下的位数有 $\log(n)$ 个，所以使用倍增算法预处理的时间复杂度是 $\mathcal O(n \log n)$，单次询问的时间复杂度是 $\mathcal O(\log(n))$ 的。

**解法 $2$（$\text{Tarjan}$ 算法）**：

能否让遍历整棵树的过程变得更有价值一点，能够解决不止一次的询问，甚至所有询问呢？

这就是介绍离散化时提到过的离线思想，将所有的询问记录下来，最后仅通过一次统一的计算，即可求得所有要询问的点对点答案。

可以发现，如果有两个点 $x, y$ 都在结点 $u$ 的子树内，那么它们的最近公共祖先就是 $u$。当然，这里的 $u$ 我们也会有要求，它必须得离这两个点尽量的近。也就是说 $x, y$ 是 $u$ 的**不同分支**。

一个结点的子树一定是它