---
layout: post
title:  第十二章 连通性问题
date:   2023-01-22
categories: course srqc jjp
---

在无向图中，连通性问题可以使用并查集解决。但是有一些点或者边是 “关键” 的，没有这些点或者边，这个图就会分裂成各个部分。

无向图中连通的点可以相互到达，有向图上的有序性是一个很好的性质，但对于多数错综复杂的有向图来说并不能直接进行拓扑排序。可以将一些可以互相到达的点合并成一个点，使这个有向图变为有向无环图，即可进行拓扑排序。

## 无向图的双连通性

### 例1：[P1656 炸铁路](https://www.luogu.com.cn/problem/P1656)

在无向图中，如果删去一条边后，图不连通了，这说明存在两个点 $u, v$，$u$ 到 $v$ 的路径必定经过这条边，那么把这条边叫做**割边**（或者桥）。如果一张图不存在割边，那么称这张图为**边双连通图**。一张图的极大双连通子图被称作**边双连通分量**。一张图的边双连通分量之间是不相交的：如果两个双连通分量相交了，那么删去其任意一条边，两个子图之间仍然连通。这说明了，点的 “属于同一个双连通分量” 的关系是带有传递性的。

对于边双连通还存在另一个等价定义：对于任意两点之间，存在至少两条边不相交的路径。

对于无向图，求出其所有双连通分量后，如果把每个双连通分量替换成一个点，那么剩下的是一颗树。这点在取出其生成树上也有体现：每一个双连通分量在生成树上都是一个连通块。

考虑树上连通快的性质：及其点集 $\text{DFS}$ 序最小为 $l$，最大为 $r$，那么其表示一个区间 $[l, r]$。将树分为若干个连通块后，所有的连通块之间代表的区间只有相离和包含两种关系。也就是可以像 $\text{DFS}$ 一样，用一个栈维护 $\text{DFS}$ 到的点，当一个点是连通块最浅的点时，弹出栈顶点一段区间就是弹出这个连通块。

有了这些性质，可以在一边 $\text{DFS}$ 中直接求出所有的边双连通分量：维护每个点是否是连通块深度最低的点，即通过树形 $\text{DP}$ 求出第 $i$ 个结点的子树，通过至多一条非树边能到的深度最低的点的 $\text{DFS}$ 序，也就是 $low_i$。需要注意的是，对于同一个图，遍历边的顺序不同，各点的 $dfn$ 和 $low$ 值也可能不同，但不影响求解答案。

遍历完一个子树，当发现 $low_v \gt dfn_u$，说明 $v$ 结点后续不会接回 $v$ 的祖先上，$(u, v)$ 就是一条割边。遍历完毕后，发现 $low_u = dfn_u$ 即子树没有非树边能到达自己的祖先的时候，就一直弹出栈的点，直到在栈中遇到自己为止，表示这些点属于同一个边双连通分量。

```cpp
void addEBCC(int u) {
    ebcccnt++;
    int v;
    do {
        v = s.top();
        s.pop();
        vertex[v].bel = ebcccnt;
    } while (v != u);
}

void DFS(int u, int from) {
    cnt++;
    vertex[u].dfn = cnt;
    vertex[u].low = cnt;
    s.push(u);
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        if (v == from) continue;
        if (!vertex[v].dfn) {
            DFS(v, u);
            vertex[u].low = std::min(vertex[u].low, vertex[v].low);
            if (vertex[v].low > vertex[u].dfn) ans.push_back(std::make_pair(std::min(u, v), std::max(u, v)));
        } else vertex[u].low = std::min(vertex[u].low, vertex[v].dfn);
    }
    if (vertex[u].low == vertex[u].dfn) addEBCC(u);
    return;
}
```

### 例2：[P2860 [USACO06JAN]Redundant Paths G](https://www.luogu.com.cn/problem/P2860)

将所有边双连通分量看作一个点，那么得到的新图里的边全是原图的割边。也就是要加若干条边，使这些边覆盖的链的并是所有割边。一个容易猜到的结论是，将新图的叶子两两配对，那么当新图点数不为 $1$ 的时候，假设有 $k$ 个叶子，那么答案是 $\lceil \frac{k}{2} \rceil$。

所以统计叶子个数就得到了答案，算法的时间复杂度 $\mathcal O(n + m)$。

```cpp
void DFS(int u, int from) {
    cnt++;
    vertex[u].low = cnt;
    vertex[u].dfn = cnt;
    s.push(u);
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        if (v == from) continue;
        if (!vertex[v].dfn) {
            DFS(v, u);
            vertex[u].low = std::min(vertex[u].low, vertex[v].low);
        } else vertex[u].low = std::min(vertex[u].low, vertex[v].dfn);
    }
    if (vertex[u].low == vertex[u].dfn) {
        bcnt++;
        int v;
        do {
            v = s.top();
            s.pop();
            vertex[v].bel = bcnt;
        } while (v != u);
    }
    return;
}

void mian() {
    for (int e1 = 1; e1 <= ecnt; e1 += 2) {
        int e2 = e1 + 1;
        int u = edge[e1].head;
        int v = edge[e2].head;
        if (vertex[u].bel != vertex[v].bel) {
            block[vertex[u].bel].degree++;
            block[vertex[v].bel].degree++;
        }
    }
    for (int b = 1; b <= bcnt; b++) if (block[b].degree == 1) ans++;
    ans = (ans + 1) / 2;
    std::cout << ans << '\n';
    return;
}
```

## 无向图的点双连通性

### 例3：[P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)

对应着割边，定义**割点**为删去一个点以及其相邻的边后，使得图不连通的点。如果一张图不存在割点，那么称这张图为**点双连通**图。类似的，**极大点双连通子图**被称作**点双连通分量**。

对于点双连通还存在另一个等价定义：对于任意两点 $u, v$ 之间，存在至少两条点不相交（不包含 $u, v$）的路径。

如果两个点双连通分量的点交大于 $1$，则删去任意一点其交仍大于等于 $1$，且图连通，所以两个点双连通分量的交最大为 $1$。这说明一条边不可能同时属于两个点双连通分量，所以点双连通可以看作是边之间带有传递性的关系。同样可以通过生成树来得到一张图所有的点双连通分量，对于非树边相当于将一条链上所有的边合并到一个集合。这说明点双连通分量仍然是树上的一个连通块。

类似边双连通分量的变种 $\text{Tarjan}$ 算法，求双连通分量可以直接计算边的 $\text{DFS}$ 序。但是这些连通分量都是基于点点，所以修改 $\text{Tarjan}$ 算法：用一个点代表其通向父结点的边，每次处理完点双连通分量深度最低的边（$low_v = dfn_u$）或者处理完割边（$low_v \gt dfn_u$）时，代表找到一个点双连通分量。

统计每个点属于的点双连通分量的数量，如果一个点属于多个点双连通分量，那么它就是一个割点。

```cpp
void addVBCC(int u) {
    vbcccnt++;
    int v;
    do {
        v = s.top();
        s.pop();
        vertex[v].degree++;
    } while (v != u);
    return;
}

void DFS(int u, int from) {
    dfn++;
    vertex[u].low = dfn;
    vertex[u].dfn = dfn;
    s.push(u);
    for (int e = vertex[u].head; e; e = edge[e].next) {
        int v = edge[e].head;
        if (v == from) continue;
        if (!vertex[v].dfn) {
            DFS(v, u);
            vertex[u].low = std::min(vertex[u].low, vertex[v].low);
            if (vertex[v].low >= vertex[u].dfn) {
                s.push(u);
                addVBCC(v);
            }
        } else vertex[u].low = std::min(vertex[u].low, vertex[v].dfn);
    }
    return;
}
```

每个点连接着若干个不同的点双连通分量，同时每个点双连通分量包含着若干点，可以依次性质将图变为树形结构，其中将原图顶点成为圆点，代表着点双连通分量的点被称作方点，那么这样的树形结构被称作**圆方树**。由于其描述了点双连通的结构，因此圆方树是解决点相关路径问题的利器。

要建立圆方树，由于已经又了深度关系，只需更改找到点双连通分量时的代码。

```cpp
void addBlockForest(int u) {
    bfcnt++;
    int v;
    do {
        v = s.top();
        s.pop();
        addEdge(n + bfcnt, v);
    } while (v != u);
    return;
}

            if (vertex[v].low >= vertex[u].dfn) {
                s.push(u);
                addBlockForest(v);
            }
```