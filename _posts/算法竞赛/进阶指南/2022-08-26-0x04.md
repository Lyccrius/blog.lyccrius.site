---
layout: post
title: "《算法竞赛进阶指南》0x04 二分"
date:   2022-08-26
author: 李煜东
categories: course sfjs-jjzn
---

二分的基础的用法是在单调序列或单调函数中进行查找。

因此，当问题的答案具有单调性时，就可以通过二分把求解转化为判定（根据复杂度理论，判定的难度小于求解），这使得二分的运用范围变得很广泛。

进一步地，我们还可以扩展到通过三分法去解决单峰函数的极值以及相关问题。

二分的视线方法多种多样，但是其细节之处确实需要仔细考虑。

> * 对于整数域上的二分，需要注意终止边界、左右区间取舍时的开闭情况，避免漏掉答案或造成死循环；
> * 对于实数域上的二分，需要注意精度问题。

## 整数集合上的二分

二分的写法保证最终答案处于闭区间 $$[l,r]$$ 以内，

循环以 $$l=r$$ 结束，

每次二分的中间值 $$mid$$ 会归属于左半段或右半段二者之一。

> * 在单调递增序列 $$a$$ 中查找 $$\geq x$$ 的数中最小的一个（即 $$x$$ 或 $$x$$ 的后继）：
> ```
> while (l < r) {
>    int mid = (l + r) >> 1;
>    if (a[mid] >= x) r = mid; else l = mid + 1;
> }
> return a[l];
> ```
> * 在单调递增序列 $$a$$ 中查找 $$\leq x$$ 的数中最大的一个（即 $$x$$ 或 $$x$$ 的前驱）：
> ```
> while (l < r) {
>    int mid = (l + r + 1) >> 1;
>    if (a[mid] <= x) l = mid; else r = mid - 1;
> }
> return a[l];
> ```

在第一段代码中，若 $$a[mid]\geq x$$，

则根据序列 $$a$$ 的单调性，$$mid$$ 之后的数会更大，

所以 $$\geq x$$ 的最小的数不可能在 $$mid$$ 之后，可行区间应该缩小为左半段。

因为 $$mid$$ 也可能是答案，故此时应取 $$r=mid$$。

同理，若 $$a[mid]<x$$，取 $$l=mid+1$$。

在第二段代码中，若 $$a[mid]\leq x$$，

则根据序列 $$a$$ 的单调性，$$mid$$ 之前的数会更小，

所以 $$\leq x$$ 的最大的数不可能在 $$mid$$ 之前，可行区域应该缩小为右半段。

因为 $$mid$$ 也可能是答案，故此时应取 $$l=mid$$。

同理，若 $$a[mid]>x$$，取 $$r=mid-1$$。

如上面两段代码所示，这种二分写法可能会有**两种形式**。

> 1. 缩小范围时，$$r=mid$$，$$l=mid+1$$，取中间值时，$$mid=(l+r)>>1$$。  
> 2. 缩小范围时，$$l=mid$$，$$r=mid+1$$，取中间值时，$$mid=(l+r+1)>>1$$。

如果不对 $$mid$$ 的取法加以区分，假如第二段代码也采用 $$mid=(l+r)>>1$$，

那么当 $$r-l$$ 等于 $$1$$ 时，就有 $$mid=(l+r)>>1=l$$。

接下来若进入 $$l=mid$$ 分支，可行区间未缩小，造成死循环；

若进入 $$r=mid-1$$ 分支，造成 $$l>r$$，循环不能以 $$l=r$$ 结束。

因此对两个形式采取**配套的 $$mid$$ 取法**是必要的。

上面两段代码所示的两个形式共同组成了这种二分的视线方法。

注意，我们在二分实现中采取了**右移运算** $$>>1$$，而不是整数除法 $$/2$$。

这是因为右移运算是向下取整，而整数除法是向零取整，在二分值域包含负数时后者不能正常工作。

仔细分析这两种 $$mid$$ 的取法，我们还发现：

$$mid=(l+r)>>1$$ 不会取到 $$r$$ 这个值，$$mid=(l+r+1)>>1$$ 不会取到 $$l$$ 这个值。

我们可以利用这一性质来处理无解的情况，

把最初的二分区间 $$[1,n]$$ 分别扩大为 $$[1,n+1]$$ 和 $$[0,n]$$，把 $$a$$ 数组的一个越界的下标包含进来。

如果最后二分终止于扩大后的这个越界下标上，则说明 $$a$$ 中不存在所求的数。

总而言之，正确写出这种二分的流程是：

> 1. 通过分析具体问题，确定左右半段哪一个是可行区间，以及 $$mid$$ 归属哪一半段；
> 2. 根据分析结果，选择 “$$r=mid,l=mid+1,mid=(l+r)>>1$$” 和 “$$l=mid,r=mid-1,mid=(l+r+1)>>1$$” 两个配套形式之一；
> 3. 二分的终止条件是 $$l==r$$，该值就是答案所在位置。

本书使用的这种二分方法的优点是始终保持答案位于二分区间内，二分结束条件对应的值恰好在答案所处位置，还可以自然地处理无解的情况，形式优美。

唯一的缺点是由两种形式共同组成，需要认真考虑实际问题选择对应的形式。

也有其他的二分写法，采用 “$$l=mid+1,r=mid-1$$” 或 “$$l=mid,r=mid$$” 来避免产生两种形式，但也相应地造成了丢失在 $$mid$$ 点上的答案、二分结束时可行区间未缩小到确切答案等问题，需要额外加以处理。

C++ STL 中的 `lower_bound` 与 `upper_bound` 函数实现了在一个序列中二分查找某个整数 $$x$$ 的后继。

## 实数域上的二分

在实数域上的二分较为简单，确定好所需的精度 $$eps$$，以 $$l+eps<r$$ 为循环条件，每次根据在 $$mid$$ 上的判定选择 $$r=mid$$ 或 $$l=mid$$ 分支之一即可。

一般需要保留 $$k$$ 位小数时，则取 $$eps=10^{-(k+2)}$$。

```
while (l + 1e-5 < r) {
    double mid = (l + r) / 2;
    if (calc(mid)) r = mid; else l = mid;
}
```