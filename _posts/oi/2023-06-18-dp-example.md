---
layout: post
title:  DP 例题
date:   2023-06-18
categories: oi
---

##  HDU     2602    Bone collector

01 背包。

记 $f_{i, j}$ 表示考虑前 $i$ 个物品占用 $j$ 体积的最大价值。

$$f_{i, j} = \max(f_{i - 1, j}, f_{i, j - v_i} + w_i)$$

时间复杂度 $\mathcal O(nv)$。

##  HDU     1712    ACboy needs your help

分组背包。

把同一门课程的不同复习时间归为一组。

一门课程只能选定一个时间长度复习，类比为一个组内的物品只能选一个。

记 $f_{i, j}$ 表示考虑前 $i$ 门课程，花费 $j$ 天的最大收益。

$$f_{i, j} = \max_{0 \le k \le j} \{ f_{i - 1, j - k} + a_{i, k} \}$$

时间复杂度 $\mathcal O(nm^2)$。

##  Luogu   P1776   宝物筛选

多重背包。

直接枚举每件物品选多少件需要 $\mathcal O(nmv)$，超时。

在二进制表示下，任意整数都可以表示成若干 $2$ 的整数次幂相加的形式。

对每件物品的数量进行二进制分组，分组后 $n \log m$ 件物品与原 $n$ 件物品等价。

时间复杂度 $\mathcal O(nv \log m)$

##  Luogu   P2602   数字计数

数位 DP。

考虑一个数字怎么求，其它数字使用相同求法。

当前要求 $[l, r]$ 中 $x$ 出现的次数，可以差分为 $[1, r]$ 中 $x$ 出现的次数减去 $[1, l - 1]$ 中 $x$ 出现的次数。

要求 $n$ 以内 $x$ 出现的次数，现将 $n$ 在十进制表示下的若干位提出来。

从最高位开始记忆化搜索，搜索时需要记录四个信息：
1.  当前搜索到十进制下的哪一位
2.  当前考虑的数码 $x$
3.  高于当前位是否有签到零
4.  高于当前位是否贴着 $n$ 的上限

考虑当前位填那一位数字，根据以上四条信息进行分类讨论计数。

注意当有前导零或贴到上限时不可记忆化。

##  Luogu   P2657   Windy 数

数位 DP。

在上一道题的基础上新增一维信息，即上一位所填的数字。

枚举当前位所填数字时，如果与上一位所填数字差小于 $2$ 则跳过。

##  Luogu   P4124   手机号码

数位 DP。

与上一道题同样的思路，在记忆化搜索形式的数位 DP 的基础上继续添加状态维度：
1.  前两位所填数字
2.  前一位所填数字
3.  之前是否出现至少 $3$ 位相邻的数字
4.  是否出现过 $4$
5.  是否出现过 $8$

##  POJ     2411    Mondriaan's dream

轮廓线 DP。

枚举当前要处理的格子，使用大小为 $2^w$ 的状态压缩表示当前行该点左侧及上一行该点右侧的骨牌堆放情况。

对于当前格子有三种决策：
1.  横放（向左）
    *   左侧格子为空时
2.  竖放（向上）
    *   上侧格子为空时
3.  留空（不动）
    *   左侧上侧非空时

依次检查当前状态能否满足上述三种情况，若满足则累加计数。

需要滚动数组优化。

##  HDU     4539    排兵布阵

状压 DP。

相邻的三行都有可能相互攻击，因此需要枚举连续三行的状态。

但是这样的状态数有 $(2^10)^3$ 达到了 $1e9$ 级别。

考虑优化，考虑第 $i$ 行时先枚举第 $i, i - 1$ 行的状态，若合法再枚举第 $i - 2$ 行的状态。

*   相邻两行状态 $x, y$ 合法，需要 $x \& (y << 1) = 0, x \& (y >> 1) = 0$。
*   相隔两行状态 $x, y$ 合法，需要 $x \& y = 0$。

##  HDU     3001 

状压 DP。

解决哈密顿回路的方法是记 $f_{i, j}$ 表示经过的点集二进制压缩后为 $i$，当前在 $j$ 点的最小花费。

这道题要求每个点经过不超过 $2$ 次，可能不存在一种每个点都经过一次的方案。

于是重新设计状态，$f_{i, j}$ 表示各点经过次数三进制压缩后为 $i$，当前在 $j$ 点的最小花费。

状态转移与哈密顿回路一样。

##  Luogu   P1880   石子合并

区间 DP。

$f_{i, j}, g_{i, j}$ 表示 $[i, j]$ 堆石子合并成一堆的最小最大得分。

$$
\begin{aligned}
    f_{i, j} & = \min_{i \le k \lt j} f_{i, k} + f_{k + 1, j} + sum(i, j) \\
    g_{i, j} & = \max_{i \le k \lt j} g_{i, k} + g_{k + 1, j} + sum(i, j)
\end{aligned}
$$

其中 $sum(i, j)$ 表示 $[i, j]$ 的石子个数和，可以使用前缀和 $\mathcal O(1)$ 计算。

时间复杂度 $\mathcal O(n^3)$。

数据范围再大点可以使用四边形不等式优化。

##  HDU     2476    String painter

区间 DP。

先考虑空串变成 $b$ 串的情况，再用 $a$ 串去匹配。

记 $f_{i, j}$ 表示空串变为 $b$ 串 $[i, j]$ 的最小次数。

$$
f_{i, j} = \min_{i \le k \lt j}
\begin{cases}
    f_{k + 1, j} + 1, & i = k \\
    f_{i + 1, k} + f_{k + 1, j} & b_i = b_k
\end{cases}
$$

记 $g_i$ 表示 $a$ 串前 $i$ 为变为 $b$ 串前 $i$ 的最小次数。

$$
g_i = 
\begin{cases}
    g_{i - 1}, & a_i = b_i \\
    \min_{0 \le j \lt i} ans_j + f_{j + 1, i} & a_i \neq b_i
\end{cases}
$$

时间复杂度 $\mathcal O(n^3)$。

##  HDU     4283    You are the one

区间 DP。

$f_{i, j}$ 表示 $[i, j]$ 的最小愤怒值。

$$f_{i, j} = \min_{i \le k \lt j} (k - i) \times diaosi_i + f_{i + 1, k} + (k - i + 1) \times (sum_j - sum_k) + f_{k + 1, j}$$

时间复杂度 $\mathcal O(n^3)$。

##  CF      1198D   Rectangle painting

二维区间 DP。

$f(x_1, y_1, x_2, y_2)$ 表示 $(x_1, y_1)$ 到 $(x_2, y_2)$ 这一矩形内的最小代价。

分别枚举 $x$ 轴和 $y$ 轴的分界点，使用记忆化搜索形式实现。

时间复杂度 $\mathcal O(n^5)$。

##  Luogu   P2015   二叉苹果树

树形 DP。

$f_{u, i}$ 表示 $u$ 的子树内保留 $i$ 根树枝的最多苹果数。

$$f_{u, i} = \max_{v \in son_u} f_{u, i - j - 1} + f_{v, j} + w$$

需要倒序枚举。

时间复杂度 $\mathcal O(nq^2)$。

##  Luogu   P1352   没有上司的舞会

树形 DP。

树上最大权独立集问题。

$f_{u, 0/1}$ 表示 $u$ 子树内 $u$ 是否选择的最大快乐指数。

$$
\begin{aligned}
    f_{u, 0} & = \sum_{v \in son_u} \max(f_{v, 0}, f_{v, 1}) \\
    f_{u, 1} & = \sum_{v \in son_u} f_{v, 0} + r_u
\end{aligned}
$$

时间复杂度 $\mathcal O(n)$。

##  Luogu   P1273   有线电视网

树形 DP。

$f_{u, i}$ 表示 $u$ 子树内 $i$ 个客户的最大收益。

$$f_{u, i} = \max_{v \in son_u} f_{u, i - j} + f_{v, j} - w$$

需要倒序枚举。

##  Luogu   P3287   方伯伯的玉米田

显然每次拔高的区间都是一个后缀。

记 $f_{i, j}$ 表示前 $i$ 株玉米，拔高 $j$ 次，最长非降子序列长度。

$$f_{i, j} = \max_{k \lt i, l \le j, a_k + l \le a_i + j} f_{k, l} + 1$$

这个 $\mathcal O(n^2 k^2)$ 的转移可以说是只能过样例。

发现 $\max f_{k, l}$ 其实就是二维前缀最大值，可以用二维树状数组维护。

于是时间复杂度来到了 $\mathcal O(n k \log n \log k)$，能过。

打个表发现：
*   当 $i$ 一定时，$f_{i, j}$ 随 $j$ 增加不减。
*   当 $j$ 一定时，$f_{i, j}$ 随 $i$ 增加不减。

也就是说，我们要查 $(i, j)$ 的前缀最大值，只需要查 $k \in [1, i]$ 的 $f_{k, j}$ 和 $k \in [1, j]$ 的 $f_{i, k}$ 就可以了，于是对行和列分别维护树状数组。

时间复杂度 $\mathcal O(n k \log n)$。

##  Luogu   P2605   基站选址

首先写出状态转移方程再优化。

$f_{i, j}$ 表示第 $j$ 个基站建在 $i$ 的最小花费。

$$f_{i, j} = \min \\{ f_{k, j - 1} + pay(k, i) \\} + c_i$$

转移是 $\mathcal O(n^2 k)$ 的，只有 40 分。

可以用分层 DP 把 $j$ 压掉。

我们考虑如何快速计算 $pay(k, i)$。

首先对于每个村庄，用二分求出能够覆盖它的基站位置 $[st_i, ed_i]$。

对于 $i$ 位置的基站，在决策之后枚举所有 $ed_j = i$ 的村庄 $j$。

由于 $i$ 是最后一个建基站使得村庄 $j$ 的位置，那么对于 $i$ 后面的位置，再建基站就无法覆盖到村庄 $j$ 了。

再来考虑村庄 $j$ 无法被前面的基站覆盖的情况，就是上一个基站建到了 $st_j$ 前面到情况。

总结一下，在第 $i$ 个位置决策结束之后，枚举所有以 $i$ 为 $ed_j$ 的村庄 $j$，将 $w_j$ 作为 $pay$ 累加到 $[1, st_j - 1]$ 的上一层状态中。

这样我们就不用每次转移分别计算 $pay$ 了。

显然这是可以用线段树优化的。

时间复杂度 $\mathcal O(n k \log n)$。

##  Luogu   P2627   Mowing the lawn

记 $f_{i, 0/1}$ 表示前 $i$ 头奶牛，第 $i$ 头选或不选的最高效率。

$$
\begin{aligned}
    f_{i, 0} & = \max(f_{i - 1, 0}, f_{i - 1, 1}) \\
    f_{i, 1} & = \max_{i - k \le j \lt i} f_{j, 0} + \sum_{k = j + 1}^i e_k
\end{aligned}
$$

使用前缀和优化。

$$
\begin{aligned}
    f_{i, 1} & = \max_{i - k \le j \lt i} f_{j, 0} + p_i - p_j \\
    & = \max_{i - k \le j \lt i} f_{j, 0} - p_j + p_i
\end{aligned}
$$

使用单调队列优化 $\max_{i - k \le j \lt i} f_{j, 0} - p_j$，时间复杂度 $\mathcal O(n)$。

##  HDU     3507    Print article

记 $f_i$ 表示前 $i$ 个数的最小代价。

$$
\begin{aligned}
    f_i & = f_j + (p_i - p_j)^2 + m \\
    f_i & = f_j + p_i^2 + p_j^2 - 2 p_i p_j + m \\
    f_j + p_j^2 & = 2 p_i p_j + f_i - p_i^2 - m
\end{aligned}
$$

使用斜率优化。

##  UVA     10304   Optimal binary search tree

按点权排序。

记 $f_{i, j}$ 表示 $[i, j]$ 合并为一棵树的最小费用。

$$f_{i, j} = \min_{i \lt k \lt j} f_{i, k - 1} + sum_{i, j} - val_k + f_{k + 1, j}$$

直接转移是 $\mathcal O(n^3)$，可以使用四边形不等式优化到 $\mathcal O(n^2)$。