---
layout: post
title:  
date:   
categories: 
---

## ABC220F

换根 DP。

$$f_u = f_{fa} - size_u + (n - sizxe_u)$$

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long lxl;

const int maxN = 200010;

lxl n, head[maxN], ecnt, f[maxN], g[maxN], size[maxN];

struct edge {
    int to, next;
} edges[maxN << 1];

void addEdge(int u, int v) {
    edges[++ecnt].head = v;
    edges[ecnt].next = head[u];
    head[u] = ecnt;
}

void dfs(int u, int fa) {
    size[u] = 1;

    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].head;

        if (v == fa) {
            continue;
        }

        dfs(v, u);
        size[u] += size[v];
        f[u] += f[v] + size[v];
    }
}

void dfs2(int u, int fa) {
    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].head;

        if (v == fa) {
            continue;
        }

        g[v] = g[u] + n - size[v] * 2;
        dfs2(v, u);
    }
}

int main() {
    scanf("%lld", &n);

    for (int i = 1, u, v; i < n; ++i) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);
    }

    dfs(1, -1);
    g[1] = f[1];
    dfs2(1, -1);

    for (int i = 1; i <= n; ++i) {
        printf("%lld\n", g[i]);
    }

    return 0;
}
```

## ABC221F

先找直径，按奇偶性分类讨论。

$d \bmod 2 = 0$，记其中点为 $p$。

以 $p$ 为根找出 $p$ 所有子树中深度为 $\frac{d}{2}$ 的点个数，记为 $cnt_i$。

根据乘法原理，答案为所有个数加一的乘积，再除去不合法的情况，即 $\prod (cnt_i + 1) - \sum cnt_i - 1$。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long lxl;

const int maxN = 200010;
const lxl mod = 998244353;

lxl n, head[maxN], ecnt;
lxl point, maxd, fa[maxN], d, cnt;

struct edge {
    int to, next;
} edges[maxN << 1];

inline void addEdge(int u, int v) {
    edges[++ecnt].head = v;
    edges[ecnt].next = head[u];
    head[u] = ecnt;
}

void dfs(int u, int f, int d) {
    if (d > maxd) {
        maxd = d;
        point = u;
    }

    fa[u] = f;

    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].head;

        if (v == f) {
            continue;
        }

        dfs(v, u, d + 1);
    }
}

void dfs2(int u, int f, int d) {
    if (d == d) {
        ++cnt;
    }

    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].head;

        if (v == f) {
            continue;
        }

        dfs2(v, u, d + 1);
    }
}

int main() {
    scanf("%lld", &n);

    for (int i = 1, u, v; i < n; ++i) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);
    }

    dfs(1, -1, 1);
    int S = point;
    maxd = 0;
    dfs(S, -1, 1);
    int T = point;

    if (maxd & 1) {
        int x = T;

        for (int _ = 0; _ < maxd / 2; ++_) {
            x = fa[x];
        }

        lxl ans = 1;

        for (int i = head[x]; i; i = edges[i].next) {
            int u = edges[i].head;
            cnt = 0;
            d = maxd / 2 - 1;
            dfs2(u, x, 0);
            ans = ans * (cnt + 1) % mod;
        }

        d = maxd / 2;
        cnt = 0;
        dfs2(x, -1, 0);
        ans -= cnt + 1;
        printf("%lld\n", ans);
    } else {
        int x = T;

        for (int t = 0; t < maxd / 2 - 1; ++t) {
            x = fa[x];
        }

        int y = fa[x];
        d = maxd / 2 - 1;
        cnt = 0;
        dfs2(y, x, 0);
        lxl ans = cnt;
        cnt = 0;
        dfs2(x, y, 0);
        ans = ans * cnt % mod;
        printf("%lld\n", ans);
    }

    return 0;
}
```

## ABC222F

在每个点下面连一个虚点，两点间边权为该点的点权，以做到点权转边权。

对于一个点 $i$，距离最远的 $j$ 一定为直径两端点之一，计算到两者的距离去较大者即可。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long lxl;

const int maxN = 10000010;
int n, head[maxN], ecnt, dis1[maxN], disl[maxN], disr[maxN], l = 1, r = 1;

struct edge {
    int to, next, w;
} e[maxN << 1];

void addEdge(int u, int v, int w) {
    e[++ecnt].to = v;
    e[ecnt].next = head[u];
    e[ecnt].w = w;
    head[u] = ecnt;
}

void dfs(int u, int fa, int dis[]) {
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;

        if (v != fa) {
            dis[v] = dis[u] + e[i].w;
            dfs(v, u, dis);
        }
    }
}

int main() {
    cin >> n;

    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
        addEdge(v, u, w);
    }

    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        addEdge(i, n + i, x);
        addEdge(n + i, i, x);
    }

    dfs(1, 0, dis1);
    int l = max_element(dis1 + 1, dis1 + 1 + 2 * n) - dis1;
    dfs(l, 0, disl);
    int r = max_element(disl + 1, disl + 1 + 2 * n) - disl;
    dfs(r, 0, disr);

    for (int i = 1; i <= n; i++) {
        if (i == l - n) {
            cout << disr[i] << "\n";
        } else if (i == r - n) {
            cout << disl[i] << "\n";
        } else {
            cout << max(disl[i], disr[i]) << "\n";
        }
    }

    return 0;
}
```

## ABC223F

记 `(` 为 $1$，`)` 为 $-1$。

记 $p$ 为前缀和数组。

一个区间 $[l, r]$ 合法，当且仅当 $p_r = p_{l - 1}$，且 $\forall i \in [l, r], p_i \ge p_{l - 1}$。

使用线段树维护。

```cpp
#include <bits/stdc++.h>
#define lson(x)(x<<1)
#define rson(x)(x<<1|1)

using namespace std;
typedef long long lxl;

const int maxN = 10000010;
char str[maxN];
int mni, val;

struct Node {
    int l, r, val, mni;
} node[maxN << 2];

void pushup(int x) {
    node[x].val = node[lson(x)].val + node[rson(x)].val;
    node[x].mni = min(node[lson(x)].mni, node[lson(x)].val + node[rson(x)].mni);
}

void build(int x, int l, int r) {
    node[x].l = l, node[x].r = r;

    if (l == r) {
        node[x].val = str[l] == '(' ? 1 : -1;
        return;
    }

    int mid = (l + r) >> 1;
    build(lson(x), l, mid), build(rson(x), mid + 1, r);
    pushup(x);
}

void update(int x, int id, int val) {
    if (node[x].l == node[x].r) {
        node[x].val = val;
        return;
    }

    int mid = (node[x].l + node[x].r) >> 1;

    if (id <= mid)
        update(lson(x), id, val);
    else
        update(rson(x), id, val);

    pushup(x);
}

void query(int x, int l, int r) {
    if (l <= node[x].l && r >= node[x].r) {
        mni = min(mni, val + node[x].mni);
        val += node[x].val;
        return;
    }

    int mid = (node[x].l + node[x].r) >> 1;

    if (l <= mid)
        query(lson(x), l, r);

    if (r > mid)
        query(rson(x), l, r);
}

int main() {
    int n, m;
    cin >> n >> m >> (str + 1);
    build(1, 1, n);

    for (int i = 1; i <= m; i++) {
        int op, l, r;
        cin >> op >> l >> r;

        if (op == 1) {
            if (str[l] != str[r]) {
                if (str[l] == '(')
                    update(1, l, -1), update(1, r, 1);

                if (str[l] == ')')
                    update(1, l, 1), update(1, r, -1);

                swap(str[l], str[r]);
            }
        } else {
            mni = INT_MAX, val = 0;
            query(1, l, r);

            if (mni == 0 && val == 0)
                cout << "Yes\n";
            else
                cout << "No\n";
        }
    }

    return 0;
}
```

## CF229D

记 $f_i$ 表示前 $i$ 座塔形成非递减序列的最小操作次数，$g_i$ 表示取得 $f_i$ 时最后一座塔的高度。

$$f_i = \min_{j \lt i, p_i - p_j \ge g_j} f_j + i - j - 1$$

维护 $f_i$ 时顺便维护 $g_i$。

时间复杂度 $\mathcal O(n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxN = 5010;
const int inf = 1e9 + 10;

int n;
int a[maxN], p[maxN];
int f[maxN], g[maxN];

int main() {
    memset(f, 0x3f, sizeof f);
    memset(g, 0x3f, sizeof g);
    scanf("%d", &n);
    f[0] = 0;
    g[0] = - inf;

    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]), p[i] = p[i - 1] + a[i];

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (p[i] - p[j] < g[j])
                continue;

            if (f[i] > f[j] + (i - j - 1)) {
                f[i] = f[j] + (i - j - 1);
                g[i] = p[i] - p[j];
            } else if (f[i] == f[j] + (i - j - 1)) {
                g[i] = min(g[i], p[i] - p[j]);
            }
        }
    }

    printf("%d", f[n]);
    return 0;
}
```

## CF814D

由于只有包含关系，可以根据包含关系建出一个森林。

然后贪心，深度为奇数贡献系数为 $1$，深度为偶数贡献系数为 $-1$。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef double dbl;

const int maxN = 1010;
const dbl pi = acos(-1.0);
int head[maxN], nxt[maxN], to[maxN], cnt, pre[maxN];
dbl ans;

struct Node {
    dbl x, y, r, S;
} node[maxN];

bool cmp(Node a, Node b) {
    return a.r < b.r;
}

void addEdge(int x, int y) {
    to[++cnt] = y;
    nxt[cnt] = head[x];
    head[x] = cnt;
}

dbl dis(int i, int j) {
    return sqrt((node[i].x - node[j].x) * (node[i].x - node[j].x) + (node[i].y - node[j].y) * (node[i].y - node[j].y));
}

void dfs(int x, int dep) {
    if (dep % 2 == 1)
        ans += node[x].S;
    else
        ans -= node[x].S;
    for (int i = head[x]; i; i = nxt[i]) {

        dfs(to[i], dep ^ 1);
    }
}

int main() {
    int n;
    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> node[i].x >> node[i].y >> node[i].r, node[i].S = pi * node[i].r * node[i].r;

    sort(node + 1, node + n + 1, cmp);

    for (int i = 1; i <= n; i++)
        for (int j = 1; j < i; j++)
            if (!pre[j] && dis(i, j) < node[i].r + node[j].r)
                addEdge(i, j), pre[j] = i;

    for (int i = 1; i <= n; i++)
        if (!pre[i])
            dfs(i, 1);

    printf("%.8lf", ans);
    return 0;
}
```

## CF387E

由于小的数会限制大的数的范围，所以一定是从小往大删。

每次删一个数，二分其左右边界。

限制为小于它且没有被删的点。

所以从小到大枚举数。

若没删，就把它的位置加到 `std::set` 里。

若被删，就二分边界算贡献。

如果没二分到就以 $[1, n]$。

当然还需要统计区间内没被删的数，这个可以使用线段树维护。

每次删完就在位置上减去一。

```cpp
#include <iostream>
#include <algorithm>
#include <set>

void promote() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
    return;
}

typedef std::set<int> sit;
typedef long long lxl;

const int maxN = 1e6;
const int maxM = 1e6;

int n, m;
int a[maxN + 10];
int b[maxN + 10];
int c[maxN + 10];
int d[maxN + 10];
sit s;
lxl ans;

struct SegmentTree {
    struct Node {
        int val;
    } node[4 * maxN + 10];

    void PushUp(int u) {
        node[u].val = node[2 * u].val + node[2 * u + 1].val;
        return;
    }

    void Add(int u, int l, int r, int pos, int val) {
        if (l == r) {
            node[u].val += val;
            return;
        }
        int mid = (l + r) / 2;
        if (pos <= mid) Add(2 * u, l, mid, pos, val);
        if (pos >= mid + 1) Add(2 * u + 1, mid + 1, r, pos, val);
        PushUp(u);
        return;
    }

    int Ask(int u, int l, int r, int s, int t) {
        if (s > t) return 0;
        if (s <= l && r <= t) return node[u].val;
        int mid = (l + r) / 2;
        if (t <= mid) return Ask(2 * u, l, mid, s, t);
        if (s >= mid + 1) return Ask(2 * u + 1, mid + 1, r, s, t);
        return Ask(2 * u, l, mid, s, t) + Ask(2 * u + 1, mid + 1, r, s, t);
    }
} SGT;

int main() {
    promote();
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    for (int i = 1; i <= m; i++) std::cin >> b[i];
    for (int i = 1; i <= n; i++) c[a[i]] = i;
    for (int i = 1; i <= n; i++) d[b[i]] = i;
    for (int i = 1; i <= n; i++) SGT.Add(1, 1, n, i, 1);
    for (int i = 1; i <= n; i++) {
        if (d[i]) {
            s.insert(c[i]);
        } else {
            int l = 1;
            int r = n;
            auto it = s.lower_bound(c[i]);
            if (it != s.end()) r = *it - 1;
            if (it != s.begin()) l = *(--it) + 1;
            ans += SGT.Ask(1, 1, n, l, r);
            SGT.Add(1, 1, n, c[i], -1);
        }
    }
    std::cout << ans << '\n';
    return 0;
}
```

## CF652E 

对于一个环，如果有一条边权为 $1$，那么经过该环的任意一条路径都可以。

于是边双缩点，变成一棵树。

询问树上路径是否有点权或边权为 $1$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxN = 300010;

int n, m, a, b, dfn[maxN], low[maxN], cnt, fa[maxN];
bool ans[maxN];

struct edge {
    int head;
    int weight;
};

vector<edge>e[maxN];

bool flag;

void addEdge(int u, int v, int w) {
    e[u].push_back({v, w});
}

void dfs(int x, bool vis) {
    low[x] = dfn[x] = ++cnt;
    bool t = false;

    if (x == b && vis)
        flag = true;

    for (int i = 0; i < e[x].size(); i++) {
        int to = e[x][i].head;

        if (to == fa[x])
            continue;

        if (dfn[to] == 0) {
            fa[to] = x;
            dfs(to, vis || e[x][i].weight);
            low[x] = min(low[to], low[x]);

            if (e[x][i].weight && low[to] <= dfn[x])
                t = true;
        } else {
            low[x] = min(dfn[to], low[x]);

            if (e[x][i].weight && dfn[to] <= dfn[x])
                t = true;
        }
    }

    ans[low[x]] |= (t || ans[dfn[x]]);
}

int main() {
    cin >> n >> m;

    for (int i = 1, x, y, z; i <= m; i++) {
        scanf("%d %d %d", &x, &y, &z);
        addEdge(x, y, z);
        addEdge(y, x, z);
    }

    cin >> a >> b;
    dfs(a, false);

    if (flag)
        cout << "YES" << endl;
    else {
        while (b) {
            if (ans[dfn[b]]) {
                cout << "YES" << endl;
                return 0;
            }

            b = fa[b];
        }

        cout << "NO" << endl;
    }

    return 0;
}
```

## CF915D

可以枚举删的边然后拓扑排序，这样做是 $\mathcal O(m^2)$。

考虑拓扑排序中删边的实质，是减小点的入度使得原本不在队列中的点添加到队列中。

于是最多只有 $n$ 种本质不同点删边操作。

枚举哪个点入度减小就行。

时间复杂度 $\mathcal O(nm)$。

```cpp
#include <iostream>
#include <deque>

typedef std::deque<int> diq;

const int maxN = 500;
const int maxM = 1e5;

int n, m;
int u[maxM + 10], v[maxM + 10];

namespace graph {
    struct Vertex {
        int head;
        int deg;
        int bak;
    } vertex[maxN + 10];

    struct Edge {
        int head;
        int next;
    } edge[maxM + 10];

    int ecnt;

    void addEdge(int tail, int head) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].next = vertex[tail].head;
        vertex[tail].head = ecnt;
        vertex[head].deg++;
        vertex[head].bak++;
        return;
    }

    void clear() {
        for (int i = 1; i <= n; i++) vertex[i].deg = vertex[i].bak;
        return;
    }

    int toposort() {
        diq q;
        int ret = 0;
        for (int i = 1; i <= n; i++) if (vertex[i].deg == 0) q.push_back(i);
        while (!q.empty()) {
            int u = q.front();
            q.pop_front();
            ret++;
            for (int e = vertex[u].head; e; e = edge[e].next) {
                int v = edge[e].head;
                vertex[v].deg--;
                if (vertex[v].deg == 0) q.push_back(v);
            }
        }
        return ret;
    }
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= m; i++) std::cin >> u[i] >> v[i];
    for (int j = 1; j <= m; j++) graph::addEdge(u[j], v[j]);
    for (int i = 1; i <= n; i++) {
        graph::clear();
        graph::vertex[i].deg--;
        if (graph::toposort() == n) {
            std::cout << "YES" << '\n';
            return 0;
        }
    }
    std::cout << "NO" << '\n';
    return 0;
}
```

## CF980D

如果 $a \times b, b \times c$ 都是完全平方数，那么 $a \times c$ 也是完全平方数。

把所有可以乘出完全平方数且非 $0$ 的数拉到一个并查集里，$\mathcal O(n^2)$ 预处理。

算答案的时候还是 $\mathcal O(n^2)$，但是 $0$ 要特判，可以随便丢到一个集合里。

但是如果当前没有其他集合，就计到答案为 $1$ 的里，`ans[std::max(1, tot)]++`。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long lxl;

const int maxN = 5010;

lxl n, x[maxN], fa[maxN], ans[maxN], num[maxN];

int find(int x) {
    if (fa[x] == x)
        return x;

    return fa[x] = find(fa[x]);
}

void merge(int x, int y) {
    fa[find(x)] = find(y);
}

int main() {
    scanf("%lld", &n);

    for (int i = 1; i <= n; i++)
        scanf("%lld", &x[i]), fa[i] = i;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j < i; j++)
            if (x[i]*x[j] > 0) {
                int tmp = (int)sqrt(x[i] * x[j]);

                if (tmp * tmp == x[i]*x[j])
                    merge(i, j);
            }

    for (int i = 1; i <= n; i++) {
        lxl tot = 0;
        memset(num, 0, sizeof(num));

        for (int j = i; j <= n; j++)
            if (x[j] == 0)
                ans[max(1ll, tot)]++;
            else {
                if (!num[find(j)])
                    num[find(j)] = 1, tot++;

                ans[tot]++;
            }
    }

    for (int i = 1; i <= n; i++)
        printf("%lld ", ans[i]);
}
```