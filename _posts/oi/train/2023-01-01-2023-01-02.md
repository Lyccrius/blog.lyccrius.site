---
layout: post
title:  刷题记录
date:   2023-01-02
categories: oi train
---

## [$\color{#9D3DCF}P4155 [SCOI2015]国旗计划$](https://www.luogu.com.cn/problem/P4155)

环覆盖问题。

通过断环为链转化为线段覆盖问题。

对于一个战士 $i$，其后 $2^0$ 个士兵是固定的，即 $next = \max \\{ j \vert D_i \ge C_j \\}$。

倍增求出其后 $2^k$ 个士兵。

对于一次询问 $i$，倍增至 $C_i + M \lt D_j$。

将答案加上该士兵本身。

将答案加上用于奔袭在 $[C_i + M, D_j]$ 的士兵。

### 坑点

#### 开空间

$maxN$ 要 $\times 2$。

$logN$ 要 $+ 1$。

```cpp
int st[maxN * 2 + 10][logN + 1 + 10];
```

转移也是。

```cpp
    for (int p = 1; p <= logN + 1; p++) for (int i = 1; i <= N * 2; i++) st[i][p] = st[st[i][p - 1]][p - 1];
```

#### 断环为链

```cpp
    for (int i = 1; i <= N; i++) {
        scanf("%lld%lld", &C[i], &D[i]);
        if (C[i] > D[i]) D[i] += M;
        soldier[i].id = i;
        soldier[i].l = C[i];
        soldier[i].r = D[i];
    }
    std::sort(soldier + 1, soldier + N + 1);
    for (int i = 1; i <= N; i++) {
        soldier[N + i].l = soldier[i].l + M;
        soldier[N + i].r = soldier[i].r + M;
    }
```

#### 预处理

```cpp
    int head = 0;
    for (int i = 1; i <= N * 2; i++) {
        while (head < N * 2 && soldier[head + 1].l <= soldier[i].r) head++;
        st[i][0] = head;
    }
```

#### 验证可行性

$st_{now, p}$ 为空可不行。

```cpp
   for (int i = 1; i <= N; i++) {
        int res = 2;
        int now = i;
        for (int p = logN + 1; p >= 0; p--) if (st[now][p] && soldier[st[now][p]].r < soldier[i].l + M) res += (1 << p), now = st[now][p];
        ans[soldier[i].id] = res;
    }
```

## [$\color{#3498DA}P4053 [JSOI2007] 建筑抢修$](https://www.luogu.com.cn/problem/P4053)

根据直觉按 $T_2$ 排序。

用 $T$ 记录已经花费的时间。

枚举每个建筑。

* 如果来得及：
    * 修理它并计数。
* 如果来不及：
    * 一定报废一栋建筑；
    * 考虑报废用时最长的建筑；
    * 在已经修理过的建筑中找到 $T_1$ 最大的建筑；
    * 若找到的 $T_1$ 比当前的 $T_1$ 大则进行替换：
        * 替换后 $S$ 不变；
        * 替换后 $T$ 减小，可用于修理更多建筑。

用堆维护已经修理过的 $T_1$。

```cpp
    for (int i = 1; i <= N; i++) {
        T += Building[i].T1;
        Heap.push(Building[i].T1);
        if (T <= Building[i].T2) S++;
        else T -= Heap.top(), Heap.pop();
    }
```

### 坑点

#### 贪心策略

仅仅按 $T_2$ 排序后贪心不一定是最优的，需要在中途进行转正。

$T_1$ 也是贪心策略的相关因素。

#### 直觉

直觉是按 $dT = T_2 - T_1$ 排序。

即能修复该建筑的最晚开始时间。

错误原因同上。

更大的 $T_1$ 意味着更少的修复。